<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini Football by San - Free Online Soccer Game | Play Now</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Play Mini Football by San - an exciting free online soccer game created by san! Choose from multiple characters, use special abilities, and score goals. The original mini football browser game by san.">
    <meta name="keywords" content="mini football by san, mini football san, soccer game by san, online football game, free soccer game, football browser game, mini soccer, sports game, san game developer">
    <meta name="author" content="san">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph Meta Tags (for social media sharing) -->
    <meta property="og:title" content="Mini Football by San - Free Online Soccer Game">
    <meta property="og:description" content="Play Mini Football by San - an exciting free online soccer game created by san! Choose from multiple characters, use special abilities, and score goals.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://minifootball.pages.dev">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Mini Football by San - Free Online Soccer Game">
    <meta name="twitter:description" content="Play Mini Football by San - an exciting free online soccer game created by san! Choose from multiple characters, use special abilities, and score goals."
    
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@900&display=swap" rel="stylesheet">
    <style>
        :root{
            --bg:#0b0f14;
            --panel:#1a202c;
            --field:#0e6f3b;
            --line:#e2e8f0;
            --accent:#48bb78;
            --accent-light:#81e6d9;
            --accent2:#f6ad55;
            --danger:#e53e3e;
            --kaiserA:#667eea;
            --kaiserB:#ed64a6;
            --glow:#ffffff;
            --robsan-dark-primary: #312e81;
            --robsan-dark-secondary: #4c1d95;
            --robsan-particle-color: rgba(68, 10, 107, 0.9);
            --robsan-particle-color-light: rgba(99, 58, 161, 0.7);
            --robsan-trail-color-start: rgba(20, 0, 40, 0.95);
            --robsan-trail-color-end: rgba(10, 0, 20, 0.7);
            --robsan-charge-aura-color1: rgba(30, 0, 50, 0.7);
            --robsan-charge-aura-color2: rgba(40, 0, 60, 0.4);
            --robsan-shadow-enhanced: rgba(15, 0, 30, 0.8);
            --robsan-void-enhanced: rgba(5, 0, 15, 0.9);
            --eclipse-aura-start: rgba(0, 0, 0, 0.8);
            --eclipse-aura-end: rgba(30, 0, 50, 0.4);
            --eclipse-line-color: rgba(50, 0, 80, 0.9);
            --eclipse-line-glow: rgba(100, 0, 150, 0.5);
            --void-dash-primary: #1e1b4b;
            --void-dash-secondary: #0c0a09;
            --void-trail-color-start: rgba(0, 0, 0, 0.9);
            --void-trail-color-end: rgba(50, 0, 80, 0.6);
            --xdrake-green-primary: #10b981;
            --xdrake-green-secondary: #059669;
            --xdrake-dash-trail-start: rgba(16, 185, 129, 0.9);
            --xdrake-dash-trail-end: rgba(5, 150, 105, 0.4);
            --xdrake-footwork-color: #6d4b2e;
            --xdrake-footwork-dust: rgba(109, 75, 46, 0.8);
            --xdrake-apex-aura-start: rgba(0, 100, 0, 0.95);
            --xdrake-apex-aura-end: rgba(100, 200, 100, 0.5);
            --xdrake-apex-ball-trail-start: rgba(0, 150, 0, 0.95);
            --xdrake-apex-ball-trail-end: rgba(0, 50, 0, 0.7);
            --xdrake-nature-essence: rgba(34, 197, 94, 0.8);
            --xdrake-earth-power: rgba(101, 69, 34, 0.9);
            --gojo-red-primary: #e53e3e;
            --gojo-red-secondary: #c53030;
            --gojo-blue-primary: #3182ce;
            --gojo-blue-secondary: #2c5282;
            --gojo-purple-primary: #805ad5;
            --gojo-purple-secondary: #553c9a;
            --gojo-red-trail-start: rgba(229, 62, 62, 0.9);
            --gojo-red-trail-end: rgba(197, 48, 48, 0.4);
            --gojo-blue-trail-start: rgba(49, 130, 206, 0.9);
            --gojo-blue-trail-end: rgba(44, 82, 130, 0.4);
            --gojo-purple-trail-start: rgba(128, 90, 213, 0.95);
            --gojo-purple-trail-end: rgba(85, 60, 154, 0.7);
            --gojo-aura-color: rgba(99, 102, 241, 0.5);
            --gojo-infinity-shimmer: rgba(255, 255, 255, 0.8);
            --gojo-domain-energy: rgba(128, 90, 213, 0.7);
            --eddie-primary: #1a202c;
            --eddie-secondary: #000000;
            --eddie-we-are-glow: rgba(255, 0, 0, 0.8);
            --eddie-we-are-aura: rgba(20, 20, 20, 0.5);
            --eddie-venom-strike-tendril-start: rgba(100, 0, 150, 0.9); /* Dark purple */
            --eddie-venom-strike-tendril-end: rgba(0, 0, 0, 0.8);    /* Black */
            --eddie-venom-strike-glow: rgba(150, 0, 200, 0.7); /* Brighter purple glow */
            --eddie-venom-strike-trail-start: rgba(30, 0, 50, 0.9);
            --eddie-venom-strike-trail-end: rgba(0, 0, 0, 0.6);
            --eddie-symbiote-montage-trail: rgba(100, 0, 150, 0.7);
            /* NEW ZEUS STYLES */
            --zeus-primary: #3b82f6; /* Blue */
            --zeus-secondary: #60a5fa; /* Lighter blue */
            --zeus-lightning-trail-start: rgba(59, 130, 246, 0.9);
            --zeus-lightning-trail-end: rgba(255, 255, 255, 0.6);
            --zeus-shield-aura: rgba(59, 130, 246, 0.4);
            --zeus-shield-glow: rgba(255, 255, 255, 0.7);
            --zeus-olympus-aura-start: rgba(253, 224, 71, 0.8); /* Yellow */
            --zeus-olympus-aura-end: rgba(59, 130, 246, 0.6); /* Blue */
            --zeus-olympus-ball-trail-start: rgba(253, 224, 71, 0.9);
            --zeus-olympus-ball-trail-end: rgba(255, 255, 255, 0.7);
            /* NEW ASHER STYLES */
            --asher-primary: #a78bfa; /* Light Purple */
            --asher-secondary: #7c3aed; /* Darker Purple */
            --asher-star-trail-start: rgba(233, 213, 255, 0.9); /* Light lavender */
            --asher-star-trail-end: rgba(167, 139, 250, 0.6); /* Light purple */
            --asher-teleport-burst: rgba(255, 255, 255, 0.9);
            --asher-arrival-glimmer: rgba(209, 213, 219, 0.8);
            /* NEW LEONARDO STYLES */
            --leonardo-primary: #06b6d4; /* Cyan */
            --leonardo-secondary: #0891b2; /* Darker Cyan */
            --leonardo-accent: #a5f3fc; /* Light Cyan */
            --leonardo-trail-start: rgba(6, 182, 212, 0.9);
            --leonardo-trail-end: rgba(165, 243, 252, 0.6);
            /* ENHANCED ANGUS STYLES */
            --angus-primary: #ffffff; /* White */
            --angus-secondary: #f3f4f6; /* Light Gray */
            --angus-accent: #e5e7eb; /* Lighter Gray */
            --angus-trail-start: rgba(255, 255, 255, 0.95);
            --angus-trail-end: rgba(243, 244, 246, 0.7);
            --angus-burst-color: rgba(255, 255, 255, 0.95);
            --angus-charge-glow: rgba(255, 255, 255, 0.85);
            --angus-time-distort: rgba(200, 200, 255, 0.6);
            --angus-teleport-shimmer: rgba(255, 255, 255, 0.9);
            /* NEW DIDDY STYLES */
            --diddy-primary: #8B4513; /* Saddle Brown */
            --diddy-secondary: #A0522D; /* Sienna */
            --diddy-accent: #CD853F; /* Peru */
            --diddy-oil-color: #FFD700; /* Gold */
            --diddy-oil-shimmer: rgba(255, 215, 0, 0.8);
            --diddy-ascension-glow: rgba(255, 215, 0, 0.9);
            --diddy-trail-start: rgba(139, 69, 19, 0.9);
            --diddy-trail-end: rgba(160, 82, 45, 0.6);
            --baby-oil-guy-subtitle-bg: rgba(0, 0, 0, 0.8);
            --baby-oil-guy-subtitle-text: #FFD700;
            /* EDDIE AWAKENING STYLES */
            --eddie-awakening-bg: #1e3a8a; /* Blue background */
            --eddie-awakening-fill: #22c55e; /* Green fill */
            --eddie-awakening-glow: rgba(0, 0, 0, 0.9); /* Black glow for awakened state */
            --eddie-awakening-aura: rgba(0, 0, 0, 0.8); /* Black aura */
            /* CRISTIANO STYLES */
            --cristiano-primary: #dc2626; /* Red */
            --cristiano-secondary: #16a34a; /* Green */
            --cristiano-accent: #fbbf24; /* Gold accent */
            --cristiano-power-shot-trail-start: rgba(255, 50, 50, 0.95);
            --cristiano-power-shot-trail-end: rgba(255, 215, 0, 0.8);
            --cristiano-tackle-burst: rgba(255, 215, 0, 0.95);
            --cristiano-spirit-aura-start: rgba(255, 50, 50, 0.9);
            --cristiano-spirit-aura-end: rgba(22, 163, 74, 0.8);
            --cristiano-trail-start: rgba(255, 50, 50, 0.95);
            --cristiano-trail-end: rgba(255, 215, 0, 0.8);
            --cristiano-power-glow: rgba(255, 215, 0, 0.9);
            --cristiano-shot-explosion: rgba(255, 100, 100, 0.95);
            /* HUDSON EMPEROR STYLES */
            --hudson-primary: #e91e63; /* Pink */
            --hudson-secondary: #3f51b5; /* Blue */
            --hudson-emperor-pink: rgba(233, 30, 99, 0.9);
            --hudson-emperor-blue: rgba(63, 81, 181, 0.9);
            --hudson-emperor-trail-start: rgba(233, 30, 99, 0.95);
            --hudson-emperor-trail-end: rgba(63, 81, 181, 0.7);
            --hudson-emperor-aura: rgba(200, 50, 150, 0.6);
            --hudson-emperor-glow: rgba(150, 100, 200, 0.8);
            /* SAJA-JIN STYLES */
            --saja-jin-primary: #4c1d95; /* Deep Purple */
            --saja-jin-secondary: #1e1b4b; /* Dark Indigo */
            --saja-jin-soul-blue: #3b82f6; /* Soul Blue */
            --saja-jin-demonic-red: #dc2626; /* Demonic Red */
            --saja-jin-trail-start: rgba(59, 130, 246, 0.95); /* Blue souls */
            --saja-jin-trail-end: rgba(76, 29, 149, 0.7); /* Purple fade */
            --saja-jin-heroism-aura: rgba(220, 38, 38, 0.8); /* Red demonic aura */
            --saja-jin-hypnotic-glow: rgba(168, 85, 247, 0.9); /* Purple hypnotic glow */
            --saja-jin-soul-particles: rgba(59, 130, 246, 0.8); /* Soul particle color */
            /* LINCOLN STYLES */
            --lincoln-primary: #32cd32; /* Lime Green */
            --lincoln-secondary: #228b22; /* Forest Green */
            --lincoln-accent: #90ee90; /* Light Green */
            --lincoln-shrek-green: rgba(50, 205, 50, 0.9);
            --lincoln-trail-start: rgba(50, 205, 50, 0.95);
            --lincoln-trail-end: rgba(34, 139, 34, 0.7);
            --lincoln-shrek-glow: rgba(144, 238, 144, 0.8);
            /* ABBY STYLES */
            --abby-primary: #ff1493; /* Deep Pink */
            --abby-secondary: #ff69b4; /* Hot Pink */
            --abby-accent: #ffc0cb; /* Light Pink */
            --abby-colossal-trail-start: rgba(255, 20, 147, 0.95);
            --abby-colossal-trail-end: rgba(255, 105, 180, 0.7);
            --abby-power-pin-glow: rgba(255, 69, 0, 0.9); /* Orange-red for pin effect */
            --abby-demon-drive-aura: rgba(139, 0, 139, 0.8); /* Dark magenta */
            --abby-demon-drive-trail: rgba(255, 0, 255, 0.9); /* Bright magenta */
            /* KORBIN STYLES */
            --korbin-primary: #ff6b35; /* Orange */
            --korbin-secondary: #f7931e; /* Light Orange */
            --korbin-accent: #ffa500; /* Gold Orange */
            --korbin-placeholder-trail-start: rgba(255, 107, 53, 0.9);
            --korbin-placeholder-trail-end: rgba(247, 147, 30, 0.6);
            --korbin-placeholder-glow: rgba(255, 165, 0, 0.8);
            /* WALLY STYLES */
            --wally-primary: #00bcd4; /* Cyan */
            --wally-secondary: #1565c0; /* Dark Blue */
            --wally-accent: #81d4fa; /* Light Cyan */
            --wally-rocket-boost-trail-start: rgba(0, 188, 212, 0.95);
            --wally-rocket-boost-trail-end: rgba(21, 101, 192, 0.7);
            --wally-speed-force-aura: rgba(0, 188, 212, 0.6);
            --wally-speed-force-dome: rgba(129, 212, 250, 0.4);
            --wally-flashy-lightning-glow: rgba(255, 255, 255, 0.9);
            --wally-flashy-lightning-aura: rgba(0, 188, 212, 0.8);
            --wally-trail-start: rgba(0, 188, 212, 0.95);
            --wally-trail-end: rgba(129, 212, 250, 0.7);
            /* 67 KID STYLES */
            --sixsevenkid-primary: #00bcd4; /* Cyan */
            --sixsevenkid-secondary: #2196f3; /* Blue */
            --sixsevenkid-accent: #ffffff; /* White */
            --sixsevenkid-shadow: #000000; /* Black */
            --sixsevenkid-trail-start: rgba(0, 188, 212, 0.95); /* Cyan trail */
            --sixsevenkid-trail-end: rgba(33, 150, 243, 0.7); /* Blue fade */
            --sixsevenkid-text-glow: rgba(0, 188, 212, 0.9); /* Cyan glow for 67 text */
            --sixsevenkid-mayhem-aura: rgba(255, 255, 255, 0.8); /* White aura */
            --sixsevenkid-blackout-overlay: rgba(0, 0, 0, 1); /* Complete black overlay */
        }
        *{box-sizing:border-box}
        html,body{height:100%}

        /* Level System Styles */
        .level-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 24px;
            background: var(--eddie-awakening-bg);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            z-index: 1000;
            padding: 0 20px;
        }
       
        .level-text {
            font-size: 0.9rem;
            color: var(--accent-light);
            text-shadow: 0 0 5px var(--glow);
            font-family: 'Nunito', sans-serif;
            position: absolute;
            left: 20px;
        }
       
        .progress-bar {
            width: 40%;
            height: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }
       
        .progress-fill {
            height: 100%;
            background: var(--eddie-awakening-fill);
            transition: width 0.3s ease;
            width: 0%;
            box-shadow: 0 0 10px var(--eddie-awakening-fill);
        }
       
        .level-goals {
            font-size: 0.9rem;
            color: var(--accent-light);
            text-shadow: 0 0 5px var(--glow);
            font-family: 'Nunito', sans-serif;
            position: absolute;
            right: 20px;
        }
       
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: var(--accent-light);
            text-shadow: 0 0 20px var(--glow);
            opacity: 0;
            pointer-events: none;
            animation: levelUpAnim 2s ease-out forwards;
            z-index: 1000;
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
        }
       
        @keyframes levelUpAnim {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        body{
            margin:0;
            display:flex;
            align-items:center;
            justify-content:center;
            flex-direction:column;
            background:radial-gradient(1000px 500px at 50% -10%, #1a202c 0%, var(--bg) 60%);
            color:var(--line);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .screen{
            position:absolute;
            inset:0;
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            transition:opacity 0.3s ease-in-out;
            opacity:0;
            visibility:hidden;
        }
        .screen.active{opacity:1; visibility:visible;}

        .main-menu{
            gap:28px;
        }
        .main-menu h1{
            font-size:3.8rem;
            margin:0 0 20px;
            text-align:center;
            color: var(--accent-light);
            text-shadow: 0 4px 12px rgba(0,0,0,0.5), 0 0 10px var(--glow);
            animation:popIn 0.6s cubic-bezier(.36,.07,.19,.97) both;
        }
        .menu-button{
            padding:12px 24px;
            border:2px solid var(--accent);
            border-radius:8px;
            background:linear-gradient(to bottom, rgba(72,187,120,0.2), rgba(72,187,120,0.1));
            color:var(--line);
            font-size:1.0rem;
            font-weight:bold;
            cursor:pointer;
            transition:transform 0.15s ease-in-out, background 0.15s ease-in-out, border-color 0.15s ease-in-out;
            width:180px;
            text-align:center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .menu-button:hover{
            transform:translateY(-2px);
            background:linear-gradient(to bottom, rgba(72,187,120,0.3), rgba(72,187,120,0.2));
            border-color: var(--accent-light);
        }
        .menu-button:active{transform:translateY(1px);}
       
        .menu-button.horizontal {
            width: 180px;
            margin: 0;
        }

        .menu-button.level-reset {
            background: linear-gradient(135deg, #10b981, #059669) !important;
            color: white !important;
            border: 2px solid #10b981 !important;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
            transition: all 0.3s ease;
        }

        .menu-button.level-reset:hover {
            background: linear-gradient(135deg, #059669, #047857) !important;
            border-color: #059669 !important;
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
            transform: translateY(-3px);
        }

        .menu-button.level-reset:active {
            transform: translateY(0px);
            box-shadow: 0 2px 10px rgba(16, 185, 129, 0.3);
        }

        .game-screen{
            gap:20px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .wrap{
            position:relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        canvas{
            background:linear-gradient(0deg, rgba(14,111,59,.95), rgba(12,98,52,.95));
            border:6px solid #2a4334;
            border-radius:12px;
            box-shadow:0 12px 30px rgba(0,0,0,.4);
        }
        .hud{position:absolute; inset:auto 20px 20px 20px; display:flex; justify-content:space-between; pointer-events:none; width: auto;}
        .hud > * {background:rgba(26, 32, 44, 0.85); border:1px solid rgba(255,255,255,0.05); backdrop-filter: blur(8px); padding:12px 18px; border-radius:8px; box-shadow: 0 6px 16px rgba(0,0,0,0.3);}

        #game-screen.active .hud {
            display: none;
        }

        .row{display:flex; gap:8px; align-items:center}
        .kbd{display:inline-block; padding:4px 8px; border-radius:4px; border:1px solid rgba(255,255,255,.1); font-weight:600; background:rgba(255,255,255,.04); font-size:0.9rem;}
        .powerbar{position:absolute; left:50%; transform:translateX(-50%); top:20px; width:60%; height:14px; border-radius:10px; background:rgba(255,255,255,.1); border:1px solid rgba(255,255,255,.15); overflow:hidden; box-shadow: 0 3px 8px rgba(0,0,0,0.4); transition: all 0.2s ease;}
        .fill{height:100%; width:0%; background:linear-gradient(90deg, var(--accent), var(--accent2), var(--accent-light)); border-radius:10px; transition:width .06s ease-out; box-shadow: 0 0 6px rgba(72,187,120,0.5);}
        .title{font-weight:700; letter-spacing:.3px; opacity:.9; font-size:1.1rem; color: var(--glow); text-shadow: 0 0 6px var(--glow);}
        .small{opacity:.7; font-size:0.85rem;}
        .badge{font-size:0.8rem; padding:3px 7px; border-radius:999px; border:1px solid rgba(255,255,255,.15); background:rgba(255,255,255,.05); margin-left:8px;}

        .movesbar{
            position:absolute;
            left:50%;
            bottom:20px;
            transform:translateX(-50%);
            display:flex; gap:16px; align-items:center; justify-content:center;
            padding:12px 20px; border-radius:10px; background:rgba(26, 32, 44, 0.7);
            border:1px solid rgba(255,255,255,.06); backdrop-filter: blur(8px);
            box-shadow:0 8px 20px rgba(0,0,0,.35); z-index:10;
        }
        .slot{
            position:relative; min-width:180px; height:42px; border-radius:8px; overflow:hidden; cursor:default;
            border:1px solid rgba(255,255,255,.1); background:linear-gradient(90deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
            box-shadow: inset 0 1px 0 rgba(255,255,255,.04), 0 4px 12px rgba(0,0,0,.2);

        }

        .slot .label{position:absolute; inset:0; display:flex; align-items:center; gap:8px; padding:0 12px; font-weight:600; letter-spacing:.2px; color: var(--line); text-shadow: 0 0 4px var(--glow);}
        .slot .key{font-size:0.8rem; font-weight:700; padding:3px 6px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.05);}
        .slot .name{opacity:.9;}
        .slot .ready{position:absolute; inset:0; background:linear-gradient(90deg, var(--kaiserA), var(--kaiserB)); opacity:.15; border-radius: 8px;}
        .slot.robsan .ready { background: linear-gradient(90deg, var(--robsan-dark-primary), var(--robsan-dark-secondary)); opacity: 0.2; }
        .slot.robsan.eclipse-ready .ready { background: linear-gradient(90deg, var(--eclipse-aura-start), var(--eclipse-aura-end)); opacity: 0.25; }
        .slot.robsan.void-ready .ready { background: linear-gradient(90deg, var(--void-dash-primary), var(--void-dash-secondary)); opacity: 0.25; }
        .slot.xdrake.ready .ready { background: linear-gradient(90deg, var(--xdrake-green-primary), var(--xdrake-green-secondary)); opacity: 0.25; }
        .slot.xdrake.footwork-ready .ready { background: linear-gradient(90deg, var(--xdrake-footwork-color), var(--xdrake-green-secondary)); opacity: 0.25; }
        .slot.xdrake.apex-ready .ready { background: linear-gradient(90deg, var(--xdrake-apex-aura-start), var(--xdrake-apex-aura-end)); opacity: 0.25; }
        .slot.gojo.ready .ready { background: linear-gradient(90deg, var(--gojo-blue-primary), var(--gojo-red-primary)); opacity: 0.25; }
        .slot.gojo.gojo-red-ready .ready { background: linear-gradient(90deg, var(--gojo-red-primary), var(--gojo-red-secondary)); opacity: 0.25; }
        .slot.gojo.gojo-blue-ready .ready { background: linear-gradient(90deg, var(--gojo-blue-primary), var(--gojo-blue-secondary)); opacity: 0.25; }
        .slot.gojo.gojo-purple-ready .ready { background: linear-gradient(90deg, var(--gojo-purple-primary), var(--gojo-purple-secondary)); opacity: 0.25; }
        .slot.eddie.ready .ready { background: linear-gradient(90deg, var(--eddie-primary), var(--eddie-secondary)); opacity: 0.35; }
        .slot.zeus.ready .ready { background: linear-gradient(90deg, var(--zeus-primary), var(--zeus-secondary)); opacity: 0.25; } /* NEW ZEUS */
        .slot.asher.ready .ready { background: linear-gradient(90deg, var(--asher-primary), var(--asher-secondary)); opacity: 0.25; } /* NEW ASHER */


        .slot .pulse{position:absolute; inset:-1px; border-radius:inherit; border:1px solid transparent;}
        .slot.ready .pulse{animation:pulseGlow 1.2s ease-in-out infinite}
        .slot.robsan.ready .pulse {
             animation:pulseRobsanGlow 1.2s ease-in-out infinite;
        }
        .slot.robsan.eclipse-ready .pulse {
            animation:pulseEclipseGlow 1.2s ease-in-out infinite;
        }
        .slot.robsan.void-ready .pulse {
            animation:pulseVoidGlow 1.2s ease-in-out infinite;
        }

        .slot.xdrake.ready .pulse { animation:pulseXDDashGlow 1.2s ease-in-out infinite; }
        .slot.xdrake.footwork-ready .pulse { animation:pulseXDFootworkGlow 1.2s ease-in-out infinite; }
        .slot.xdrake.apex-ready .pulse { animation:pulseXDApexGlow 1.2s ease-in-out infinite; }
        .slot.gojo.gojo-red-ready .pulse { animation:pulseGojoRedGlow 1.2s ease-in-out infinite; }
        .slot.gojo.gojo-blue-ready .pulse { animation:pulseGojoBlueGlow 1.2s ease-in-out infinite; }
        .slot.gojo.gojo-purple-ready .pulse { animation:pulseGojoPurpleGlow 1.2s ease-in-out infinite; }
        .slot.eddie.ready .pulse { animation:pulseEddieGlow 1.2s ease-in-out infinite; }
        .slot.zeus.ready .pulse { animation:pulseZeusGlow 1.2s ease-in-out infinite; } /* NEW ZEUS */
        .slot.asher.ready .pulse { animation:pulseAsherGlow 1.2s ease-in-out infinite; } /* NEW ASHER */
        .slot.leonardo.ready .pulse { animation:pulseLeonardoGlow 1.2s ease-in-out infinite; }
.slot.leonardo.ready .ready { background: linear-gradient(90deg, var(--leonardo-primary), var(--leonardo-secondary)); opacity: 0.25; }
.slot.angus.ready .pulse { animation:pulseAngusGlow 1.2s ease-in-out infinite; }
.slot.angus.ready .ready { background: linear-gradient(90deg, var(--angus-primary), var(--angus-secondary)); opacity: 0.25; }

        .slot.diddy.ready .pulse { animation:pulseBabyOilGuyGlow 1.2s ease-in-out infinite; }
        .slot.diddy.ready .ready { background: linear-gradient(90deg, var(--diddy-primary), var(--diddy-secondary)); opacity: 0.25; }
        .slot.cristiano.ready .pulse { animation:pulseCristianoGlow 1.2s ease-in-out infinite; }
        .slot.cristiano.ready .ready { background: linear-gradient(90deg, var(--cristiano-primary), var(--cristiano-secondary)); opacity: 0.25; }
        .slot.hudson.ready .pulse { animation:pulseHudsonGlow 1.2s ease-in-out infinite; }
        .slot.hudson.ready .ready { background: linear-gradient(90deg, var(--hudson-primary), var(--hudson-secondary)); opacity: 0.25; }
        .slot.saja-jin.ready .pulse { animation:pulseSajaJinGlow 1.2s ease-in-out infinite; }
        .slot.saja-jin.ready .ready { background: linear-gradient(90deg, var(--saja-jin-primary), var(--saja-jin-secondary)); opacity: 0.25; }
        .slot.lincoln.ready .pulse { animation:pulseLincolnGlow 1.2s ease-in-out infinite; }
        .slot.lincoln.ready .ready { background: linear-gradient(90deg, var(--lincoln-primary), var(--lincoln-secondary)); opacity: 0.25; }
        .slot.abby.ready .pulse { animation:pulseAbbyGlow 1.2s ease-in-out infinite; }
        .slot.abby.ready .ready { background: linear-gradient(90deg, var(--abby-primary), var(--abby-secondary)); opacity: 0.25; }
        .slot.wally.ready .pulse { animation:pulseWallyGlow 1.2s ease-in-out infinite; }
        .slot.wally.ready .ready { background: linear-gradient(90deg, var(--wally-primary), var(--wally-secondary)); opacity: 0.25; }
        .slot.korbin.ready .pulse { animation:pulseKorbinGlow 1.2s ease-in-out infinite; }
        .slot.korbin.ready .ready { background: linear-gradient(90deg, var(--korbin-primary), var(--korbin-secondary)); opacity: 0.25; }
        .slot.sixsevenkid.ready .pulse { animation:pulse67KidGlow 1.2s ease-in-out infinite; }
        .slot.sixsevenkid.ready .ready { background: linear-gradient(90deg, var(--sixsevenkid-primary), var(--sixsevenkid-secondary)); opacity: 0.25; }

        @keyframes pulseGlow{
            0%{box-shadow:0 0 0 0 rgba(102,126,234,.3), 0 0 0 0 rgba(237,100,166,.3)}
            70%{box-shadow:0 0 0 8px rgba(102,126,234,0), 0 0 0 16px rgba(237,100,166,0)}
            100%{box-shadow:0 0 0 0 rgba(102,126,234,0), 0 0 0 0 rgba(237,100,166,0)}
        }
        @keyframes pulseRobsanGlow{
            0%{box-shadow:0 0 0 0 rgba(49,46,129,.3), 0 0 0 0 rgba(76,29,149,.3)}
            70%{box-shadow:0 0 0 8px rgba(49,46,129,0), 0 0 0 16px rgba(76,29,149,0)}
            100%{box-shadow:0 0 0 0 rgba(49,46,129,0), 0 0 0 0 rgba(76,29,149,0)}
        }
        @keyframes pulseEclipseGlow{
            0%{box-shadow:0 0 0 0 rgba(0,0,0,.4), 0 0 0 0 rgba(30,0,50,.4)}
            70%{box-shadow:0 0 0 8px rgba(0,0,0,0), 0 0 0 16px rgba(30,0,50,0)}
            100%{box-shadow:0 0 0 0 rgba(0,0,0,0), 0 0 0 0 rgba(30,0,50,0)}
        }
        @keyframes pulseVoidGlow{
            0%{box-shadow:0 0 0 0 rgba(30,27,75,.4), 0 0 0 0 rgba(12,10,9,.4)}
            70%{box-shadow:0 0 0 8px rgba(30,27,75,0), 0 0 0 16px rgba(12,10,9,0)}
            100%{box-shadow:0 0 0 0 rgba(30,27,75,0), 0 0 0 0 rgba(12,10,9,0)}
        }
        @keyframes pulseXDDashGlow{
            0%{box-shadow:0 0 0 0 rgba(16,185,129,.4), 0 0 0 0 rgba(5,150,105,.4)}
            70%{box-shadow:0 0 0 8px rgba(16,185,129,0), 0 0 0 16px rgba(5,150,105,0)}
            100%{box-shadow:0 0 0 0 rgba(16,185,129,0), 0 0 0 0 rgba(5,150,105,0)}
        }
        @keyframes pulseXDFootworkGlow{
            0%{box-shadow:0 0 0 0 rgba(109,75,46,.4), 0 0 0 0 rgba(5,150,105,.4)}
            70%{box-shadow:0 0 0 8px rgba(109,75,46,0), 0 0 0 16px rgba(5,150,105,0)}
            100%{box-shadow:0 0 0 0 rgba(109,75,46,0), 0 0 0 0 rgba(5,150,105,0)}
        }
        @keyframes pulseXDApexGlow{
            0%{box-shadow:0 0 0 0 rgba(0,100,0,.4), 0 0 0 0 rgba(100,200,100,.4)}
            70%{box-shadow:0 0 0 8px rgba(0,100,0,0), 0 0 0 16px rgba(100,200,100,0)}
            100%{box-shadow:0 0 0 0 rgba(0,100,0,0), 0 0 0 0 rgba(100,200,100,0)}
        }
        @keyframes pulseGojoRedGlow{
            0%{box-shadow:0 0 0 0 rgba(229,62,62,.4), 0 0 0 0 rgba(197,48,48,.4)}
            70%{box-shadow:0 0 0 8px rgba(229,62,62,0), 0 0 0 16px rgba(197,48,48,0)}
            100%{box-shadow:0 0 0 0 rgba(229,62,62,0), 0 0 0 0 rgba(197,48,48,0)}
        }
        @keyframes pulseGojoBlueGlow{
            0%{box-shadow:0 0 0 0 rgba(49,130,206,.4), 0 0 0 0 rgba(44,82,130,.4)}
            70%{box-shadow:0 0 0 8px rgba(49,130,206,0), 0 0 0 16px rgba(44,82,130,0)}
            100%{box-shadow:0 0 0 0 rgba(49,130,206,0), 0 0 0 0 rgba(44,82,130,0)}
        }
        @keyframes pulseGojoPurpleGlow{
            0%{box-shadow:0 0 0 0 rgba(128,90,213,.4), 0 0 0 0 rgba(85,60,154,.4)}
            70%{box-shadow:0 0 0 8px rgba(128,90,213,0), 0 0 0 16px rgba(85,60,154,0)}
            100%{box-shadow:0 0 0 0 rgba(128,90,213,0), 0 0 0 0 rgba(85,60,154,0)}
        }
        @keyframes pulseEddieGlow{
            0%{box-shadow:0 0 0 0 rgba(0,0,0,.4), 0 0 0 0 rgba(26,32,44,.4)}
            70%{box-shadow:0 0 0 8px rgba(0,0,0,0), 0 0 0 16px rgba(26,32,44,0)}
            100%{box-shadow:0 0 0 0 rgba(0,0,0,0), 0 0 0 0 rgba(26,32,44,0)}
        }
        /* NEW ZEUS KEYFRAMES */
        @keyframes pulseZeusGlow{
            0%{box-shadow:0 0 0 0 rgba(59,130,246,.4), 0 0 0 0 rgba(96,165,250,.4)}
            70%{box-shadow:0 0 0 8px rgba(59,130,246,0), 0 0 0 16px rgba(96,165,250,0)}
            100%{box-shadow:0 0 0 0 rgba(59,130,246,0), 0 0 0 0 rgba(96,165,250,0)}
        }
        /* NEW ASHER KEYFRAMES */
        @keyframes pulseAsherGlow{
            0%{box-shadow:0 0 0 0 rgba(167,139,250,.4), 0 0 0 0 rgba(233,213,255,.4)}
            70%{box-shadow:0 0 0 8px rgba(167,139,250,0), 0 0 0 16px rgba(233,213,255,0)}
            100%{box-shadow:0 0 0 0 rgba(167,139,250,0), 0 0 0 0 rgba(233,213,255,0)}
        }

        /* NEW LEONARDO KEYFRAMES */
        @keyframes pulseLeonardoGlow{
            0%{box-shadow:0 0 0 0 rgba(6,182,212,.4), 0 0 0 0 rgba(165,243,252,.4)}
            70%{box-shadow:0 0 0 8px rgba(6,182,212,0), 0 0 0 16px rgba(165,243,252,0)}
            100%{box-shadow:0 0 0 0 rgba(6,182,212,0), 0 0 0 0 rgba(165,243,252,0)}
        }
        /* NEW ANGUS KEYFRAMES */
        @keyframes pulseAngusGlow{
            0%{box-shadow:0 0 0 0 rgba(255,255,255,.4), 0 0 0 0 rgba(243,244,246,.4)}
            70%{box-shadow:0 0 0 8px rgba(255,255,255,0), 0 0 0 16px rgba(243,244,246,0)}
            100%{box-shadow:0 0 0 0 rgba(255,255,255,0), 0 0 0 0 rgba(243,244,246,0)}
        }
        /* NEW BABY OIL GUY KEYFRAMES */
        @keyframes pulseBabyOilGuyGlow{
            0%{box-shadow:0 0 0 0 rgba(139,69,19,.4), 0 0 0 0 rgba(255,215,0,.4)}
            70%{box-shadow:0 0 0 8px rgba(139,69,19,0), 0 0 0 16px rgba(255,215,0,0)}
            100%{box-shadow:0 0 0 0 rgba(139,69,19,0), 0 0 0 0 rgba(255,215,0,0)}
        }
        @keyframes pulseCristianoGlow{
            0%{box-shadow:0 0 0 0 rgba(220,38,38,.4), 0 0 0 0 rgba(22,163,74,.4)}
            70%{box-shadow:0 0 0 8px rgba(220,38,38,0), 0 0 0 16px rgba(22,163,74,0)}
            100%{box-shadow:0 0 0 0 rgba(220,38,38,0), 0 0 0 0 rgba(22,163,74,0)}
        }
        @keyframes pulseHudsonGlow{
            0%{box-shadow:0 0 0 0 rgba(233,30,99,.4), 0 0 0 0 rgba(63,81,181,.4)}
            70%{box-shadow:0 0 0 8px rgba(233,30,99,0), 0 0 0 16px rgba(63,81,181,0)}
            100%{box-shadow:0 0 0 0 rgba(233,30,99,0), 0 0 0 0 rgba(63,81,181,0)}
        }
        @keyframes pulseSajaJinGlow{
            0%{box-shadow:0 0 0 0 rgba(76,29,149,.4), 0 0 0 0 rgba(59,130,246,.4)}
            70%{box-shadow:0 0 0 8px rgba(76,29,149,0), 0 0 0 16px rgba(59,130,246,0)}
            100%{box-shadow:0 0 0 0 rgba(76,29,149,0), 0 0 0 0 rgba(59,130,246,0)}
        }
        @keyframes pulseLincolnGlow{
            0%{box-shadow:0 0 0 0 rgba(50,205,50,.4), 0 0 0 0 rgba(34,139,34,.4)}
            70%{box-shadow:0 0 0 8px rgba(50,205,50,0), 0 0 0 16px rgba(34,139,34,0)}
            100%{box-shadow:0 0 0 0 rgba(50,205,50,0), 0 0 0 0 rgba(34,139,34,0)}
        }
        @keyframes pulseAbbyGlow{
            0%{box-shadow:0 0 0 0 rgba(255,20,147,.4), 0 0 0 0 rgba(255,105,180,.4)}
            70%{box-shadow:0 0 0 8px rgba(255,20,147,0), 0 0 0 16px rgba(255,105,180,0)}
            100%{box-shadow:0 0 0 0 rgba(255,20,147,0), 0 0 0 0 rgba(255,105,180,0)}
        }
        @keyframes pulseWallyGlow{
            0%{box-shadow:0 0 0 0 rgba(0,188,212,.4), 0 0 0 0 rgba(21,101,192,.4)}
            70%{box-shadow:0 0 0 8px rgba(0,188,212,0), 0 0 0 16px rgba(21,101,192,0)}
            100%{box-shadow:0 0 0 0 rgba(0,188,212,0), 0 0 0 0 rgba(21,101,192,0)}
        }
        @keyframes pulseKorbinGlow{
            0%{box-shadow:0 0 0 0 rgba(255,107,53,.4), 0 0 0 0 rgba(247,147,30,.4)}
            70%{box-shadow:0 0 0 8px rgba(255,107,53,0), 0 0 0 16px rgba(247,147,30,0)}
            100%{box-shadow:0 0 0 0 rgba(255,107,53,0), 0 0 0 0 rgba(247,147,30,0)}
        }
        @keyframes pulse67KidGlow{
            0%{box-shadow:0 0 0 0 rgba(0,188,212,.4), 0 0 0 0 rgba(33,150,243,.4)}
            70%{box-shadow:0 0 0 8px rgba(0,188,212,0), 0 0 0 16px rgba(33,150,243,0)}
            100%{box-shadow:0 0 0 0 rgba(0,188,212,0), 0 0 0 0 rgba(33,150,243,0)}
        }

        /* SCOREBOARD STYLES */
        .scoreboard {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 80px;
            height: 120px;
            background: rgba(26, 32, 44, 0.9);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            backdrop-filter: blur(8px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
        }
       
        .scoreboard-left {
            left: 10px;
        }
       
        .scoreboard-right {
            right: 10px;
        }
       
        .scoreboard-title {
            font-size: 0.8rem;
            color: var(--accent-light);
            text-shadow: 0 0 5px var(--glow);
            margin-bottom: 8px;
        }
       
        .scoreboard-score {
            font-size: 2.5rem;
            color: var(--glow);
            text-shadow: 0 0 10px var(--accent-light);
            line-height: 1;
        }

        /* CAPTION ANIMATION STYLES */
        @keyframes captionFade {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        @keyframes captionSlideFromTop {
            0% { transform: translateX(-50%) translateY(-100%); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        @keyframes captionSlideFromBottom {
            0% { transform: translateX(-50%) translateY(100%); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        @keyframes captionSlideFromLeft {
            0% { transform: translateX(-150%) translateY(0); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        @keyframes captionSlideFromRight {
            0% { transform: translateX(50%) translateY(0); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        @keyframes captionBounce {
            0% { transform: translateX(-50%) scale(0); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.1); opacity: 1; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        @keyframes captionZoom {
            0% { transform: translateX(-50%) scale(0); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        @keyframes captionFadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .slot .cool{
            position:absolute; left:0; top:0; bottom:0; width:0%;
            background:linear-gradient(90deg, rgba(102,126,234,.8), rgba(237,100,166,.8));
            opacity:.2; border-radius: 8px;
        }
        .slot.robsan .cool {
             background:linear-gradient(90deg, var(--robsan-dark-primary), var(--robsan-dark-secondary));
        }
        .slot.robsan.eclipse-cool .cool {
             background:linear-gradient(90deg, var(--eclipse-line-color), var(--eclipse-line-glow));
        }
        .slot.robsan.void-cool .cool {
             background:linear-gradient(90deg, var(--void-dash-primary), var(--void-dash-secondary));
        }
        .slot.xdrake .cool {
             background:linear-gradient(90deg, var(--xdrake-green-primary), var(--xdrake-green-secondary));
        }
        .slot.xdrake.footwork-cool .cool {
             background:linear-gradient(90deg, var(--xdrake-footwork-color), var(--xdrake-green-secondary));
        }
        .slot.xdrake.apex-cool .cool {
             background:linear-gradient(90deg, var(--xdrake-apex-aura-start), var(--xdrake-apex-aura-end));
        }
        .slot.gojo.gojo-red-cool .cool { background: linear-gradient(90deg, var(--gojo-red-primary), var(--gojo-red-secondary)); }
        .slot.gojo.gojo-blue-cool .cool { background: linear-gradient(90deg, var(--gojo-blue-primary), var(--gojo-blue-secondary)); }
        .slot.gojo.gojo-purple-cool .cool { background: linear-gradient(90deg, var(--gojo-purple-primary), var(--gojo-purple-secondary)); }
        .slot.eddie .cool { background: linear-gradient(90deg, var(--eddie-primary), var(--eddie-secondary)); }
        .slot.zeus .cool { background: linear-gradient(90deg, var(--zeus-primary), var(--zeus-secondary)); } /* NEW ZEUS */
        .slot.asher .cool { background: linear-gradient(90deg, var(--asher-primary), var(--asher-secondary)); } /* NEW ASHER */
.slot.leonardo .cool { background: linear-gradient(90deg, var(--leonardo-primary), var(--leonardo-secondary)); }
        .slot.angus .cool { background: linear-gradient(90deg, var(--angus-primary), var(--angus-secondary)); }
        .slot.diddy .cool { background: linear-gradient(90deg, var(--diddy-primary), var(--diddy-secondary)); }
        .slot.korbin .cool { background: linear-gradient(90deg, var(--korbin-primary), var(--korbin-secondary)); }
        .slot.sixsevenkid .cool { background: linear-gradient(90deg, var(--sixsevenkid-primary), var(--sixsevenkid-secondary)); }

        .slot .coolText{position:absolute; right:8px; top:50%; transform:translateY(-50%); font-size:0.75rem; opacity:.7;}

        .modal-backdrop{
            position:fixed; inset:0; background:rgba(0,0,0,.7);
            backdrop-filter:blur(6px); z-index:100;
            display:flex; align-items:center; justify-content:center;
            opacity:0; visibility:hidden; transition:opacity 0.2s ease-in-out;
        }
        .modal-backdrop.open{opacity:1; visibility:visible;}
        .modal-content{
            background:var(--panel); border:1px solid rgba(255,255,255,.08);
            border-radius:12px; padding:32px; width:400px; max-width:90%;
            transform:scale(0.95) translateY(10px); transition:transform 0.3s cubic-bezier(.36,.07,.19,.97);
            box-shadow:0 10px 25px rgba(0,0,0,.5);
            color: var(--line);
            position: relative;
        }
        .modal-backdrop.open .modal-content{transform:scale(1) translateY(0);}
        .modal-content h2{margin-top:0; font-size:2.2rem; letter-spacing:.4px; color: var(--accent-light); text-shadow: 0 0 8px var(--glow);}
        .modal-content p{line-height:1.6; opacity:0.85; font-size:1rem; margin-bottom:0; color: var(--line);}
        .modal-content .close-button{
            position:absolute; top:10px; right:10px;
            padding:6px; background:none; border:none;
            color:rgba(255,255,255,0.7); font-size:1.4rem; cursor:pointer;
            transition:transform 0.15s ease-in-out, color 0.15s ease-in-out;
        }
        .modal-content .close-button:hover{color:var(--danger); transform:rotate(90deg);}
        .modal-content .toggle-container{
            display:flex; flex-direction:column; gap:10px; margin-top:20px;
        }
        .toggle-group{
            display:flex; flex-wrap: wrap; gap:8px;
            background:rgba(255,255,255,0.03); padding:5px; border-radius:8px;
            justify-content: center;
        }
        .toggle-button{
            flex:1; padding:10px 16px; border-radius:6px; cursor:pointer;
            background:transparent; transition:background 0.15s ease-in-out, color 0.15s ease-in-out, border-color 0.15s ease-in-out;
            border:1px solid transparent; font-weight:500; text-align:center; color: var(--line);
            min-width: 120px;
        }
        .toggle-button.active{background:var(--accent); color:var(--panel); border-color:var(--accent-light);}
        .toggle-button.robsan.active{background:var(--robsan-dark-primary); color:white; border-color:var(--robsan-dark-secondary);}
        .toggle-button.xdrake.active{background:var(--xdrake-green-primary); color:white; border-color:var(--xdrake-green-secondary);}
        .toggle-button.gojo.active{background:var(--gojo-blue-primary); color:white; border-color:var(--gojo-purple-primary);}
        .toggle-button.eddie.active{background:var(--eddie-primary); color:white; border-color:var(--eddie-secondary);}
        .toggle-button.zeus.active{background:var(--zeus-primary); color:white; border-color:var(--zeus-secondary);} /* NEW ZEUS */
        .toggle-button.asher.active{background:var(--asher-primary); color:white; border-color:var(--asher-secondary);} /* NEW ASHER */
        .toggle-button.leonardo.active{background:var(--leonardo-primary); color:white; border-color:var(--leonardo-secondary);}
        .toggle-button.angus.active{background:var(--angus-primary); color:black; border-color:var(--angus-secondary);}
        .toggle-button.diddy.active{background:var(--diddy-primary); color:white; border-color:var(--diddy-secondary);}
        .toggle-button:hover:not(.active){border-color: rgba(255,255,255,0.2);}

        .exit-icon-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(229, 62, 62, 0.8);
            border: 2px solid var(--danger);
            color: var(--line);
            font-size: 1.8rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.15s ease-in-out, background 0.15s ease-in-out, border-color 0.15s ease-in-out, color 0.15s ease-in-out;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .exit-icon-button:hover {
            background: var(--danger);
            color: white;
            transform: scale(1.05);
        }

        .exit-icon-button:active {
            transform: scale(0.95);
        }

        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 32, 44, 0.95);
            border: 2px solid var(--danger);
            border-radius: 8px;
            padding: 12px 20px;
            color: var(--line);
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
            backdrop-filter: blur(8px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        /* UNIVERSAL AWAKENING BAR STYLES */
        .awakening-bar {
            position: fixed; /* Fixed position relative to viewport */
            left: 50%;
            bottom: 10px; /* Very bottom of screen */
            transform: translateX(-50%);
            width: 60%; /* Make it wider */
            height: 25px; /* Taller for text */
            border-radius: 12px;
            background: linear-gradient(45deg, #1a202c, #2d3748);
            border: 2px solid rgba(0, 255, 255, 0.5);
            overflow: visible; /* Allow text to show */
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
            display: block;
            z-index: 10;
        }

        .awakening-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1rem;
            color: white; /* White text as requested */
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 11;
        }

        .awakening-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ffff, #0080ff);
            border-radius: 8px;
            transition: width 0.3s ease-out;
            box-shadow: 0 0 6px rgba(0, 255, 255, 0.6);
        }

        .awakening-bar.full .awakening-fill {
            animation: pulseAwakeningGlow 1.5s ease-in-out infinite;
        }

        /* AWAKENED MOVES BAR STYLES */
        .awakened-movesbar {
            position: absolute;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            border: 2px solid rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            z-index: 10;
        }

        .awakened-slot {
            position: relative;
            width: 70px;
            height: 50px;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 100, 255, 0.1));
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(0, 255, 255, 0.9);
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .awakened-slot:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 100, 255, 0.2));
            border-color: rgba(0, 255, 255, 0.8);
            transform: translateY(-2px);
        }

        .awakened-slot .label {
            text-align: center;
            font-size: 0.7rem;
        }

        .awakened-slot .key {
            display: block;
            font-size: 1rem;
            font-weight: bold;
            color: rgba(0, 255, 255, 1);
        }

        .awakened-slot .name {
            display: block;
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 2px;
        }

        @keyframes pulseAwakeningGlow {
            0% { box-shadow: 0 0 6px rgba(0, 255, 255, 0.6); }
            50% { box-shadow: 0 0 15px rgba(0, 255, 255, 1), 0 0 25px rgba(0, 255, 255, 0.8); }
            100% { box-shadow: 0 0 6px rgba(34, 197, 94, 0.6); }
        }

        .awakening-label {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--eddie-awakening-fill);
            text-shadow: 0 0 4px rgba(34, 197, 94, 0.8);
            opacity: 0.9;
        }

        .notification.show {
            opacity: 1;
            visibility: visible;
        }

        .notification.success {
            border-color: var(--accent);
            background: rgba(72, 187, 120, 0.15);
        }

        .notification.warning {
            border-color: var(--accent2);
            background: rgba(246, 173, 85, 0.15);
        }

        @keyframes popIn{
            0%{transform:scale(0.9); opacity:0;}
            100%{transform:scale(1); opacity:1;}
        }
       
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
            20%, 40%, 60%, 80% { transform: translateX(2px); }
        }

        @keyframes shrekGlow {
            0% {
                filter: brightness(1.2) contrast(1.3) saturate(1.5) drop-shadow(0 0 20px rgba(50, 205, 50, 0.8));
            }
            100% {
                filter: brightness(1.5) contrast(1.4) saturate(1.8) drop-shadow(0 0 40px rgba(50, 205, 50, 1));
            }
        }

        @keyframes chillGuyFloat {
            0% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
                filter: drop-shadow(0 0 20px rgba(255,255,255,0.8));
            }
            100% {
                transform: translate(-50%, -50%) scale(1.05) rotate(2deg);
                filter: drop-shadow(0 0 30px rgba(100,200,255,0.9));
            }
        }

        @keyframes superKickCharge {
            0% {
                transform: translate(-50%, -50%) scale(1);
                filter: brightness(1.5) contrast(1.4) drop-shadow(0 0 30px rgba(255,215,0,0.8));
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                filter: brightness(2) contrast(1.6) drop-shadow(0 0 60px rgba(255,215,0,1));
            }
            100% {
                transform: translate(-50%, -50%) scale(1.1);
                filter: brightness(1.8) contrast(1.5) drop-shadow(0 0 45px rgba(255,215,0,0.9));
            }
        }

        @keyframes megaShake {
            0%, 100% { transform: translateX(0) translateY(0); }
            5% { transform: translateX(-5px) translateY(-3px); }
            10% { transform: translateX(5px) translateY(3px); }
            15% { transform: translateX(-8px) translateY(-5px); }
            20% { transform: translateX(8px) translateY(5px); }
            25% { transform: translateX(-6px) translateY(-2px); }
            30% { transform: translateX(6px) translateY(2px); }
            35% { transform: translateX(-4px) translateY(-4px); }
            40% { transform: translateX(4px) translateY(4px); }
            45% { transform: translateX(-7px) translateY(-1px); }
            50% { transform: translateX(7px) translateY(1px); }
            55% { transform: translateX(-3px) translateY(-6px); }
            60% { transform: translateX(3px) translateY(6px); }
            65% { transform: translateX(-5px) translateY(-3px); }
            70% { transform: translateX(5px) translateY(3px); }
            75% { transform: translateX(-2px) translateY(-2px); }
            80% { transform: translateX(2px) translateY(2px); }
            85% { transform: translateX(-4px) translateY(-1px); }
            90% { transform: translateX(4px) translateY(1px); }
            95% { transform: translateX(-1px) translateY(-1px); }
        }

        #tutorial-modal .modal-content {
            height: 60vh;
            overflow-y: auto;
            max-height: 80vh;
            width: 500px;
            padding-right: 20px;
        }
    </style>
</head>
<body>

    <div id="main-menu" class="screen active main-menu">
        <h1>mini Football!!!!wer!!</h1>
        <p style="color: white; font-size: 1rem; margin: 10px 0; text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 20px rgba(255,255,255,0.6), 0 0 30px rgba(255,255,255,0.4); text-align: center;">THIS GAME IS NOT COMPLETELY COMPLETED YET YOU WILL FIND ALOT OF BUGS, EDDIE AWAKENING STILL IN DEVELOPMENT</p>
        <p style="color: red; font-size: 0.95rem; margin: 10px 0; text-shadow: 0 0 10px rgba(255,0,0,0.8), 0 0 20px rgba(255,0,0,0.6), 0 0 30px rgba(255,0,0,0.4); text-align: right; padding-right: 20px;">[Current style im working on: Korbin, And the new style Wally West!]</p>
        <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 15px;">
            <button class="menu-button horizontal" id="play-btn">play</button>
            <button class="menu-button horizontal" id="level-boost-btn">add 15 levels SAN ONLY</button>
            <button class="menu-button horizontal level-reset" id="level-reset-btn">reset level</button>
        </div>
        <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 15px;">
            <button class="menu-button horizontal" id="tutorial-btn">tutorial</button>
            <button class="menu-button horizontal" id="styles-btn">styles</button>
            <button class="menu-button horizontal" id="credits-btn">credits</button>
        </div>
    </div>

    <div id="game-screen" class="screen game-screen">
        <button class="exit-icon-button" id="exit-game-btn">&times;</button>
        <div id="notification" class="notification"></div>
        <div class="wrap">
            <canvas id="game" width="960" height="560"></canvas>
            <div class="level-container">
                <div class="level-text">LEVEL <span id="level-number">1</span></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="level-progress"></div>
                </div>
                <div class="level-goals">GOALS: <span id="goals-progress">0</span>/<span id="goals-needed">2</span></div>
            </div>
            <!-- Scoreboards -->
            <div class="scoreboard scoreboard-left">
                <div class="scoreboard-title">YOU</div>
                <div class="scoreboard-score" id="score-left">0</div>
            </div>
            <div class="scoreboard scoreboard-right">
                <div class="scoreboard-title">AI</div>
                <div class="scoreboard-score" id="score-right">0</div>
            </div>
            <div class="hud">
                <div class="card">
                    <div class="title">mini football<span class="badge">wasd to move mouse to aim click to shoot</span></div>
                    <div class="row small" style="margin-top:6px">
                        <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span style="opacity:.6">D</span>
                        <span style="opacity:.6">move</span>
                        <span class="kbd">Click</span> <span style="opacity:.6">shoot</span>
                        <span style="opacity:.6">hold auto shoot @ 3s</span>
                        <span style="opacity:.6">c hudson impact (need ball)</span>
                    </div>
                </div>
            </div>
            <div class="powerbar" id="powerbar" aria-hidden="true"><div class="fill" id="powerfill"></div></div>

            <!-- Baby Oil Guy Subtitles System -->
            <div id="baby-oil-guy-subtitles" style="position: absolute; top: 30px; left: 50%; transform: translateX(-50%); background: black; color: white; padding: 12px 24px; border-radius: 8px; font-size: 1.6rem; font-family: 'Nunito', sans-serif; font-weight: 900; text-align: center; z-index: 1000; display: none; min-width: 400px; border: 2px solid #3b82f6; box-shadow: 0 0 20px rgba(59, 130, 246, 0.5), 0 0 40px rgba(59, 130, 246, 0.3);">
                <span id="subtitle-text"></span>
            </div>
        </div>
        <div class="movesbar">
            <div id="slotC" class="slot" aria-label="Special Ability C">
                <div class="ready"></div>
                <div class="pulse"></div>
                <div class="cool" id="coolC"></div>
                <div class="label">
                    <span class="key">C</span>
                    <span class="name" id="ability-name-C">Hudson Impact</span>
                    <span class="coolText" id="coolCText"></span>
                </div>
            </div>
            <div id="slotV" class="slot" aria-label="Special Ability V">
                <div class="ready"></div>
                <div class="pulse"></div>
                <div class="cool" id="coolV"></div>
                <div class="label">
                    <span class="key">V</span>
                    <span class="name" id="ability-name-V">Eclipse Grasp</span>
                    <span class="coolText" id="coolVText"></span>
                </div>
            </div>
            <div id="slotX" class="slot" aria-label="Special Ability X">
                <div class="ready"></div>
                <div class="pulse"></div>
                <div class="cool" id="coolX"></div>
                <div class="label">
                    <span class="key">X</span>
                    <span class="name" id="ability-name-X">Void Dash</span>
                    <span class="coolText" id="coolXText"></span>
                </div>
            </div>
        </div>
        <!-- Universal Awakening Bar -->
        <div id="awakening-bar" class="awakening-bar">
            <div class="awakening-label" id="awakening-label">G - Awakening: 0%</div>
            <div id="awakening-fill" class="awakening-fill"></div>
        </div>
        
        <!-- Awakened Moves Bar (shown during awakening) -->
        <div id="awakened-movesbar" class="awakened-movesbar" style="display: none;">
            <div id="awakened-slotC" class="awakened-slot" aria-label="Awakened Ability C">
                <div class="ready"></div>
                <div class="cool" id="awakened-coolC"></div>
                <div class="label">
                    <span class="key">C</span>
                    <span class="name" id="awakened-ability-name-C">Last Fear</span>
                    <span class="coolText" id="awakened-coolCText"></span>
                </div>
            </div>
            <div id="awakened-slotV" class="awakened-slot" aria-label="Awakened Ability V">
                <div class="ready"></div>
                <div class="cool" id="awakened-coolV"></div>
                <div class="label">
                    <span class="key">V</span>
                    <span class="name" id="awakened-ability-name-V">Eyes Closed</span>
                    <span class="coolText" id="awakened-coolVText"></span>
                </div>
            </div>
            <div id="awakened-slotX" class="awakened-slot" aria-label="Awakened Ability X">
                <div class="ready"></div>
                <div class="cool" id="awakened-coolX"></div>
                <div class="label">
                    <span class="key">X</span>
                    <span class="name" id="awakened-ability-name-X">Part of my Desire</span>
                    <span class="coolText" id="awakened-coolXText"></span>
                </div>
            </div>
        </div>
    </div>

    <div id="credits-modal" class="modal-backdrop">
        <div class="modal-content">
            <button class="close-button" id="close-credits">&times;</button>
            <h2>credits</h2>
            <p>this game was diddiled by san, on a more serious note this game will continue getting new updates and i take my time making these typa stuff..</p>
            <p style="margin-top:12px;">everything wa made by me except the images, but i made the ball, player, and the field. i scripted it all, Frooty24 on youtube helped me with some of the style designs, like gojo, XDrake, etc he also makes the images. well not the ball or the player or the field </p>
        </div>
    </div>

    <div id="styles-modal" class="modal-backdrop">
        <div class="modal-content">
            <button class="close-button" id="close-styles">&times;</button>
            <h2>styles</h2>
            <div class="toggle-container">
                <div class="toggle-group">
                    <button class="toggle-button" id="style-none">none</button>
                    <button class="toggle-button" id="style-gojo">satoru gojo</button>
                    <button class="toggle-button" id="style-hudson">hudson</button>
                    <button class="toggle-button" id="style-robsan">robsan</button>
                    <button class="toggle-button" id="style-xdrake">xdrake</button>
                    <button class="toggle-button" id="style-eddie">eddie</button>
                    <button class="toggle-button" id="style-zeus">zeus</button>
                    <button class="toggle-button" id="style-asher">asher</button> <!-- NEW ASHER BUTTON -->
                    <button class="toggle-button" id="style-leonardo">leonardo</button>
                    <button class="toggle-button" id="style-angus">angus</button>
                    <button class="toggle-button" id="style-diddy">baby oil guy</button>
                    <button class="toggle-button" id="style-cristiano">cristiano</button>
                    <button class="toggle-button" id="style-saja-jin">saja-jin</button>
                    <button class="toggle-button" id="style-lincoln" style="opacity: 0.5; cursor: not-allowed;" title="Requires Level 15">lincoln (lvl 15)</button>
                    <button class="toggle-button" id="style-abby">abby saja</button>
                    <button class="toggle-button" id="style-korbin">korbin</button>
                    <button class="toggle-button" id="style-67kid">67 kid</button>
                    <button class="toggle-button" id="style-wally" style="opacity: 0.5; cursor: not-allowed;" title="Requires Level 50">wally (lvl 50)</button>
                </div>
            </div>
        </div>
    </div>

    <div id="tutorial-modal" class="modal-backdrop">
        <div class="modal-content">
            <button class="close-button" id="close-tutorial">&times;</button>
            <h2>how to play mini Football</h2>
            <p>welcome to mini FootBall heres a quick guide to get you started</p>
            <h3>objective</h3>
            <p>the goal is simple control your player get the ball and shoot it into the opponents goal</p>
            <h3>controls</h3>
            <ul>
                <li>movement use the <span class="kbd">W</span> <span class="kbd">A</span> <span class="kbd">S</span> <span class="kbd">D</span> keys to move your player around the field your player has some momentum so anticipate your movements</li>
                <li>aiming move your <span class="kbd">mouse</span> to aim where you want to kick the ball</li>
                <li>shooting
                    <ul>
                        <li><span class="kbd">Click</span> and release the mouse button to shoot the longer you hold it the more powerful your shot will be</li>
                        <li><span class="kbd">Hold</span> the mouse button for 3 seconds and your player will automatically unleash a powerful shot</li>
                    </ul>
                </li>
            </ul>
            <h3>special abilities</h3>
            <p>depending on your chosen style youll have unique special abilities</p>
            <ul>
                <li>Hudson Impact (Hudson Style) press the <span class="kbd">C</span> key when you have possession of the ball to launch it with incredible speed and visual effects</li>
                <li>Robsan Style
                    <ul>
                        <li>Shadow Spiral press the <span class="kbd">C</span> key with the ball to perform a spinning dark aura move for 2 seconds followed by a 2-second charge then a powerful shadowy shot</li>
                        <li>Eclipse Grasp press the <span class="kbd">V</span> key when you do not have the ball your player will emit a dark aura for 02 seconds then a wiggly black line will draw the ball directly to you in 05 seconds no matter its distance</li>
                        <li>Void Dash press the <span class="kbd">X</span> key to instantly dash a short distance in the direction of your mouse cursor can be used with or without the ball for quick repositioning</li>
                    </ul>
                </li>
                <li>XDRAKE Style
                    <ul>
                        <li>Supernova press the <span class="kbd">C</span> key to instantly dash a medium distance in the direction of your mouse cursor your player will turn green and leave a bright green trail no ball required</li>
                        <li>Fossilised Footwork press the <span class="kbd">V</span> key when you have the ball perform a quick short forward burst with earthy visual effects and a unique trail</li>
                        <li>Ancient Apex press the <span class="kbd">X</span> key when you have the ball your player glows green and unleashes an extremely powerful shot with a fierce green aura</li>
                    </ul>
                </li>
                <li>Satoru Gojo Style harness cursed energy for devastating effects
                    <ul>
                        <li>Red press the <span class="kbd">C</span> key when you have the ball after a short charge the ball turns vibrant red and is launched with immense power</li>
                        <li>Lapse Blue press the <span class="kbd">V</span> key when you do not have the ball a large blue cursed energy ball appears and orbits you rapidly if it touches the main soccer ball you instantly gain possession</li>
                        <li>Purple press the <span class="kbd">X</span> key when you have the ball two powerful cursed energy spheres red and blue are launched outwards for 15 seconds then converge in the middle to create a massive 'Purple' attack unleashing the most powerful shot imaginable towards your cursor</li>
                    </ul>
                </li>
                <li>Eddie Style:
                    <ul>
                        <li>We Are: press the <span class="kbd">C</span> key to turn black for 10 seconds and gain increased speed</li>
                        <li>Venom Strike: press the <span class="kbd">V</span> key when you **do not have the ball** to instantly grab it from a large range and immediately shoot with all your might (extremely fast retrieval, with a powerful tendril aura)</li>
                        <li>Symbiote Montage: press the <span class="kbd">X</span> key when you **have the ball** to rapidly teleport to 3 random locations on the field, leaving black puddles behind. After the third teleport, you'll instantly appear in the center of the field with the ball. You'll then have 1 second to aim with your cursor before automatically unleashing a powerful shot.</li>
                    </ul>
                </li>
                <li>Zeus Style:
                    <ul>
                        <li>Lightning Bolt: Press the <span class="kbd">C</span> key when you have the ball to charge and unleash a super-fast, precise shot with an electrifying trail.</li>
                        <li>Heavenly Shield: Press the <span class="kbd">V</span> key to activate a protective aura around you for 1.5 seconds. Any soccer ball entering this aura will have its velocity significantly reduced, making it easier to gain possession.</li>
                        <li>Olympus' Fury: Press the <span class="kbd">X</span> key to generate a powerful pull that draws the ball directly to you for 3 seconds (if you don't have it). Once you have possession, you'll have 1.5 seconds to aim before unleashing an ultra-powerful, arcing lightning shot.</li>
                    </ul>
                </li>
                <li>Asher Style:
                    <ul>
                        <li>Starfall Shot: Press the <span class="kbd">C</span> key when you have the ball to launch a shot that automatically homes in on the opponent's goal, leaving a starry trail.</li>
                        <li>Celestial Pull: Press the <span class="kbd">V</span> key when you do not have the ball to instantly teleport it to your position with a burst of light.</li>
                    </ul>
                </li>
                <li>all abilities have a cooldown period use them strategically</li>
            </ul>
            <h3>game interface</h3>
            <ul>
                <li>power bar located at the top of the screen this shows you the power of your shot when youre charging it</li>
                <li>moves bar at the bottom this bar displays the cooldown status and name of your active special abilityies watch for the ready indicator</li>
            </ul>
            <p>have fun and enjoy the game</p>
        </div>
    </div>

    <div id="ai-modal" class="modal-backdrop">
        <div class="modal-content">
            <button class="close-button" id="close-ai">&times;</button>
            <h2>Choose Game Mode</h2>
            <p>Select how you want to play</p>
            <div class="toggle-container">
                <div class="toggle-group" style="flex-direction: column; gap: 15px;">
                    <button class="menu-button" id="play-with-ai" style="width: 100%;">Play with AI</button>
                    <button class="menu-button" id="play-without-ai" style="width: 100%;">Play without AI Reccomended.</button>
                </div>
            </div>
        </div>
    </div>

    <div id="level-boost-modal" class="modal-backdrop">
        <div class="modal-content">
            <button class="close-button" id="close-level-boost">&times;</button>
            <h2>Level Boost</h2>
            <p>Enter the secret code to get 15 levels:</p>
            <input type="text" id="level-boost-code" placeholder="Enter code..." style="width: 100%; padding: 10px; margin: 10px 0; font-size: 16px; text-align: center; border: 2px solid #ddd; border-radius: 5px;">
            <button class="menu-button" id="submit-level-boost" style="width: 100%; margin-top: 10px;">Submit</button>
        </div>
    </div>

    <script>
        /*
         * TRYCAPTION STYLES AVAILABLE:
         * - 'Fade': Simple fade in and out
         * - 'SlideFromTop': Slides down from above
         * - 'SlideFromBottom': Slides up from below
         * - 'SlideFromLeft': Slides in from left
         * - 'SlideFromRight': Slides in from right
         * - 'Bounce': Bounces in with spring effect
         * - 'Zoom': Scales in and out
         * - 'Typewriter': Classic typewriter effect
         */

        // Universal Subtitle Function - Available everywhere
        function TrySubtitle(text, callback) {
            const subtitleEl = document.getElementById('baby-oil-guy-subtitles');
            const textEl = document.getElementById('subtitle-text');

            subtitleEl.style.display = 'block';
            textEl.textContent = '';

            let charIndex = 0;
            const typeInterval = setInterval(() => {
                if (charIndex < text.length) {
                    textEl.textContent += text[charIndex];
                    charIndex++;
                } else {
                    clearInterval(typeInterval);
                    setTimeout(() => {
                        subtitleEl.style.display = 'none';
                        if (callback) callback();
                    }, 1000); // Fade out after 1 second when finished writing
                }
            }, 50); // 50ms per character for typewriter effect
        }

        function Trycaption(text, style = 'Fade', callback) {
            const subtitleEl = document.getElementById('baby-oil-guy-subtitles');
            const textEl = document.getElementById('subtitle-text');

            // Clear any existing animations
            subtitleEl.style.animation = '';
            subtitleEl.style.display = 'block';
            textEl.textContent = text;

            // Apply entrance animation based on style
            switch(style.toLowerCase()) {
                case 'fade':
                    subtitleEl.style.animation = 'captionFade 0.5s ease-in-out';
                    break;
                case 'slidefromtop':
                    subtitleEl.style.animation = 'captionSlideFromTop 0.6s ease-out';
                    break;
                case 'slidefrombottom':
                    subtitleEl.style.animation = 'captionSlideFromBottom 0.6s ease-out';
                    break;
                case 'slidefromleft':
                    subtitleEl.style.animation = 'captionSlideFromLeft 0.6s ease-out';
                    break;
                case 'slidefromright':
                    subtitleEl.style.animation = 'captionSlideFromRight 0.6s ease-out';
                    break;
                case 'bounce':
                    subtitleEl.style.animation = 'captionBounce 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                    break;
                case 'zoom':
                    subtitleEl.style.animation = 'captionZoom 0.5s ease-out';
                    break;
                case 'typewriter':
                    // Special typewriter effect
                    textEl.textContent = '';
                    subtitleEl.style.animation = 'captionFade 0.3s ease-in-out';
                    let charIndex = 0;
                    const typeInterval = setInterval(() => {
                        if (charIndex < text.length) {
                            textEl.textContent += text[charIndex];
                            charIndex++;
                        } else {
                            clearInterval(typeInterval);
                        }
                    }, 40);
                    break;
                default:
                    subtitleEl.style.animation = 'captionFade 0.5s ease-in-out';
            }

            // Hide after 2.5 seconds with fade out
            setTimeout(() => {
                subtitleEl.style.animation = 'captionFadeOut 0.5s ease-in-out';
                setTimeout(() => {
                    subtitleEl.style.display = 'none';
                    if (callback) callback();
                }, 500);
            }, 2500);
        }

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;

        // NEW DIDDY OIL IMAGE SYSTEM
        const oilImage = new Image();
        let oilImageLoaded = false;
        oilImage.onload = function() {
            oilImageLoaded = true;
            console.log('Oil image loaded successfully!');
        };
        oilImage.onerror = function() {
            console.warn('Failed to load oil.png, using fallback effects');
        };
        oilImage.src = 'oil.png';

        let gameState = 'menu';
        let isPlaying = false;
        let currentStyle = 'hudson';
        let aiEnabled = false;

        const mainMenuScreen = document.getElementById('main-menu');
        const gameScreen = document.getElementById('game-screen');
        const playBtn = document.getElementById('play-btn');
        const tutorialBtn = document.getElementById('tutorial-btn');
        const stylesBtn = document.getElementById('styles-btn');
        const creditsBtn = document.getElementById('credits-btn');
        const levelBoostBtn = document.getElementById('level-boost-btn');
        const levelResetBtn = document.getElementById('level-reset-btn');
        const exitBtn = document.getElementById('exit-game-btn');

        const creditsModal = document.getElementById('credits-modal');
        const closeCreditsBtn = document.getElementById('close-credits');
        const stylesModal = document.getElementById('styles-modal');
        const closeStylesBtn = document.getElementById('close-styles');
        const tutorialModal = document.getElementById('tutorial-modal');
        const closeTutorialBtn = document.getElementById('close-tutorial');
        const aiModal = document.getElementById('ai-modal');
        const closeAiBtn = document.getElementById('close-ai');
        const playWithAiBtn = document.getElementById('play-with-ai');
        const playWithoutAiBtn = document.getElementById('play-without-ai');
       
        const levelBoostModal = document.getElementById('level-boost-modal');
        const closeLevelBoostBtn = document.getElementById('close-level-boost');
        const levelBoostCodeInput = document.getElementById('level-boost-code');
        const submitLevelBoostBtn = document.getElementById('submit-level-boost');

        const styleNoneBtn = document.getElementById('style-none');
        const styleHudsonBtn = document.getElementById('style-hudson');
        const styleRobsanBtn = document.getElementById('style-robsan');
        const styleXDrakeBtn = document.getElementById('style-xdrake');
        const styleGojoBtn = document.getElementById('style-gojo');
        const styleEddieBtn = document.getElementById('style-eddie');
        const styleZeusBtn = document.getElementById('style-zeus');
        const styleAsherBtn = document.getElementById('style-asher'); // NEW ASHER BUTTON
        const styleLeonardoBtn = document.getElementById('style-leonardo');
        const styleAngusBtn = document.getElementById('style-angus');
        const styleDiddyBtn = document.getElementById('style-diddy');
        const styleCristianoBtn = document.getElementById('style-cristiano');
        const styleSajaJinBtn = document.getElementById('style-saja-jin');
        const styleLincolnBtn = document.getElementById('style-lincoln');
        const styleAbbyBtn = document.getElementById('style-abby');
        const styleKorbinBtn = document.getElementById('style-korbin');
        const style67KidBtn = document.getElementById('style-67kid');
        const styleWallyBtn = document.getElementById('style-wally');

        const slotC = document.getElementById('slotC');
        const abilityNameCEl = document.getElementById('ability-name-C');
        const slotV = document.getElementById('slotV');
        const abilityNameVEl = document.getElementById('ability-name-V');
        const slotX = document.getElementById('slotX');
        const abilityNameXEl = document.getElementById('ability-name-X');

        // Eddie Awakening Elements
        const awakeningBar = document.getElementById('awakening-bar');
        const awakeningFill = document.getElementById('awakening-fill');

        const margin = 40;
        const goalW = 140, goalDepth = 18;

        const player = {
            x:W*0.25, y:H*0.5, r:18, speed:0, vx:0, vy:0, maxSpd:3.2, accel:0.6, drag:0.85, hasBall:false,
lastStealTime: 0, stealCooldown: 2000, // 2 second cooldown for player stealing
            spinning:false, spinTimer:0, charging:false, chargeTimer:0, telekinising:false,
            dashing:false, dashTimer:0,
            xdrakeSupernovaDashing: false, xdrakeSupernovaDashTimer: 0,
            xdrakeFossilFootworking: false, xdrakeFossilFootworkTimer: 0,
            xdrakeAncientApexCharging: false, xdrakeAncientApexChargeTimer: 0,
            // NEW ASHER PROPERTIES

            gojoRedCharging: false,
            gojoRedChargeStartTime: 0,
            gojoRedActive: false,
            gojoLapseBlueActive: false,
            gojoLapseBlueBall: null,
            gojoPurpleActive: false,
            gojoPurpleConverging: false,
            gojoPurpleConvergenceStartTime: 0,
            gojoPurpleLeftBall: null,
            gojoPurpleRightBall: null,
            gojoPurpleInitialDir: 0,
            gojoPurpleShotFired: false,

            eddieWeAreActive: false,
            eddieWeAreOriginalMaxSpd: 3.2, // Initialized correctly
            eddieWeAreEndTime: 0,
            eddieVenomStrikeActive: false,
            eddieVenomStrikeEndTime: 0,
            eddieSymbioteMontageActive: false,
            eddieSymbioteMontagePhase: '', // 'teleporting', 'aiming'
            eddieSymbioteMontageTeleportCount: 0,
            eddieSymbioteMontageCurrentTeleportTarget: {x:0, y:0},
            eddieSymbioteMontageTeleportStartTime: 0,
            eddieSymbioteMontageTeleportEndTime: 0,
            eddieSymbioteMontageStartPlayerPos: {x:0, y:0},
            eddieSymbioteMontageAimStartTime: 0,
            eddieSymbioteMontageShotFired: false,
            // EDDIE AWAKENING PROPERTIES
            eddieAwakeningProgress: 0, // 0-100%
            eddieAwakeningActive: false,
            eddieAwakeningEndTime: 0,
            eddieAwakeningVideoPlaying: false,
            
            // UNIVERSAL AWAKENING PROPERTIES
            awakeningProgress: 0, // 0-10 goals
            awakeningActive: false,
            awakeningEndTime: 0,
            awakeningEyesActive: false,
            awakeningAuraActive: false,
            
            // AWAKENING ABILITIES
            lastFearActive: false,
            lastFearEndTime: 0,
            partOfMyDesireActive: false,
            partOfMyDesireEndTime: 0,
            partOfMyDesireOriginalMaxSpd: 3.2,

            zeusLightningCharging: false,
            zeusLightningChargeStartTime: 0,
            zeusLightningActive: false,
            zeusHeavenlyShieldActive: false,
            zeusHeavenlyShieldEndTime: 0,
            zeusHeavenlyShieldRadius: 0,
            zeusOlympusFuryActive: false,
            zeusOlympusFuryPhase: '', // 'pulling', 'aiming'
            zeusOlympusFuryPullStartTime: 0,
            zeusOlympusFuryAimStartTime: 0,
            zeusOlympusFuryShotFired: false,
            zeusOlympusFuryOrigHasBall: false,
            // NEW ASHER PROPERTIES
// NEW ASHER PROPERTIES
            asherAutoGoalActive: false,
            asherStarfallCharging: false,
            asherStarfallChargeStartTime: 0,
            // NEW LEONARDO PROPERTIES
// NEW LEONARDO PROPERTIES
            leonardoFocusShotActive: false,
            leonardoShieldActive: false,
            leonardoShieldEndTime: 0,
            leonardoDashing: false,
            leonardoDashTimer: 0,
            leonardoDashEndX: 0, // For the new Pattern Weave VFX
            leonardoDashEndY: 0,
            // NEW ANGUS PROPERTIES
            angusCharging: false,
            angusChargeStartTime: 0,
            angusBurstUsesLeft: 3, // Can only use 3 times per game
            angusTimeStopActive: false,
            angusTimeStopEndTime: 0,
            angusTeleportActive: false,
            // NEW DIDDY PROPERTIES
            diddyBabyOilActive: false,
            diddyBabyOilPhase: '', // 'subtitle1', 'running', 'ascension', 'subtitle2'
            diddyBabyOilStartTime: 0,
            diddySlickShotActive: false,
            diddyOilSlickActive: false,
            diddyOilSlickEndTime: 0,
            // NEW DRIBBLING PROPERTIES
            isDribbling: false,
            dribbleEndTime: 0,
            // HUDSON EMPEROR DRIBBLE PROPERTIES
            hudsonEmperorDribbling: false,
            hudsonEmperorDribbleStartTime: 0,
            hudsonEmperorDribblePhase: '', // 'left', 'right'
            hudsonEmperorDribbleStartX: 0,
            hudsonEmperorDribbleStartY: 0,
            hudsonEmperorDribbleMouseDir: 0, // Store mouse direction when ability is triggered
            // SAJA-JIN PROPERTIES
            sajaJinDemonicHeroismActive: false,
            sajaJinDemonicHeroismEndTime: 0,
            sajaJinDemonicHeroismOriginalMaxSpd: 3.2,
            sajaJinSoulSuckingShotActive: false,
            sajaJinHypnoticShotActive: false,
            sajaJinHypnoticShotPhase: '', // 'spinning', 'left', 'caption', 'goal', 'burst'
            sajaJinHypnoticShotStartTime: 0,
            sajaJinHypnoticShotSpinAngle: 0,
            sajaJinHypnoticShotPlayerCenterX: 0,
            sajaJinHypnoticShotPlayerCenterY: 0
            ,sajaJinHypnoticLockUntil: 0,
            // LINCOLN PROPERTIES
            lincolnShrekMoveActive: false,
            lincolnShrekMovePhase: '', // 'shrek1_appear', 'shrek2_kick'
            lincolnShrekMoveStartTime: 0,
           
            // Lincoln Kiss Move Properties
            lincolnKissMoveActive: false,
            lincolnKissMovePhase: '', // 'gyat_appear', 'puddles', 'ball_movement'
            lincolnKissMoveStartTime: 0,
            lincolnKissBallDirection: 1, // 1 for right, -1 for left
            
            // Lincoln Gyatt Showdown Properties
            lincolnGyattShowdownActive: false,
            lincolnGyattShowdownEndTime: 0,
            lincolnGyattShowdownOriginalMaxSpd: 3.2,
            
            // WALLY PROPERTIES
            wallyRocketBoostActive: false,
            wallyRocketBoostEndTime: 0,
            wallySpeedForceActive: false,
            wallySpeedForceEndTime: 0,
            wallySpeedForceOriginalMaxSpd: 3.2,
            wallyFlashyLightningActive: false,
            wallyFlashyLightningEndTime: 0,
            wallyFlashyLightningOriginalMaxSpd: 3.2,
            
            // KORBIN BIG BACK POWER PROPERTIES
            korbinBigBackPowerActive: false,
            korbinBigBackPowerEndTime: 0,
            korbinBigBackPowerDirection: { x: 0, y: 0 },
            korbinBigBackPowerOriginalMaxSpd: 3.2,
            korbinBigBackPowerStunned: false
                };

        const ball = {
            x:W*0.5, y:H*0.5, r:10, vx:0, vy:0, friction:0.988, maxSpeed:Infinity,
            bounceDamping: 0.75, // Enhanced bounce physics
            // NEW ASHER BALL PROPERTIES
            isHoming: false,
            homingTargetX: 0,
            homingTargetY: 0,
            homingEndTime: 0,
        };

        // AI Player
        const aiPlayer = {
            x: W*0.75, y: H*0.5, r: 18, speed: 0, vx: 0, vy: 0, maxSpd: 2.8, accel: 0.5, drag: 0.85, hasBall: false,
            // AI behavior properties
            targetX: 0, targetY: 0,
            lastThinkTime: 0,
            thinkInterval: 100, // AI thinks every 100ms (faster decisions)
            state: 'chase', // 'chase', 'defend', 'shoot', 'position'
            shootPower: 0,
            shootCharging: false,
            shootStartTime: 0,
            lastShotTime: 0,
            shotCooldown: 1000, // 1 second between shots
            defensiveX: W*0.8, // AI defends closer to right goal
            skill: 0.8, // AI skill level (0-1), affects accuracy and decision making - IMPROVED!
            // NEW AI PROPERTIES FOR STUNNING AND BALL PICKUP
            isDribbling: false,
            isStunned: false,
            stunEndTime: 0,
            ballPickupAttemptTime: 0,
            lastBallPickupAttempt: 0,
            lastStealAttempt: 0,
            stealCooldown: 0, // No cooldown for AI
        };

        const keys = {};
        let mouse = {x:W/2, y:H/2, down:false};

        let chargeStart = 0; let autoShotFired = false; let autoTimer = null;
        const powerBar = document.getElementById('powerbar');
        const powerFill = document.getElementById('powerfill');
        const AUTO_MS = 2500; // Faster auto-shot for more dynamic gameplay

        const ABILITY_COOLDOWN = 5500; // Slightly faster cooldowns for smoother gameplay
        const ROBSAN_SPIN_DURATION = 2000;
        const ROBSAN_CHARGE_DURATION = 2000;
        const ECLIPSE_AURA_DURATION = 200;
        const ECLIPSE_RETRIEVAL_DURATION = 500;
        const VOID_DASH_DURATION = 200;
        const VOID_DASH_SPEED = 25;

        const XDRAKE_SUPERNOVA_DASH_DURATION = 250;
        const XDRAKE_SUPERNOVA_DASH_SPEED = 30;
        const XDRAKE_FOSSIL_FOOTWORK_DURATION = 150;
        const XDRAKE_FOSSIL_FOOTWORK_SPEED = 18;
        const XDRAKE_ANCIENT_APEX_CHARGE_DURATION = 1000;
        const XDRAKE_ANCIENT_APEX_SHOT_POWER = 32;

        const GOJO_RED_CHARGE_DURATION = 500;
        const GOJO_RED_SHOT_POWER = 28;
        const GOJO_LAPSE_BLUE_BALL_RADIUS = ball.r * 3;
        const GOJO_LAPSE_BLUE_ORBIT_RADIUS = player.r * 4;
        const GOJO_LAPSE_BLUE_ORBIT_SPEED = 10;
        const GOJO_PURPLE_SPREAD_DISTANCE = 100;
        const GOJO_PURPLE_CONVERGE_DURATION = 1500;
        const GOJO_PURPLE_FINAL_SHOT_POWER = 40;
        const GOJO_PURPLE_SHOCKWAVE_DURATION = 200;
        let gojoPurpleShockwaveEndTime = 0;

        const EDDIE_WE_ARE_DURATION = 10000;
        const EDDIE_WE_ARE_SPEED_BOOST = 2; // Multiplier for speed
        const EDDIE_VENOM_STRIKE_PULL_SPEED = 300; // Significantly faster
        const EDDIE_VENOM_STRIKE_SHOT_POWER = 35;
        const EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION = 1000; // 1 second aiming
        const EDDIE_SYMBIOTE_MONTAGE_SHOT_POWER = 25; // Adjusted shot power
        const EDDIE_SYMBIOTE_MONTAGE_TELEPORT_SPEED = 100; // Pixels per second for teleport
        const PUDDLE_DURATION = 1500; // Duration for black puddles

        const ZEUS_LIGHTNING_CHARGE_DURATION = 300;
        const ZEUS_LIGHTNING_SHOT_POWER = 28;
        const ZEUS_HEAVENLY_SHIELD_DURATION = 1500;
        const ZEUS_HEAVENLY_SHIELD_RADIUS = player.r * 3.5;
        const ZEUS_OLYMPUS_FURY_PULL_DURATION = 3000;
        const ZEUS_OLYMPUS_FURY_AIM_DURATION = 1500;
        const ZEUS_OLYMPUS_FURY_SHOT_POWER = 45;

        // NEW ASHER ABILITY CONSTANTS
        const ASHER_HOMING_SHOT_DURATION = 4000; // 4 seconds for the ball to home in
        const ASHER_HOMING_SHOT_POWER = 18;
        const ASHER_HOMING_TURN_RATE = 0.08; // How quickly the ball adjusts its course
        const ASHER_STARFALL_CHARGE_DURATION = 800; // 0.8 seconds
        const ASHER_STARFALL_ORBIT_SPEED = 25; // Radians per second
        const ASHER_STARFALL_ORBIT_RADIUS = player.r + ball.r + 15;


        // NEW LEONARDO ABILITY CONSTANTS
// NEW LEONARDO ABILITY CONSTANTS
        const LEONARDO_FOCUS_SHOT_POWER = 26;
        const LEONARDO_SHIELD_DURATION = 2500; // Increased duration to 2.5s
        const LEONARDO_SHIELD_RADIUS = player.r * 4.5; // Slightly larger shield
        const LEONARDO_SHIELD_PULL_STRENGTH = 0.03; // Slow pull effect
        const LEONARDO_DASH_DURATION = 200;
        const LEONARDO_DASH_SPEED = 28;
        const LEONARDO_PATTERN_FIELD_DURATION = 1000; // Field lasts for 1s after dash
        // NEW ANGUS ABILITY CONSTANTS
        const ANGUS_CHARGE_DURATION = 2000; // 2 second charge time
        const ANGUS_BURST_POWER = 45; // Very powerful shot
        const ANGUS_TIME_STOP_DURATION = 3000; // 3 seconds of time stop
        const ANGUS_TELEPORT_RANGE = 200; // Teleport range

        // NEW BABY OIL GUY ABILITY CONSTANTS
        const DIDDY_BABY_OIL_DURATION = 4000; // Total duration for baby oil sequence
        const DIDDY_SUBTITLE_DURATION = 1500; // Time for each subtitle
        const DIDDY_RUN_SPEED = 35; // Speed when running to ball
        const DIDDY_ASCENSION_SPEED = 25; // Speed of ball ascension
        const DIDDY_SLICK_SHOT_POWER = 30; // Slippery shot power
        const DIDDY_OIL_SLICK_DURATION = 5000; // Oil slick duration

        // CRISTIANO ABILITY CONSTANTS
        const CRISTIANO_POWER_SHOT_POWER = 35; // Extremely powerful unblockable shot
        const CRISTIANO_GOAT_TACKLE_RANGE = 200; // Extended range for teleporting to ball/AI
        const CRISTIANO_PORTUGUESE_SPIRIT_DURATION = 12000; // 12 seconds boost
        const CRISTIANO_PORTUGUESE_SPIRIT_SPEED_MULTIPLIER = 2.2; // Much higher speed boost
        const CRISTIANO_PORTUGUESE_SPIRIT_SHOT_POWER_BONUS = 25; // Much higher shot power bonus

        // HUDSON EMPEROR DRIBBLE CONSTANTS
        const HUDSON_EMPEROR_DRIBBLE_DURATION = 800;
        const HUDSON_EMPEROR_DRIBBLE_SPEED = 20; // Speed during dribble
        const HUDSON_EMPEROR_DRIBBLE_DISTANCE = W * 0.5; // Half field distance

        // UNIVERSAL AWAKENING CONSTANTS
        const AWAKENING_GOALS_REQUIRED = 10; // 10 goals to awaken
        const AWAKENING_DURATION = 30000; // 30 seconds
        const LAST_FEAR_DURATION = 5000; // 5 seconds shield
        const PART_OF_MY_DESIRE_DURATION = 8000; // 8 seconds
        const PART_OF_MY_DESIRE_SPEED_BOOST = 1.75; // 75% speed boost
        const PART_OF_MY_DESIRE_STRENGTH_BOOST = 1.4; // 40% shot power boost

        let abilityReadyAt = 0;
        let shadowSpiralReadyAt = 0;
        let eclipseGraspReadyAt = 0;
        let voidDashReadyAt = 0;

        let supernovaReadyAt = 0;
        let fossilFootworkReadyAt = 0;
        let ancientApexReadyAt = 0;

        let gojoRedReadyAt = 0;
        let gojoLapseBlueReadyAt = 0;
        let gojoPurpleReadyAt = 0;

        let eddieWeAreReadyAt = 0;
        let eddieVenomStrikeReadyAt = 0;
        let eddieSymbioteMontageReadyAt = 0;

        let zeusLightningReadyAt = 0;
        let zeusHeavenlyShieldReadyAt = 0;
        let zeusOlympusFuryReadyAt = 0;

        // NEW ASHER ABILITY TIMERS
        let asherAutoGoalReadyAt = 0;
        let asherBallTeleportReadyAt = 0;

        // NEW LEONARDO ABILITY TIMERS
        let leonardoFocusShotReadyAt = 0;
        let leonardoShieldReadyAt = 0;
        let leonardoDashReadyAt = 0;
        // NEW ANGUS ABILITY TIMERS
        let angusTimeStopReadyAt = 0;
        let angusTeleportReadyAt = 0;

        // NEW DIDDY ABILITY TIMERS
        let diddyBabyOilReadyAt = 0;
        let diddySlickShotReadyAt = 0;
        let diddyOilSlickReadyAt = 0;

        // CRISTIANO ABILITY TIMERS
        let cristianoPowerShotReadyAt = 0;
        let cristianoGoatTackleReadyAt = 0;
        let cristianoPortugueseSpiritReadyAt = 0;

        // SAJA-JIN ABILITY TIMERS
        let sajaJinDemonicHeroismReadyAt = 0;
        let sajaJinSoulSuckingShotReadyAt = 0;
        let sajaJinHypnoticShotReadyAt = 0;

        // LINCOLN ABILITY CONSTANTS
        const LINCOLN_SHREK_MOVE_DURATION = 5000; // Total Shrek sequence duration
        const LINCOLN_SHREK1_DURATION = 2000; // Time Shrek says "IM BOUTTA SHREK YOU LINCOLN"
        const LINCOLN_SHREK2_KICK_POWER = 10000; // Very powerful kick to goal

        // Lincoln Kiss Move Constants
        const LINCOLN_KISS_DURATION = 3000; // Total kiss sequence duration
        const LINCOLN_KISS_PUDDLE_DURATION = 1500; // White puddle effects duration
        const LINCOLN_KISS_BALL_MOVEMENT_DURATION = 1500; // Ball movement duration
        const LINCOLN_KISS_BALL_SPEED = 8; // Speed of ball back/forth movement

        // Lincoln Gyatt Showdown Constants
        const LINCOLN_GYATT_SHOWDOWN_DURATION = 10000; // 10 seconds
        const LINCOLN_GYATT_SHOWDOWN_SPEED_MULTIPLIER = 2; // 2x walk speed
        const LINCOLN_GYATT_SHOWDOWN_SHOT_MULTIPLIER = 5; // 5x shot power

        // LINCOLN ABILITY TIMERS
        let lincolnShrekMoveReadyAt = 0;
        let lincolnKissMoveReadyAt = 0;
        let lincolnGyattShowdownReadyAt = 0;
       
        // ABBY ABILITY TIMERS
        let abbyColossalCalvesReadyAt = 0;
        let abbyPowerPinReadyAt = 0;
        let abbyDemonDriveReadyAt = 0;

        // KORBIN ABILITY TIMERS
        let korbinFieryApocalypseReadyAt = 0;
        let korbinBigBackPowerReadyAt = 0;
        let korbinBigShotReadyAt = 0;

        // KORBIN ABILITY CONSTANTS
        const KORBIN_FIERY_APOCALYPSE_COOLDOWN = 8000; // 8 second cooldown
        const KORBIN_FIERY_APOCALYPSE_DAMAGE = 2.5; // Super powerful shot
        const KORBIN_FIERY_APOCALYPSE_RANGE = 150; // Fire effect range
        const KORBIN_BIG_BACK_POWER_COOLDOWN = 15000; // 15 second cooldown
        const KORBIN_BIG_BACK_POWER_SPEED = 10; // Moderate running speed (reduced from 35)
        const KORBIN_BIG_BACK_POWER_DURATION = 5000; // Max duration if not stopped
        const KORBIN_BIG_SHOT_COOLDOWN = 12000; // 12 second cooldown
        const KORBIN_BIG_SHOT_DAMAGE = 3.0; // Very powerful shot
        const KORBIN_BIG_SHOT_WIND_DURATION = 1200; // Wind effects duration

        // WALLY ABILITY TIMERS
        let wallyRocketBoostReadyAt = 0;
        let wallySpeedForceReadyAt = 0;
        let wallyFlashyLightningReadyAt = 0;

        // WALLY ABILITY CONSTANTS
        const WALLY_ROCKET_BOOST_COOLDOWN = 6000; // 6 second cooldown
        const WALLY_ROCKET_BOOST_DURATION = 400; // 0.4 second dash
        const WALLY_ROCKET_BOOST_SPEED = 75; // Very fast dash to cover 200+ pixels
        const WALLY_SPEED_FORCE_COOLDOWN = 10000; // 10 second cooldown
        const WALLY_SPEED_FORCE_DURATION = 3000; // 8 second duration
        const WALLY_SPEED_FORCE_RANGE = 300; // 300 px range
        const WALLY_SPEED_FORCE_SPEED_BOOST = 1.2; // 20% speed boost
        const WALLY_FLASHY_LIGHTNING_COOLDOWN = 12000; // 12 second cooldown
        const WALLY_FLASHY_LIGHTNING_DURATION = 3500; // 2 seconds
        const WALLY_FLASHY_LIGHTNING_SPEED_BOOST = 8.0; // 8x speed boost - MASSIVE!

        // 67KID ABILITY CONSTANTS
        const SIXTY_SEVEN_KID_MAYHEM_COOLDOWN = 15000; // 15 second cooldown
        const SIXTY_SEVEN_KID_MAYHEM_67_DISPLAY_DURATION = 1500; // 1 second of 67s
        const SIXTY_SEVEN_KID_MAYHEM_BLACKOUT_DURATION = 1670; // 0.67 seconds blackout
        const SIXTY_SEVEN_KID_MAYHEM_TOTAL_FROZEN_DURATION = 1670; // Total frozen time

        // 67KID ABILITY TIMERS
        let sixtySevenKidMayhemReadyAt = 0;

        // HUDSON ABILITY TIMERS
        let hudsonEmperorDribbleReadyAt = 0;
const HUDSON_EMPEROR_DRIBBLE_COOLDOWN = 10000;

        // SAJA-JIN ABILITY CONSTANTS
        const SAJA_JIN_DEMONIC_HEROISM_DURATION = 8000; // 8 seconds
        const SAJA_JIN_DEMONIC_HEROISM_SPEED_BOOST = 1.4; // 40% speed boost
        const SAJA_JIN_SOUL_SUCKING_SHOT_POWER = 28;
        const SAJA_JIN_SOUL_SUCKING_TRAIL_DURATION = 800;
        const SAJA_JIN_HYPNOTIC_SHOT_SPIN_DURATION = 3500; // 3.5 seconds spinning around player (longer, more hypnotic)
        const SAJA_JIN_HYPNOTIC_SHOT_SPIN_RADIUS = 70; // Slightly larger radius for more dramatic effect
        const SAJA_JIN_HYPNOTIC_SHOT_SPIN_SPEED = 0.08; // Much slower, more hypnotic rotation
        const SAJA_JIN_HYPNOTIC_SHOT_LEFT_DURATION = 1200; // Longer left movement
        const SAJA_JIN_HYPNOTIC_SHOT_CAPTION_DURATION = 2500; // Longer caption display
        const SAJA_JIN_HYPNOTIC_SHOT_GOAL_SPEED = 8; // Much slower, more controlled movement to goal
        const SAJA_JIN_HYPNOTIC_SHOT_BURST_RADIUS = 150; // Larger burst effect
        const SAJA_JIN_HYPNOTIC_SHOT_SPIRAL_LAYERS = 3; // Multiple spiral layers for hypnotic effect

        let vfx = {
            trail:[], trails:[], sparks:[], shockwaves:[], flashes:[], lines:[],
            robsanParticles:[], robsanAura:[], shadowTrails:[], robsanChargeAura:[],
            eclipseAura:[], eclipseLines:[], voidTrails:[],
            xdrakeSupernovaTrails: [], xdrakeFootworkDust: [], xdrakeApexAura: [],

            gojoRedTrail: [],
            gojoBlueOrbitParticles: [],
            gojoPurpleCombineVFX: [],
            gojoPurpleTrail: [],

// NEW LEONARDO VFX
            leonardoFocusText: [],
            leonardoFocusParticles: [],
            leonardoShieldAura: [],
            leonardoShieldParticles: [],
            leonardoDashTrail: [],
            leonardoDashParticles: [],
            leonardoPatternField: [], // For the new dash utility
            leonardoFocusTrail: [], // Fix: add missing array for focus shot trail
            // NEW ANGUS VFX
            angusChargeParticles: [],
            angusBurstVFX: [],
            angusTimeStopField: [],
            angusTeleportTrail: [],
            // NEW DIDDY VFX
            diddyOilParticles: [],
            diddyAscensionVFX: [],
            diddyOilSlicks: [],
            diddySlickTrail: [],

            // LINCOLN VFX
            lincolnGyattAura: [],
            lincolnGyattParticles: [],
            lincolnGyattTrail: [],

            // CRISTIANO VFX
            cristianoPowerShotTrail: [],
            cristianoGoatTackleParticles: [],
            cristianoPortugueseSpiritAura: [],
            cristianoMovementTrail: [],

            eddieWeAreAura: [],
            eddieWeAreParticles: [],
            eddieVenomTendrils: [],
            eddieVenomShotTrail: [],
            eddieSymbioteMontageAimAura: [],
            blackPuddles: [],

            zeusLightningParticles: [],
            zeusLightningTrail: [],
            zeusHeavenlyShieldWaves: [],
            zeusHeavenlyShieldAura: [],
            zeusOlympusFuryAura: [],
            zeusOlympusFuryBallTrail: [],
            zeusLightningChargeEffect: [],
            zeusOlympusFuryPullLines: [],
            zeusGroundScorches: [],

            // NEW ASHER VFX
            asherStarTrail: [],
            asherTeleportBurst: [],
            asherArrivalGlimmer: [],

            hudsonEmperorDribbleTrail: [],
            hudsonEmperorDribbleParticles: [],
            hudsonEmperorDribbleAura: [],
            robsanGroundRupture: [],
            robsanEclipseWisps: [],
            robsanVoidPuffs: [],
            xdrakeSupernovaGroundCrack: [],
            xdrakeFootworkLeaves: [],
            xdrakeAncientApexGroundBurst: [],
            gojoRedExplosion: [],
            gojoLapseBluePullEffect: [],
            gojoPurpleArcs: [],
            eddieWeAreRipples: [],
            eddieVenomBallSwirl: [],
            eddieTeleportFlicker: [],

            hudsonSpeedLines: [],
            hudsonEnergyWaves: [],
            robsanShadowClones: [],
            robsanVoidRifts: [],
            xdrakeNatureSpirits: [],
            xdrakeTerraforms: [],
            gojoInfinityBarriers: [],
            gojoDomainExpansions: [],
            eddieSymbioteSpikes: [],
            eddieVenomDrops: [],
            zeusThunderClouds: [],
            zeusLightningBolts: [],

            // SAJA-JIN VFX
            sajaJinDemonicAura: [],
            sajaJinSoulTrail: [], // ensured defined
            sajaJinSoulParticles: [], // ensured defined
            sajaJinGhostTrail: [], // New ghost trail for soul shot
            sajaJinHypnoticGlow: [], // ensured defined
            sajaJinHypnoticTrail: [], // Enhanced motion path with spiral effects
            sajaJinHypnoticSpinTrail: [], // Multi-layered spinning around player trail
            sajaJinHypnoticCaption: [], // Caption display
            sajaJinHypnoticBurst: [], // Enhanced final burst effect

            // ABBY PLACEHOLDER VFX (in case future specific arrays are referenced later)
            abbyColossalCalvesTrail: [],
            abbyPowerPinSparks: [],
            abbyDemonDriveAura: [],

            // LINCOLN VFX
            lincolnShrekParticles: [],
            lincolnShrekTrail: [],
            lincolnKissGyatGlow: [],
            lincolnKissWhitePuddles: [],
            lincolnKissBallTrail: [],
            lincolnKissHeartParticles: [],

            playerMovementTrail: [],

            fieldCracks: [],
            energyResidue: [],
            shockwaveRings: [],

            // NEW EPIC VFX SYSTEMS
            epicExplosions: [],
            massiveShockwaves: [],
            screenDistortions: [],
            energyNovas: [],
            particleStorms: [],
            chromaticAberrations: [],
            timeRipples: [],
            cosmicRifts: [],
            elementalBursts: [],
            dimensionalTears: [],
            powerSurges: [],
            mysticalRunes: [],
            energyMatrixes: [],
            celestialBeams: [],
            quantumFluctuations: [],
            vortexes: [],
            hyperTrails: [],
            auraExplosions: [],
            realityBreaks: [],
            cosmicWinds: [],

            // KORBIN VFX
            korbinFireApocalypseFlames: [],
            korbinFireApocalypseEmbers: [],
            korbinFireApocalypseExplosion: [],
            korbinFireApocalypseTrail: [],
            korbinFireApocalypseShockwave: [],
            korbinBigShotWindParticles: [],
            korbinBigShotWindSwirls: [],
            korbinBigShotWindTrail: [],
            korbinBigBackPowerWindTrail: [],
            korbinBigBackPowerWindBurst: [],
            korbinBigBackPowerShockwave: [],

            // WALLY VFX
            wallyRocketTrail: [],
            wallySpeedForceDome: [],
            wallySpeedForceAura: [],
            wallyLightningAura: [],
            wallyLightningBolts: [],
            wallyMovementTrail: [],

            // 67KID VFX
            sixtySevenKidTextClones: [],
            sixtySevenKidMayhemAura: [],
            sixtySevenKidBlackoutOverlay: []
        };

        let scoreL = 0;
        let scoreR = 0;
       
        // Level system variables
        let playerLevel = parseInt(localStorage.getItem('playerLevel')) || 1;
        let playerGoals = parseInt(localStorage.getItem('playerGoals')) || 0;
        let goalsForNextLevel = playerLevel * 2; // Level 1: 2 goals, Level 2: 4 goals, etc.
        let lastGoalTime = 0;

        let last = performance.now();

        let loopId = null;

        function setGameState(state) {
            gameState = state;
            mainMenuScreen.classList.remove('active');
            gameScreen.classList.remove('active');
            isPlaying = false;
            if (loopId) cancelAnimationFrame(loopId);

            if (state === 'menu') {
                mainMenuScreen.classList.add('active');

                const movesbarContainer = slotC.closest('.movesbar');
                if (movesbarContainer) movesbarContainer.style.display = 'none';
            } else if (state === 'game') {
                gameScreen.classList.add('active');
                const movesbarContainer = slotC.closest('.movesbar');
                if (movesbarContainer) movesbarContainer.style.display = 'flex';


                if (currentStyle === 'none') {
                    if (movesbarContainer) movesbarContainer.style.display = 'none';
                } else if (currentStyle === 'hudson') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'none';
                    slotX.style.display = 'none';
                } else if (currentStyle === 'asher') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'flex';
                    slotX.style.display = 'none';
                } else if (currentStyle === 'eddie' || currentStyle === 'zeus') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'flex';
                    slotX.style.display = 'flex';
                } else if (currentStyle === 'robsan' || currentStyle === 'xdrake' || currentStyle === 'gojo' || 
                          currentStyle === 'leonardo' || currentStyle === 'angus' || currentStyle === 'diddy' || 
                          currentStyle === 'cristiano' || currentStyle === 'saja-jin' || currentStyle === 'abby' ||
                          currentStyle === 'wally') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'flex';
                    slotX.style.display = 'flex';
                } else if (currentStyle === 'lincoln') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'flex';
                    slotX.style.display = 'none';
                } else if (currentStyle === '67kid') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'none';
                    slotX.style.display = 'none';
                }
                resetGame();
                isPlaying = true;
                loop();
            }
        }

        function showModal(modal) {
            modal.classList.add('open');
        }

        function hideModal(modal) {
            modal.classList.remove('open');
        }

        function setPlayerStyle(style) {
            currentStyle = style;

            styleNoneBtn.classList.toggle('active', style === 'none');
            styleHudsonBtn.classList.toggle('active', style === 'hudson');
            styleRobsanBtn.classList.toggle('active', style === 'robsan');
            styleXDrakeBtn.classList.toggle('active', style === 'xdrake');
            styleGojoBtn.classList.toggle('active', style === 'gojo');
            styleEddieBtn.classList.toggle('active', style === 'eddie');
            styleZeusBtn.classList.toggle('active', style === 'zeus');
            styleAsherBtn.classList.toggle('active', style === 'asher'); // NEW ASHER BUTTON
            styleLeonardoBtn.classList.toggle('active', style === 'leonardo'); // NEW LEONARDO BUTTON
            styleAngusBtn.classList.toggle('active', style === 'angus'); // NEW ANGUS BUTTON
            styleDiddyBtn.classList.toggle('active', style === 'diddy'); // NEW DIDDY BUTTON
            styleCristianoBtn.classList.toggle('active', style === 'cristiano');
            styleSajaJinBtn.classList.toggle('active', style === 'saja-jin');
            styleLincolnBtn.classList.toggle('active', style === 'lincoln');
            styleAbbyBtn.classList.toggle('active', style === 'abby');
            styleKorbinBtn.classList.toggle('active', style === 'korbin');
            style67KidBtn.classList.toggle('active', style === '67kid');
            styleWallyBtn.classList.toggle('active', style === 'wally');




            slotC.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher','leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'korbin', '67kid', 'wally', 'ready', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');
            slotV.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher','leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'korbin', '67kid', 'wally', 'ready', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');
            slotX.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher','leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'korbin', '67kid', 'wally', 'ready', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');

            if (style === 'hudson') {
                abilityNameCEl.textContent = 'Hudson Impact';
                abilityNameVEl.textContent = 'dribble like an emperor';
                abilityNameXEl.textContent = 'None';
                slotC.classList.add('hudson');
                slotV.classList.add('hudson');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'none';
            } else if (style === 'robsan') {
                abilityNameCEl.textContent = 'Shadow Spiral';
                abilityNameVEl.textContent = 'Eclipse Grasp';
                abilityNameXEl.textContent = 'Void Dash';
                slotC.classList.add('robsan');
                slotV.classList.add('robsan');
                slotX.classList.add('robsan');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'xdrake') {
                abilityNameCEl.textContent = 'Supernova';
                abilityNameVEl.textContent = 'Fossilised Footwork';
                abilityNameXEl.textContent = 'Ancient Apex';
                slotC.classList.add('xdrake');
                slotV.classList.add('xdrake');
                slotX.classList.add('xdrake');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'gojo') {
                abilityNameCEl.textContent = 'Red';
                abilityNameVEl.textContent = 'Lapse Blue';
                abilityNameXEl.textContent = 'Purple';
                slotC.classList.add('gojo');
                slotV.classList.add('gojo');
                slotX.classList.add('gojo');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'eddie') {
                slotC.classList.add('eddie');
                slotV.classList.add('eddie');
                slotX.classList.add('eddie');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
                // Show awakening bar for Eddie
                awakeningBar.style.display = 'block';
                updateAwakeningBar();
                // Update move names based on awakening state
                updateEddieAwakeningMoves();
            } else if (style === 'zeus') {
                abilityNameCEl.textContent = 'Lightning Bolt';
                abilityNameVEl.textContent = 'Heavenly Shield';
                abilityNameXEl.textContent = 'Olympus\' Fury';
                slotC.classList.add('zeus');
                slotV.classList.add('zeus');
                slotX.classList.add('zeus');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'asher') { // NEW ASHER STYLE BLOCK
                abilityNameCEl.textContent = 'Starfall Shot';
                abilityNameVEl.textContent = 'Celestial Pull';
                abilityNameXEl.textContent = 'None';
                slotC.classList.add('asher');
                slotV.classList.add('asher');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'none';
                } else if (style === 'leonardo') {
                abilityNameCEl.textContent = 'Focus Shot';
                abilityNameVEl.textContent = 'Sensory Shield';
                abilityNameXEl.textContent = 'Pattern Weave';
                slotC.classList.add('leonardo');
                slotV.classList.add('leonardo');
                slotX.classList.add('leonardo');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
                } else if (style === 'angus') {
                abilityNameCEl.textContent = `Power Burst (${player.angusBurstUsesLeft}/3)`;
                abilityNameVEl.textContent = 'Time Stop';
                abilityNameXEl.textContent = 'Shadow Teleport';
                slotC.classList.add('angus');
                slotV.classList.add('angus');
                slotX.classList.add('angus');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'diddy') {
                abilityNameCEl.textContent = 'Baby Oil Ascension';
                abilityNameVEl.textContent = 'Slick Shot';
                abilityNameXEl.textContent = 'Baby oil Blindness';
                slotC.classList.add('diddy');
                slotV.classList.add('diddy');
                slotX.classList.add('diddy');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'cristiano') {
                abilityNameCEl.textContent = 'Power Shot';
                abilityNameVEl.textContent = "GOAT's Tackle";
                abilityNameXEl.textContent = 'Portuguese Spirit';
                slotC.classList.add('cristiano');
                slotV.classList.add('cristiano');
                slotX.classList.add('cristiano');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'saja-jin') {
                abilityNameCEl.textContent = 'Demonic Heroism';
                abilityNameVEl.textContent = 'Soul-Sucking Shot';
                abilityNameXEl.textContent = 'Hypnotic Shot';
                slotC.classList.add('saja-jin');
                slotV.classList.add('saja-jin');
                slotX.classList.add('saja-jin');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'lincoln') {
                abilityNameCEl.textContent = 'Shrek Move';
                abilityNameVEl.textContent = 'Chill Guy Grasp';
                abilityNameXEl.textContent = 'None';
                slotC.classList.add('lincoln');
                slotV.classList.add('lincoln');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'none';
            } else if (style === 'abby') {
                abilityNameCEl.textContent = 'Colossal Calves';
                abilityNameVEl.textContent = 'Power Pin';
                abilityNameXEl.textContent = 'Demon Drive';
                slotC.classList.add('abby');
                slotV.classList.add('abby');
                slotX.classList.add('abby');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'korbin') {
                abilityNameCEl.textContent = 'Fiery Apocalypse';
                abilityNameVEl.textContent = 'Big Back Power';
                abilityNameXEl.textContent = 'Big Shot';
                slotC.classList.add('korbin');
                slotV.classList.add('korbin');
                slotX.classList.add('korbin');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === '67kid') {
                abilityNameCEl.textContent = '67 Mayhem';
                abilityNameVEl.textContent = 'None';
                abilityNameXEl.textContent = 'None';
                slotC.classList.add('67kid');
                slotC.style.display = 'flex';
                slotV.style.display = 'none';
                slotX.style.display = 'none';
            } else if (style === 'wally') {
                abilityNameCEl.textContent = 'Rocket Boost';
                abilityNameVEl.textContent = 'Speed Force';
                abilityNameXEl.textContent = 'Flashy Lightning';
                slotC.classList.add('wally');
                slotV.classList.add('wally');
                slotX.classList.add('wally');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            }
            else {
                abilityNameCEl.textContent = 'no ability';
                abilityNameVEl.textContent = 'no ability';
                abilityNameXEl.textContent = 'no ability';
                slotC.style.display = 'none';
                slotV.style.display = 'none';
                slotX.style.display = 'none';
            }

            // Show universal awakening bar only for Wally style
            if (style === 'wally') {
                awakeningBar.style.display = 'block';
                updateAwakeningBar();
            } else {
                awakeningBar.style.display = 'none';
            }

            const movesbarContainer = slotC.closest('.movesbar');
            movesbarContainer.style.display = (style === 'none') ? 'none' : 'flex';


            abilityReadyAt = 0;
            shadowSpiralReadyAt = 0;
            eclipseGraspReadyAt = 0;
            voidDashReadyAt = 0;
            supernovaReadyAt = 0;
            fossilFootworkReadyAt = 0;
            ancientApexReadyAt = 0;
            gojoRedReadyAt = 0;
            gojoLapseBlueReadyAt = 0;
            gojoPurpleReadyAt = 0;
            eddieWeAreReadyAt = 0;
            eddieVenomStrikeReadyAt = 0;
            eddieSymbioteMontageReadyAt = 0;
            zeusLightningReadyAt = 0;
            zeusHeavenlyShieldReadyAt = 0;
            zeusOlympusFuryReadyAt = 0;
            asherAutoGoalReadyAt = 0; // NEW ASHER
            asherBallTeleportReadyAt = 0; // NEW ASHER
            // Reset Cristiano ability timers
            cristianoPowerShotReadyAt = 0;
            cristianoGoatTackleReadyAt = 0;
            cristianoPortugueseSpiritReadyAt = 0;
            // Reset SAJA-JIN ability timers
            sajaJinDemonicHeroismReadyAt = 0;
            sajaJinSoulSuckingShotReadyAt = 0;
            sajaJinHypnoticShotReadyAt = 0;
            // Reset ABBY ability timers
            abbyColossalCalvesReadyAt = 0;
            abbyPowerPinReadyAt = 0;
            abbyDemonDriveReadyAt = 0;
            // Reset KORBIN ability timers
            korbinFieryApocalypseReadyAt = 0;
            korbinBigBackPowerReadyAt = 0;
            // Also reset Big Back Power state and ball protection
            if (player.korbinBigBackPowerActive) {
                player.korbinBigBackPowerActive = false;
                player.korbinBigBackPowerStunned = false;
                player.maxSpd = player.korbinBigBackPowerOriginalMaxSpd;
                if (ball.korbinBigBackProtected) {
                    ball.korbinBigBackProtected = false;
                }
            }
            // Reset WALLY ability timers
            wallyRocketBoostReadyAt = 0;
            wallySpeedForceReadyAt = 0;
            wallyFlashyLightningReadyAt = 0;
            // Reset 67KID ability timers
            sixtySevenKidMayhemReadyAt = 0;
            
            // Reset awakening system (only used by Wally)
            player.awakeningProgress = 0;
            if (player.awakeningActive) {
                player.awakeningActive = false;
                player.awakeningEndTime = 0;
                // Clear awakening abilities if active
                player.lastFearActive = false;
                player.lastFearEndTime = 0;
                player.partOfMyDesireActive = false;
                player.partOfMyDesireEndTime = 0;
                player.partOfMyDesireOriginalMaxSpd = 3.2;
            }
        }



        window.onload = function() {
            setGameState('menu');
            setPlayerStyle('hudson');
            initializeLevelSystem();
        };



        playBtn.addEventListener('click', () => showModal(aiModal));
        tutorialBtn.addEventListener('click', () => showModal(tutorialModal));
        creditsBtn.addEventListener('click', () => showModal(creditsModal));
        stylesBtn.addEventListener('click', () => showModal(stylesModal));
        levelBoostBtn.addEventListener('click', () => showModal(levelBoostModal));
        levelResetBtn.addEventListener('click', () => {
            // Reset player level to 1 (the initial level)
            playerLevel = 1;
            playerGoals = 0;
            goalsForNextLevel = playerLevel * 2; // Level 1 needs 2 goals
            updateLevelDisplay();
            showNotification('Level reset to beginning!', 'success');
        });
        exitBtn.addEventListener('click', () => setGameState('menu'));
        closeCreditsBtn.addEventListener('click', () => hideModal(creditsModal));
        closeStylesBtn.addEventListener('click', () => hideModal(stylesModal));
        closeTutorialBtn.addEventListener('click', () => hideModal(tutorialModal));
        closeAiBtn.addEventListener('click', () => hideModal(aiModal));
        closeLevelBoostBtn.addEventListener('click', () => hideModal(levelBoostModal));
       
        submitLevelBoostBtn.addEventListener('click', () => {
            const enteredCode = levelBoostCodeInput.value.trim();
            if (enteredCode === 'Sablol') {
                // Give 15 levels
                playerLevel += 15;
                updateLevelDisplay();
                showNotification('Code accepted! You gained 15 levels!', 'success');
                hideModal(levelBoostModal);
                levelBoostCodeInput.value = ''; // Clear the input
            } else {
                // Wrong code - just close the modal
                hideModal(levelBoostModal);
                levelBoostCodeInput.value = 'wrong one buddy bang bang'; // Clear the input
            }
        });
       
        // Allow Enter key to submit the code
        levelBoostCodeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitLevelBoostBtn.click();
            }
        });
        playWithAiBtn.addEventListener('click', () => {
            aiEnabled = true;
            hideModal(aiModal);
            setGameState('game');
        });
        playWithoutAiBtn.addEventListener('click', () => {
            aiEnabled = false;
            hideModal(aiModal);
            setGameState('game');
        });

        styleNoneBtn.addEventListener('click', () => setPlayerStyle('none'));
        styleHudsonBtn.addEventListener('click', () => setPlayerStyle('hudson'));
        styleRobsanBtn.addEventListener('click', () => setPlayerStyle('robsan'));
        styleXDrakeBtn.addEventListener('click', () => setPlayerStyle('xdrake'));
        styleGojoBtn.addEventListener('click', () => setPlayerStyle('gojo'));
        styleEddieBtn.addEventListener('click', () => setPlayerStyle('eddie'));
        styleZeusBtn.addEventListener('click', () => setPlayerStyle('zeus'));
        styleAsherBtn.addEventListener('click', () => setPlayerStyle('asher')); // NEW ASHER LISTENER
        styleLeonardoBtn.addEventListener('click', () => setPlayerStyle('leonardo'));
        styleAngusBtn.addEventListener('click', () => setPlayerStyle('angus'));
        styleDiddyBtn.addEventListener('click', () => setPlayerStyle('diddy'));
        styleCristianoBtn.addEventListener('click', () => setPlayerStyle('cristiano'));
        styleSajaJinBtn.addEventListener('click', () => setPlayerStyle('saja-jin'));
        styleLincolnBtn.addEventListener('click', () => {
            if (playerLevel >= 15) {
                setPlayerStyle('lincoln');
            } else {
                showNotification(`Lincoln requires level 15! You are level ${playerLevel}`, 'warning');
            }
        });
        styleAbbyBtn.addEventListener('click', () => setPlayerStyle('abby'));
        styleKorbinBtn.addEventListener('click', () => setPlayerStyle('korbin'));
        style67KidBtn.addEventListener('click', () => setPlayerStyle('67kid'));
        styleWallyBtn.addEventListener('click', () => {
            if (playerLevel >= 50) {
                setPlayerStyle('wally');
            } else {
                showNotification(`Wally requires level 50! You are level ${playerLevel}`, 'warning');
            }
        });

        window.addEventListener('keydown', e => {
            if (gameState !== 'game') return;
            const k = e.key.toLowerCase();
            keys[k] = true;

            if (k === 'e') {
                // E button now specifically for stealing ball from AI
                const now = performance.now();
                const d = Math.hypot(ball.x - player.x, ball.y - player.y);

                // If Saja-Jin Hypnotic Shot is commanding the ball or the final lock is active, disallow stealing/pickups
                const keydownHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                if (keydownHypnoticLocked) {
                    showNotification('Ball is under Hypnotic control — cannot steal now', 'info');
                    return;
                }

                // Check cooldown for player
                if (now - player.lastStealTime < player.stealCooldown) {
                    const cooldownLeft = Math.ceil((player.stealCooldown - (now - player.lastStealTime)) / 1000);
                    showNotification(`Steal on cooldown for ${cooldownLeft}s`, 'error');
                    return;
                }

                if (aiEnabled && aiPlayer.hasBall && d < player.r + ball.r + 20 && !player.hasBall && !player.eddieSymbioteMontageActive) {
                    // STEAL BALL FROM AI
                    aiPlayer.hasBall = false;
                    player.hasBall = true;
                    ball.vx = 0;
                    ball.vy = 0;
                    player.lastStealTime = now; // Set cooldown
                    aiPlayer.lastStolenFromTime = now; // Add AI steal cooldown
                    showNotification('yoink got the ball lol', 'success');
                } else if (!aiEnabled || !aiPlayer.hasBall) {
                    showNotification('e is for stealing from ai step on ball to pick up', 'info');
                } else if (d >= player.r + ball.r + 20) {
                    showNotification('too far from ai to steal smh', 'warning');
                } else if (player.hasBall) {
                    showNotification('you already got the ball bestie', 'info');
                }
            } else if (k === 'q') {
                // Dribbling mechanic
                if (player.hasBall && !player.isDribbling) {
                    player.isDribbling = true;
                    player.dribbleEndTime = performance.now() + 3000; // 3 seconds of dribbling
                    player.maxSpd *= 1.2; // Slight speed boost while dribbling
                    showNotification('dribbling activated fr', 'success');
                }
            } else if (k === 'c') {
                // Check if awakening is active first (only for Wally)
                if (currentStyle === 'wally' && player.awakeningActive) {
                    tryLastFear();
                } else if (currentStyle === 'hudson') {
                    tryKaiser();
                } else if (currentStyle === 'robsan') {
                    tryRobsanShadowSpiral();
                } else if (currentStyle === 'xdrake') {
                    tryXDrakeSupernova();
                } else if (currentStyle === 'gojo') {
                    tryGojoRed();
                } else if (currentStyle === 'eddie') {
                    if (player.eddieAwakeningActive) {
                        tryEddieVenomDevastation();
                    } else {
                        tryEddieWeAre();
                    }
                } else if (currentStyle === 'zeus') {
                    tryZeusLightningBolt();
                } else if (currentStyle === 'leonardo') {
                    tryLeonardoFocusShot();
                } else if (currentStyle === 'asher') { // NEW ASHER
                    tryAsherAutoGoal();
                } else if (currentStyle === 'angus') { // NEW ANGUS
                    tryAngusPowerBurst();
                } else if (currentStyle === 'diddy') { // NEW DIDDY
                    tryDiddyBabyOilAscension();
                } else if (currentStyle === 'cristiano') {
                    tryCristianoPowerShot();
                } else if (currentStyle === 'saja-jin') {
                    trySajaJinDemonicHeroism();
                } else if (currentStyle === 'lincoln') {
                    tryLincolnShrekMove();
                } else if (currentStyle === 'abby') {
                    tryAbbyColossalCalves();
                } else if (currentStyle === 'korbin') {
                    tryKorbinFieryApocalypse();
                } else if (currentStyle === '67kid') {
                    try67KidMayhem();
                } else if (currentStyle === 'wally') {
                    tryWallyRocketBoost();
                }
            } else if (k === 'v') {
                // Check if awakening is active first (only for Wally)
                if (currentStyle === 'wally' && player.awakeningActive) {
                    tryEyesClosed();
                } else if (currentStyle === 'hudson') {
                    tryHudsonEmperorDribble();
                } else if (currentStyle === 'robsan') {
                    tryRobsanEclipseGrasp();
                } else if (currentStyle === 'xdrake') {
                    tryXDrakeFossilFootwork();
                } else if (currentStyle === 'gojo') {
                    tryGojoLapseBlue();
                } else if (currentStyle === 'eddie') {
                    if (player.eddieAwakeningActive) {
                        tryEddieShadowRealm();
                    } else {
                        tryEddieVenomStrike();
                    }
                } else if (currentStyle === 'zeus') {
                    tryZeusHeavenlyShield();
                } else if (currentStyle === 'leonardo') {
                    tryLeonardoSensoryShield();

                } else if (currentStyle === 'asher') { // NEW ASHER
                    tryAsherBallTeleport();
                } else if (currentStyle === 'leonardo') {
                    tryLeonardoSensoryShield();
                } else if (currentStyle === 'angus') { // NEW ANGUS
                    tryAngusTimeStop();
                } else if (currentStyle === 'diddy') { // NEW DIDDY
                    tryDiddySlickShot();
                } else if (currentStyle === 'cristiano') {
                    tryCristianoGoatTackle();
                } else if (currentStyle === 'saja-jin') {
                    trySajaJinSoulSuckingShot();
                } else if (currentStyle === 'lincoln') {
                    tryLincolnKissMove();
                } else if (currentStyle === 'abby') {
                    tryAbbyPowerPin();
                } else if (currentStyle === 'korbin') {
                    tryKorbinBigBackPower();
                } else if (currentStyle === 'wally') {
                    tryWallySpeedForce();
                }
            } else if (k === 'x') {
                // Check if awakening is active first (only for Wally)
                if (currentStyle === 'wally' && player.awakeningActive) {
                    tryPartOfMyDesire();
                } else if (currentStyle === 'robsan') {
                    tryRobsanVoidDash();
                } else if (currentStyle === 'xdrake') {
                    tryXDrakeAncientApex();
                } else if (currentStyle === 'gojo') {
                    tryGojoPurple();
                } else if (currentStyle === 'eddie') {
                    tryEddieSymbioteMontage();
                } else if (currentStyle === 'zeus') {
                    tryZeusOlympusFury();
                } else if (currentStyle === 'leonardo') {
                    tryLeonardoPatternWeave();
                } else if (currentStyle === 'angus') { // NEW ANGUS
                    tryAngusShadowTeleport();
                } else if (currentStyle === 'diddy') { // NEW DIDDY
                    tryDiddyOilSlickTrap();
                } else if (currentStyle === 'cristiano') {
                    tryCristianoPortugueseSpirit();
                } else if (currentStyle === 'saja-jin') {
                    trySajaJinHypnoticShot();
                } else if (currentStyle === 'lincoln') {
                    tryLincolnGyattShowdown();
                } else if (currentStyle === 'abby') {
                    tryAbbyDemonDrive();
                } else if (currentStyle === 'korbin') {
                    tryKorbinBigShot();
                } else if (currentStyle === 'wally') {
                    tryWallyFlashyLightning();
                }
            } else if (k === 'g') {
                // Awakening Trigger - only for Wally style
                if (currentStyle === 'wally' && player.awakeningProgress >= AWAKENING_GOALS_REQUIRED && player.hasBall && !player.awakeningActive) {
                    triggerAwakening();
                }
                // Eddie Awakening Trigger (legacy)
                else if (currentStyle === 'eddie' && player.eddieAwakeningProgress >= 100 && player.hasBall && !player.eddieAwakeningActive) {
                    triggerEddieAwakening();
                }
            } else if (k === ' ') {
                // Space key - used for stopping Big Back Power move
                if (currentStyle === 'korbin' && player.korbinBigBackPowerActive) {
                    stopKorbinBigBackPower();
                }
            }
        });
        window.addEventListener('keyup', e => {
            if (gameState !== 'game') return;
            keys[e.key.toLowerCase()] = false;
        });
        canvas.addEventListener('mousemove', e => {
            if (gameState !== 'game') return;
            const rect = canvas.getBoundingClientRect();
            mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
            mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
        });
        canvas.addEventListener('mousedown', () => {
            if (gameState !== 'game') return;

            if (!player.spinning && !player.charging && !player.telekinising && !player.dashing &&
                !player.xdrakeSupernovaDashing && !player.xdrakeFossilFootworking && !player.xdrakeAncientApexCharging &&
                !player.gojoPurpleActive && !player.gojoRedCharging && !player.eddieVenomStrikeActive && !player.eddieSymbioteMontageActive &&
                !player.zeusLightningCharging && !player.zeusOlympusFuryActive && !player.asherAutoGoalActive &&
                player.hasBall) {
                mouse.down = true;
                chargeStart = performance.now();
                autoShotFired = false;
                powerBar.style.opacity = 1;
                autoTimer = setTimeout(() => {
                    if (mouse.down && player.hasBall && !autoShotFired) {
                        autoShotFired = true;
                        shoot(1.25);
                        endCharge();
                    }
                }, AUTO_MS);
            } else if (currentStyle === 'xdrake' && player.xdrakeAncientApexCharging) {
                 mouse.down = true;
                 powerBar.style.opacity = 1;
            } else if (currentStyle === 'gojo' && player.gojoRedCharging) {
                mouse.down = true;
                powerBar.style.opacity = 1;
            } else if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                 mouse.down = true;
                 powerBar.style.opacity = 1;
            } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming') {
                 mouse.down = true;
                 powerBar.style.opacity = 1;
            }
        });
        window.addEventListener('mouseup', () => {
            if (gameState !== 'game') return;

            if (!player.spinning && !player.charging && !player.telekinising && !player.dashing &&
                !player.xdrakeSupernovaDashing && !player.xdrakeFossilFootworking && !player.xdrakeAncientApexCharging &&
                !player.gojoPurpleActive && !player.gojoRedCharging && !player.asherAutoGoalActive &&
                mouse.down && player.hasBall && !autoShotFired && !player.zeusLightningCharging) {
                const held = (performance.now() - chargeStart);
                const t = clamp(held / AUTO_MS, 0, 1);
                const scale = lerp(0.55, 1.0, t);
                shoot(scale);
            } else if (currentStyle === 'xdrake' && player.xdrakeAncientApexCharging && mouse.down) {
                 xdrakeAncientApexShoot(1.0);
                 player.xdrakeAncientApexCharging = false;
                 endCharge();
            } else if (currentStyle === 'gojo' && player.gojoRedCharging) {
                if ((performance.now() - player.gojoRedChargeStartTime) < GOJO_RED_CHARGE_DURATION) {
                    player.gojoRedCharging = false;
                    clearTimeout(autoTimer);
                    endCharge();
                }
            } else if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                 if ((performance.now() - player.zeusLightningChargeStartTime) < ZEUS_LIGHTNING_CHARGE_DURATION) {
                    player.zeusLightningCharging = false;
                    clearTimeout(autoTimer);
                    endCharge();
                }
            } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming' && mouse.down) {
                 zeusOlympusFuryShoot();
            }
            endCharge();
        });

        const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
        const lerp=(a,b,t)=>a+(b-a)*t;

        function showNotification(message, type = 'error') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }

        function getRGBA(colorStr, alpha) {
            if (colorStr.startsWith('#')) {
                const hex = colorStr.slice(1);
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            } else if (colorStr.startsWith('rgb(')) {
                const parts = colorStr.slice(4, -1).split(',').map(s => s.trim());
                return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha})`;
            } else if (colorStr.startsWith('rgba(')) {
                const parts = colorStr.slice(5, -1).split(',').map(s => s.trim());
                const a = parseFloat(parts[3]);
                return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha * a})`;
            }

            return `rgba(0, 0, 0, ${alpha})`;
        }

        function endCharge(){
            mouse.down=false;
            chargeStart=0;
            clearTimeout(autoTimer); autoTimer=null;
            powerBar.style.opacity=0.6;
            powerFill.style.width='0%';
            // Smooth power bar reset
            powerFill.style.transition = 'width 0.3s ease-out';
            setTimeout(() => {
                powerFill.style.transition = 'width 0.06s ease-out';
            }, 300);
            player.gojoRedCharging = false;
            player.zeusLightningCharging = false;
        }


        function updatePlayer(dt){
            const now = performance.now();

            // Handle dribbling timeout
            if (player.isDribbling && now > player.dribbleEndTime) {
                player.isDribbling = false;
                player.maxSpd = player.maxSpd / 1.2; // Restore original speed
                showNotification('dribbling ended', 'info');
            }

            // Handle Hudson Emperor Dribble
            if (player.hudsonEmperorDribbling) {
                const dribbleDuration = now - player.hudsonEmperorDribbleStartTime;
                const halfDuration = HUDSON_EMPEROR_DRIBBLE_DURATION / 2;

                if (dribbleDuration <= halfDuration) {
                    // Left curve phase - use mouse direction with left offset
                    player.hudsonEmperorDribblePhase = 'left';
                    const progress = dribbleDuration / halfDuration;
                    const angle = player.hudsonEmperorDribbleMouseDir - Math.PI/3; // 60 degrees left of mouse direction
                    const targetX = player.hudsonEmperorDribbleStartX + Math.cos(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;
                    const targetY = player.hudsonEmperorDribbleStartY + Math.sin(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;

                    player.vx = (targetX - player.x) * 0.2;
                    player.vy = (targetY - player.y) * 0.2;
                } else if (dribbleDuration <= HUDSON_EMPEROR_DRIBBLE_DURATION) {
                    // Right curve phase - use mouse direction with right offset
                    player.hudsonEmperorDribblePhase = 'right';
                    const progress = (dribbleDuration - halfDuration) / halfDuration;
                    const leftAngle = player.hudsonEmperorDribbleMouseDir - Math.PI/3;
                    const midX = player.hudsonEmperorDribbleStartX + Math.cos(leftAngle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE;
                    const midY = player.hudsonEmperorDribbleStartY + Math.sin(leftAngle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE;

                    const angle = player.hudsonEmperorDribbleMouseDir + Math.PI/3; // 60 degrees right of mouse direction
                    const targetX = midX + Math.cos(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;
                    const targetY = midY + Math.sin(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;

                    player.vx = (targetX - player.x) * 0.2;
                    player.vy = (targetY - player.y) * 0.2;
                } else {
                    // End emperor dribble
                    player.hudsonEmperorDribbling = false;
                    player.hudsonEmperorDribblePhase = '';
                    player.vx = 0;
                    player.vy = 0;
                    showNotification('emperor dribble complete fr', 'success');
                }

            // Generate emperor dribble effects during movement
            if (Math.random() < 0.6) {
                vfx.hudsonEmperorDribbleTrail.push(newHudsonEmperorTrail(player.x, player.y, player.hudsonEmperorDribblePhase));
                vfx.hudsonEmperorDribbleParticles.push(newHudsonEmperorParticle(player.x, player.y, player.hudsonEmperorDribblePhase));
            }
            if (Math.random() < 0.3) {
                vfx.hudsonEmperorDribbleAura.push(newHudsonEmperorAura(player.x, player.y));
            }
        }

        // Generate Lincoln Gyatt Showdown VFX during movement
        if (currentStyle === 'lincoln' && player.lincolnGyattShowdownActive) {
            const now = performance.now();
            const timeLeft = (player.lincolnGyattShowdownEndTime - now) / LINCOLN_GYATT_SHOWDOWN_DURATION;
            
            // Generate continuous aura around player (reduced frequency)
            if (Math.random() < 0.3) {
                vfx.lincolnGyattAura.push({
                    x: player.x + (Math.random() - 0.5) * 40,
                    y: player.y + (Math.random() - 0.5) * 40,
                    life: 1000,
                    t: 0,
                    size: 15 + Math.random() * 10,
                    hue: 280 + Math.random() * 80, // Purple to magenta
                    intensity: timeLeft
                });
            }
            
            // Generate movement trail particles (reduced frequency)
            if (Math.random() < 0.2) {
                vfx.lincolnGyattTrail.push({
                    x: player.x + (Math.random() - 0.5) * 20,
                    y: player.y + (Math.random() - 0.5) * 20,
                    life: 800,
                    t: 0,
                    size: 8 + Math.random() * 6,
                    hue: 300 + Math.random() * 60,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2
                });
            }
            
            // Generate sparkle particles (reduced frequency)
            if (Math.random() < 0.1) {
                vfx.lincolnGyattParticles.push({
                    x: player.x + (Math.random() - 0.5) * 60,
                    y: player.y + (Math.random() - 0.5) * 60,
                    life: 1500,
                    t: 0,
                    size: 3 + Math.random() * 4,
                    hue: 280 + Math.random() * 100,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3
                });
            }
        }            // Handle Abby Demon Drive
            if (player.abbyDemonDriveActive) {
                const driveDuration = now - player.abbyDemonDriveStartTime;
               
                if (player.abbyDemonDrivePhase === 'forward' && driveDuration < 500) {
                    // Ball moves forward phase (500ms) - SUPER POWERED!
                    const progress = driveDuration / 500;
                    const moveDistance = 120; // MUCH more distance for super power!
                    const targetX = player.abbyDemonDriveStartX + Math.cos(player.abbyDemonDriveDirection) * moveDistance * progress;
                    const targetY = player.abbyDemonDriveStartY + Math.sin(player.abbyDemonDriveDirection) * moveDistance * progress;
                   
                    // BALL moves forward instead of player - DEMON POWER!
                    ball.x = targetX + Math.cos(player.abbyDemonDriveDirection) * 40;
                    ball.y = targetY + Math.sin(player.abbyDemonDriveDirection) * 40;
                    ball.vx = Math.cos(player.abbyDemonDriveDirection) * 30; // SUPER FAST!
                    ball.vy = Math.sin(player.abbyDemonDriveDirection) * 30;
                   
                    // INSANE DEMON AURA EXPLOSION AROUND BALL!
                    for(let i = 0; i < 25; i++) {
                        vfx.trails.push({
                            x: ball.x + (Math.random() - 0.5) * 120,
                            y: ball.y + (Math.random() - 0.5) * 120,
                            vx: (Math.random() - 0.5) * 25,
                            vy: (Math.random() - 0.5) * 25,
                            life: 65,
                            t: 0,
                            color: 'rgba(139, 0, 139, 0.98)', // ULTRA INTENSE magenta!
                            w: 16
                        });
                    }
                   
                    // MASSIVE DARK ENERGY STORM!
                    for(let i = 0; i < 20; i++) {
                        vfx.trails.push({
                            x: ball.x,
                            y: ball.y,
                            vx: (Math.random() - 0.5) * 30,
                            vy: (Math.random() - 0.5) * 30,
                            life: 50,
                            t: 0,
                            color: 'rgba(255, 0, 255, 0.95)', // ULTRA BRIGHT demon pink!
                            w: 14
                        });
                    }
                   
                    // DEMON ENERGY RINGS AROUND BALL!
                    for(let ring = 0; ring < 3; ring++) {
                        for(let i = 0; i < 15; i++) {
                            const angle = (i / 15) * Math.PI * 2;
                            const radius = 25 + (ring * 15);
                            vfx.trails.push({
                                x: ball.x + Math.cos(angle) * radius,
                                y: ball.y + Math.sin(angle) * radius,
                                vx: Math.cos(angle) * (18 + ring * 5),
                                vy: Math.sin(angle) * (18 + ring * 5),
                                life: 55 - ring * 10,
                                t: 0,
                                color: `rgba(${139 + ring * 30}, 0, ${139 + ring * 30}, 0.9)`,
                                w: 12 - ring * 2
                            });
                        }
                    }
                   
                    // HELLFIRE SPARKS!
                    for(let i = 0; i < 15; i++) {
                        vfx.trails.push({
                            x: ball.x + (Math.random() - 0.5) * 80,
                            y: ball.y + (Math.random() - 0.5) * 80,
                            vx: (Math.random() - 0.5) * 20,
                            vy: (Math.random() - 0.5) * 20,
                            life: 45,
                            t: 0,
                            color: 'rgba(75, 0, 130, 0.9)', // Deep purple hellfire!
                            w: 10
                        });
                    }
                   
                } else if (player.abbyDemonDrivePhase === 'forward' && driveDuration >= 500) {
                    // Switch to stun phase
                    player.abbyDemonDrivePhase = 'stun';
                    player.vx = 0;
                    player.vy = 0;
                    showNotification('Stunned! Preparing super kick...', 'info');
                   
                } else if (player.abbyDemonDrivePhase === 'stun' && driveDuration < 1500) {
                    // Stun phase (1000ms after forward movement)
                    player.vx = 0;
                    player.vy = 0;
                   
                    // MASSIVE DEMON STUN EFFECTS!
                    for(let i = 0; i < 20; i++) {
                        vfx.trails.push({
                            x: player.x + (Math.random() - 0.5) * 100,
                            y: player.y + (Math.random() - 0.5) * 100,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15,
                            life: 50,
                            t: 0,
                            color: 'rgba(255, 255, 0, 0.9)', // BRIGHT yellow stun!
                            w: 10
                        });
                    }
                   
                    // ELECTRIC DEMON STUN RINGS!
                    for(let i = 0; i < 15; i++) {
                        const angle = (i / 15) * Math.PI * 2;
                        vfx.trails.push({
                            x: player.x + Math.cos(angle) * 60,
                            y: player.y + Math.sin(angle) * 60,
                            vx: Math.cos(angle) * 12,
                            vy: Math.sin(angle) * 12,
                            life: 45,
                            t: 0,
                            color: 'rgba(255, 215, 0, 0.85)', // Golden electric stun!
                            w: 8
                        });
                    }
                   
                    // DEMON STUN SPARKS!
                    for(let i = 0; i < 25; i++) {
                        vfx.trails.push({
                            x: player.x + (Math.random() - 0.5) * 80,
                            y: player.y + (Math.random() - 0.5) * 80,
                            vx: (Math.random() - 0.5) * 10,
                            vy: (Math.random() - 0.5) * 10,
                            life: 40,
                            t: 0,
                            color: 'rgba(255, 255, 255, 0.8)', // White electric sparks!
                            w: 6
                        });
                    }
                   
                } else if (player.abbyDemonDrivePhase === 'stun' && driveDuration >= 1500) {
                    // Switch to kick phase
                    player.abbyDemonDrivePhase = 'kick';
                   
                    // Teleport to ball and kick it
                    player.x = ball.x - Math.cos(player.abbyDemonDriveDirection) * 25;
                    player.y = ball.y - Math.sin(player.abbyDemonDriveDirection) * 25;
                   
                    // ULTIMATE DEMON KICK - INSANELY POWERFUL!
                    player.hasBall = false;
                    ball.vx = Math.cos(player.abbyDemonDriveDirection) * 50; // EXTREME POWER!
                    ball.vy = Math.sin(player.abbyDemonDriveDirection) * 50;
                   
                    // ABSOLUTELY INSANE DEMON KICK EXPLOSION!
                    for(let i = 0; i < 80; i++) {
                        vfx.trails.push({
                            x: ball.x + (Math.random() - 0.5) * 200,
                            y: ball.y + (Math.random() - 0.5) * 200,
                            vx: (Math.random() - 0.5) * 40,
                            vy: (Math.random() - 0.5) * 40,
                            life: 90,
                            t: 0,
                            color: 'rgba(255, 0, 255, 0.98)', // ULTIMATE BRIGHT magenta!
                            w: 20
                        });
                    }
                   
                    // EPIC DEMON ENERGY SUPERNOVA!
                    for(let i = 0; i < 50; i++) {
                        const angle = (i / 50) * Math.PI * 2;
                        vfx.trails.push({
                            x: ball.x,
                            y: ball.y,
                            vx: Math.cos(angle) * 35,
                            vy: Math.sin(angle) * 35,
                            life: 70,
                            t: 0,
                            color: 'rgba(139, 0, 139, 0.95)', // INTENSE dark demon energy!
                            w: 16
                        });
                    }
                   
                    // DEMON PORTAL RIFTS!
                    for(let i = 0; i < 40; i++) {
                        vfx.trails.push({
                            x: ball.x + (Math.random() - 0.5) * 150,
                            y: ball.y + (Math.random() - 0.5) * 150,
                            vx: (Math.random() - 0.5) * 30,
                            vy: (Math.random() - 0.5) * 30,
                            life: 80,
                            t: 0,
                            color: 'rgba(75, 0, 130, 0.9)', // Deep purple rifts!
                            w: 14
                        });
                    }
                   
                    // HELLISH ENERGY WAVES!
                    for(let wave = 0; wave < 5; wave++) {
                        for(let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2;
                            const radius = 40 + (wave * 25);
                            vfx.trails.push({
                                x: ball.x + Math.cos(angle) * radius,
                                y: ball.y + Math.sin(angle) * radius,
                                vx: Math.cos(angle) * (30 + wave * 8),
                                vy: Math.sin(angle) * (30 + wave * 8),
                                life: 75 - wave * 10,
                                t: 0,
                                color: `rgba(${148 + wave * 20}, 0, ${211 - wave * 30}, 0.9)`,
                                w: 18 - wave * 3
                            });
                        }
                    }
                   
                    // DEMONIC FIRE EXPLOSION!
                    for(let i = 0; i < 35; i++) {
                        vfx.trails.push({
                            x: ball.x,
                            y: ball.y,
                            vx: (Math.random() - 0.5) * 45,
                            vy: (Math.random() - 0.5) * 45,
                            life: 65,
                            t: 0,
                            color: 'rgba(25, 0, 25, 0.85)', // Dark demon fire!
                            w: 12
                        });
                    }
                   
                    // End demon drive
                    player.abbyDemonDriveActive = false;
                    player.abbyDemonDrivePhase = '';
                    showNotification('DEMON DRIVE COMPLETE! Super kick!', 'success');
                }
            }

            let ax=0, ay=0;
            if(keys['w']||keys['arrowup']) ay-=player.accel;
            if(keys['s']||keys['arrowdown']) ay+=player.accel;
            if(keys['a']||keys['arrowleft']) ax-=player.accel;
            if(keys['d']||keys['arrowright']) ax+=player.accel;


            const isPlayerMovementRestricted = player.spinning || player.charging || player.telekinising || player.dashing ||
                                               player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking ||
                                               player.xdrakeAncientApexCharging || player.gojoPurpleActive || player.gojoRedCharging ||
                                               player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                               player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive ||
                                               player.abbyDemonDriveActive || player.sajaJinHypnoticShotActive || player.korbinBigBackPowerStunned;

            if (!isPlayerMovementRestricted) {

                // Smoother acceleration with interpolation
                const accelSmoothing = 0.8;
                player.vx = player.vx * accelSmoothing + (player.vx + ax) * (1 - accelSmoothing);
                player.vy = player.vy * accelSmoothing + (player.vy + ay) * (1 - accelSmoothing);

                const sp=Math.hypot(player.vx, player.vy);
                let currentMaxSpd = player.maxSpd;
                if (currentStyle === 'eddie' && player.eddieWeAreActive) {
                    currentMaxSpd = player.eddieWeAreOriginalMaxSpd * EDDIE_WE_ARE_SPEED_BOOST;
                }
                if (currentStyle === 'saja-jin' && player.sajaJinDemonicHeroismActive) {
                    currentMaxSpd = player.sajaJinDemonicHeroismOriginalMaxSpd * SAJA_JIN_DEMONIC_HEROISM_SPEED_BOOST;
                }
                if(sp>currentMaxSpd){ player.vx*=currentMaxSpd/sp; player.vy*=currentMaxSpd/sp; }

                if(ax===0 && ay===0){
                    // Enhanced drag with smoother deceleration
                    const smoothDrag = player.drag * 0.98;
                    player.vx *= smoothDrag;
                    player.vy *= smoothDrag;
                    // Stop very small movements to prevent jitter
                    if (Math.abs(player.vx) < 0.01) player.vx = 0;
                    if (Math.abs(player.vy) < 0.01) player.vy = 0;
                }
            } else {

                player.vx *= player.drag;
                player.vy *= player.drag;
            }

            // Symbiote Montage logic
            if (currentStyle === 'eddie' && player.eddieSymbioteMontageActive) {
                if (player.eddieSymbioteMontagePhase === 'teleporting') {
                    const progress = clamp((now - player.eddieSymbioteMontageTeleportStartTime) / (player.eddieSymbioteMontageTeleportEndTime - player.eddieSymbioteMontageTeleportStartTime), 0, 1);
                    player.x = lerp(player.eddieSymbioteMontageStartPlayerPos.x, player.eddieSymbioteMontageCurrentTeleportTarget.x, progress);
                    player.y = lerp(player.eddieSymbioteMontageStartPlayerPos.y, player.eddieSymbioteMontageCurrentTeleportTarget.y, progress);

                    if (player.hasBall) {
                        const ballOffsetDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                        ball.x = player.x + Math.cos(ballOffsetDir) * (player.r + ball.r + 4);
                        ball.y = player.y + Math.sin(ballOffsetDir) * (player.r + ball.r + 4);
                        ball.vx = player.vx;
                        ball.vy = player.vy;
                    }

                    if (progress >= 1) {
                        vfx.blackPuddles.push(newBlackPuddle(player.x, player.y));
                        player.eddieSymbioteMontageTeleportCount++;
                        if (player.eddieSymbioteMontageTeleportCount < 3) {
                            startNewSymbioteMontageTeleport();
                        } else {
                            player.x = W / 2;
                            player.y = H / 2;
                            player.vx = 0;
                            player.vy = 0;
                            const ballOffsetDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                            ball.x = player.x + Math.cos(ballOffsetDir) * (player.r + ball.r + 4);
                            ball.y = player.y + Math.sin(ballOffsetDir) * (player.r + ball.r + 4);
                            player.hasBall = true;

                            player.eddieSymbioteMontagePhase = 'aiming';
                            player.eddieSymbioteMontageAimStartTime = now;

                            vfx.eddieSymbioteMontageAimAura.push({
                                x: player.x, y: player.y,
                                end: now + EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION,
                                radius: player.r * 2.5,
                                t: 0, life: EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION
                            });
                        }
                    }
                } else if (player.eddieSymbioteMontagePhase === 'aiming') {
                    player.vx = 0;
                    player.vy = 0;

                    if (!player.eddieSymbioteMontageShotFired && (now - player.eddieSymbioteMontageAimStartTime) >= EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION) {

                        const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                        ball.vx = Math.cos(dir) * EDDIE_SYMBIOTE_MONTAGE_SHOT_POWER;
                        ball.vy = Math.sin(dir) * EDDIE_SYMBIOTE_MONTAGE_SHOT_POWER;
                        ball.maxSpeed = 100000;
                        player.hasBall = false;
                        player.eddieSymbioteMontageShotFired = true;


                        vfx.eddieVenomShotTrail.push({
                            end: performance.now() + 600,
                            w: 20,
                            colorStart: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-start'),
                            colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-end')
                        });
                        shockwave(player.x, player.y, 25, 'eddie-venom');

                        const origFric = ball.friction;
                        ball.friction = 0.99;
                        setTimeout(() => { ball.friction = origFric; ball.maxSpeed = 18; }, 600);

                        player.eddieSymbioteMontageActive = false;
                        player.eddieSymbioteMontageAimStartTime = 0;
                        player.eddieSymbioteMontageShotFired = false;
                    }
                }
            }


            // Store previous position for movement trails
            const prevX = player.x;
            const prevY = player.y;

            // Don't move player if frozen for kiss move or 67 mayhem
            if (!player._frozenForKissMove && !player._frozenFor67Mayhem) {
                player.x+=player.vx; player.y+=player.vy;
            }

            // Generate movement trail for Cristiano when Portuguese Spirit is active
            if (currentStyle === 'cristiano' && player.cristianoPortugueseSpiritActive) {
                const moveDistance = Math.hypot(player.x - prevX, player.y - prevY);
                if (moveDistance > 2) { // Only create trail when moving fast enough
                    vfx.cristianoMovementTrail.push({
                        startX: prevX,
                        startY: prevY,
                        endX: player.x,
                        endY: player.y,
                        life: 400,
                        t: 0
                    });
                }
            }

            const left=margin, right=W-margin, top=margin, bottom=H-margin;
            const currentR = player.r;
            if(player.x-currentR<left){ player.x=left+currentR; player.vx*=-0.2; }
            if(player.x+currentR>right){ player.x=right-currentR; player.vx*=-0.2; }
            if(player.y-currentR<top){ player.y=top+currentR; player.vy*=-0.2; }
            if(player.y+currentR>bottom){ player.y=bottom-currentR; player.vy*=-0.2; }


            if (player.spinning) {
                player.spinTimer -= dt;
                if (player.spinTimer <= 0) {
                    player.spinning = false;
                    player.spinTimer = 0;
                    player.charging = true;
                    player.chargeTimer = ROBSAN_CHARGE_DURATION;
                    vfx.robsanChargeAura.push({x:player.x, y:player.y, end:performance.now() + ROBSAN_CHARGE_DURATION, radius:player.r*1.2, t:0, life:ROBSAN_CHARGE_DURATION});
                }
            }
            if (player.charging) {
                player.chargeTimer -= dt;
                if (player.chargeTimer <= 0) {
                    player.charging = false;
                    player.chargeTimer = 0;
                }
            }

            if (player.dashing) {
                player.dashTimer -= dt;
                if (player.dashTimer <= 0) {
                    player.dashing = false;
                    player.dashTimer = 0;
                    vfx.robsanVoidPuffs.push(newRobsanVoidPuff(player.x, player.y, 'end'));
                }
            }

            if (player.xdrakeSupernovaDashing) {
                player.xdrakeSupernovaDashTimer -= dt;
                if (player.xdrakeSupernovaDashTimer <= 0) {
                    player.xdrakeSupernovaDashing = false;
                    player.xdrakeSupernovaDashTimer = 0;
                }
            }

            if (player.xdrakeFossilFootworking) {
                player.xdrakeFossilFootworkTimer -= dt;
                if (player.xdrakeFossilFootworkTimer <= 0) {
                    player.xdrakeFossilFootworking = false;
                    player.xdrakeFossilFootworkTimer = 0;
                }
            }

            if (player.xdrakeAncientApexCharging) {
                const chargeDuration = now - player.ancientApexChargeTimer;
                if (chargeDuration >= XDRAKE_ANCIENT_APEX_CHARGE_DURATION && player.hasBall && mouse.down) {
                     xdrakeAncientApexShoot(1.0);
                     player.xdrakeAncientApexCharging = false;
                     endCharge();
                }
            }


            if (player.gojoLapseBlueActive && player.gojoLapseBlueBall) {
                player.gojoLapseBlueBall.angle += player.gojoLapseBlueBall.speed * (dt / 1000);
                player.gojoLapseBlueBall.x = player.x + Math.cos(player.gojoLapseBlueBall.angle) * player.gojoLapseBlueBall.orbitRadius;
                player.gojoLapseBlueBall.y = player.y + Math.sin(player.gojoLapseBlueBall.angle) * player.gojoLapseBlueBall.orbitRadius;


                vfx.gojoBlueOrbitParticles.push({
                    x: player.gojoLapseBlueBall.x,
                    y: player.gojoLapseBlueBall.y,
                    life: 200 + Math.random() * 200, t: 0, r: 2 + Math.random() * 3,
                    vx: -player.vx * 0.2 + (Math.random() - 0.5) * 0.5,
                    vy: -player.vy * 0.2 + (Math.random() - 0.5) * 0.5,
                    color: 'rgba(49, 130, 206,'
                });
            }


            if (player.gojoPurpleActive && player.gojoPurpleConverging) {

                const convergenceProgress = clamp((now - player.gojoPurpleConvergenceStartTime) / GOJO_PURPLE_CONVERGE_DURATION, 0, 1);


                const dir = player.gojoPurpleInitialDir;
                const spreadDist = GOJO_PURPLE_SPREAD_DISTANCE;
                const leftSpreadX = player.x + Math.cos(dir - Math.PI/2) * spreadDist;
                const leftSpreadY = player.y + Math.sin(dir - Math.PI/2) * spreadDist;
                const rightSpreadX = player.x + Math.cos(dir + Math.PI/2) * spreadDist;
                const rightSpreadY = player.y + Math.sin(dir + Math.PI/2) * spreadDist;


                const targetX = player.x;
                const targetY = player.y;

                player.gojoPurpleLeftBall.x = lerp(leftSpreadX, targetX, convergenceProgress);
                player.gojoPurpleLeftBall.y = lerp(leftSpreadY, targetY, convergenceProgress);

                player.gojoPurpleRightBall.x = lerp(rightSpreadX, targetX, convergenceProgress);
                player.gojoPurpleRightBall.y = lerp(rightSpreadY, targetY, convergenceProgress);


                if (convergenceProgress >= 1 && !player.gojoPurpleShotFired) {

                    const finalX = (player.gojoPurpleLeftBall.x + player.gojoPurpleRightBall.x) / 2;
                    const finalY = (player.gojoPurpleLeftBall.y + player.gojoPurpleRightBall.y) / 2;

                    vfx.gojoPurpleCombineVFX.push({x: finalX, y: finalY, t: 0, life: GOJO_PURPLE_SHOCKWAVE_DURATION, radius: GOJO_LAPSE_BLUE_BALL_RADIUS * 1.5});
                    shockwave(finalX, finalY, GOJO_LAPSE_BLUE_BALL_RADIUS * 1.5, 'gojo-purple');

                    gojoPurpleShockwaveEndTime = now + GOJO_PURPLE_SHOCKWAVE_DURATION;
                    player.gojoPurpleShotFired = true;

                    for(let i=0; i<8; i++) {
                        vfx.gojoPurpleArcs.push(newGojoPurpleArc(finalX, finalY, i * (Math.PI / 4)));
                    }
                }
            }


            if (player.gojoPurpleShotFired && now >= gojoPurpleShockwaveEndTime && gojoPurpleShockwaveEndTime !== 0) {
                 if (player.gojoPurpleLeftBall && player.gojoPurpleRightBall) {
                     const finalX = (player.gojoPurpleLeftBall.x + player.gojoPurpleRightBall.x) / 2;
                     const finalY = (player.gojoPurpleLeftBall.y + player.gojoPurpleRightBall.y) / 2;
                     shootPurpleShot(finalX, finalY, player.gojoPurpleInitialDir);
                 }

                 player.gojoPurpleActive = false;
                 player.gojoPurpleConverging = false;
                 player.gojoPurpleConvergenceStartTime = 0;
                 player.gojoPurpleLeftBall = null;
                 player.gojoPurpleRightBall = null;
                 player.gojoPurpleInitialDir = 0;
                 player.gojoPurpleShotFired = false;
                 gojoPurpleShockwaveEndTime = 0;


                 player.x = W * 0.25;
                 player.y = H * 0.5;
                 player.vx = 0;
                 player.vy = 0;
            }


            if (currentStyle === 'eddie' && player.eddieWeAreActive && now >= player.eddieWeAreEndTime) {
                player.eddieWeAreActive = false;
                player.maxSpd = player.eddieWeAreOriginalMaxSpd;
                const currentSpeed = Math.hypot(player.vx, player.vy);
                if (currentSpeed > player.maxSpd) {
                    player.vx *= player.maxSpd / currentSpeed;
                    player.vy *= player.maxSpd / currentSpeed;
                }
            }

            // Check if Cristiano's Portuguese Spirit boost should end
            if (currentStyle === 'cristiano' && player.cristianoPortugueseSpiritActive && now >= player.cristianoPortugueseSpiritEndTime) {
                player.cristianoPortugueseSpiritActive = false;
                player.maxSpd = player.maxSpd / CRISTIANO_PORTUGUESE_SPIRIT_SPEED_MULTIPLIER;
                const currentSpeed = Math.hypot(player.vx, player.vy);
                if (currentSpeed > player.maxSpd) {
                    player.vx *= player.maxSpd / currentSpeed;
                    player.vy *= player.maxSpd / currentSpeed;
                }
                showNotification('portuguese spirit ended', 'info');
            }

            // Check if SAJA-JIN's Demonic Heroism boost should end
            if (currentStyle === 'saja-jin' && player.sajaJinDemonicHeroismActive && now >= player.sajaJinDemonicHeroismEndTime) {
                player.sajaJinDemonicHeroismActive = false;
                player.maxSpd = player.sajaJinDemonicHeroismOriginalMaxSpd;
                const currentSpeed = Math.hypot(player.vx, player.vy);
                if (currentSpeed > player.maxSpd) {
                    player.vx *= player.maxSpd / currentSpeed;
                    player.vy *= player.maxSpd / currentSpeed;
                }
                showNotification('demonic heroism ended', 'info');
            }

            // Check if LINCOLN's Gyatt Showdown should end
            if (currentStyle === 'lincoln' && player.lincolnGyattShowdownActive && now >= player.lincolnGyattShowdownEndTime) {
                player.lincolnGyattShowdownActive = false;
                player.maxSpd = player.lincolnGyattShowdownOriginalMaxSpd;
                const currentSpeed = Math.hypot(player.vx, player.vy);
                if (currentSpeed > player.maxSpd) {
                    player.vx *= player.maxSpd / currentSpeed;
                    player.vy *= player.maxSpd / currentSpeed;
                }
                showNotification('GYATT SHOWDOWN ended!', 'info');
                
                // Remove gyatt image when ability ends
                const gyattImg = document.getElementById('lincolnGyattImage');
                if (gyattImg) {
                    gyattImg.style.opacity = '0';
                    setTimeout(() => {
                        if (gyattImg.parentNode) {
                            gyattImg.parentNode.removeChild(gyattImg);
                        }
                    }, 300);
                }
            }

            // Update Lincoln gyatt image position to follow player
            if (currentStyle === 'lincoln' && player.lincolnGyattShowdownActive) {
                const gyattImg = document.getElementById('lincolnGyattImage');
                if (gyattImg && canvas) {
                    const rect = canvas.getBoundingClientRect();
                    const centerX = rect.left + (player.x * rect.width / W);
                    const centerY = rect.top + (player.y * rect.height / H);
                    gyattImg.style.left = (centerX - 20) + 'px'; // Center the 40px image
                    gyattImg.style.top = (centerY - 20) + 'px';
                }
            }

            if (currentStyle === 'zeus' && player.zeusHeavenlyShieldActive) {
                if (now >= player.zeusHeavenlyShieldEndTime) {
                    player.zeusHeavenlyShieldActive = false;
                    vfx.zeusHeavenlyShieldAura = [];
                } else {
                    if (Math.random() < 0.2) {
                        vfx.zeusHeavenlyShieldWaves.push(newZeusShieldWave(player.x, player.y));
                    }
                }
            }

            if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                const chargeDuration = now - player.zeusLightningChargeStartTime;
                if (chargeDuration >= ZEUS_LIGHTNING_CHARGE_DURATION && player.hasBall && mouse.down) {
                    zeusLightningShoot();
                    player.zeusLightningCharging = false;
                    vfx.zeusLightningChargeEffect = [];
                    endCharge();
                } else {
                    if (Math.random() < 0.3) {
                        vfx.zeusLightningChargeEffect.push(newZeusLightningChargeParticle(player.x, player.y));
                    }
                }
            }

            if (currentStyle === 'leonardo' && player.leonardoShieldActive && now >= player.leonardoShieldEndTime) {
                player.leonardoShieldActive = false;
            }
            if (currentStyle === 'leonardo' && player.leonardoDashing) {
                player.leonardoDashTimer -= dt;
                if (player.leonardoDashTimer <= 0) {
                    player.leonardoDashing = false;
                }
            }

            // WALLY ability timers
            if (currentStyle === 'wally' && player.wallyRocketBoostActive) {
                if (now >= player.wallyRocketBoostEndTime) {
                    player.wallyRocketBoostActive = false;
                    // Reset velocity after rocket boost ends
                    player.vx *= 0.3;
                    player.vy *= 0.3;
                } else {
                    // Smooth tween animation for rocket boost
                    const elapsed = now - (player.wallyRocketBoostEndTime - WALLY_ROCKET_BOOST_DURATION);
                    const progress = Math.min(1, elapsed / WALLY_ROCKET_BOOST_DURATION);
                    
                    // Ease-out animation for smooth movement
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    
                    player.x = player.wallyRocketBoostStartX + (player.wallyRocketBoostTargetX - player.wallyRocketBoostStartX) * easeProgress;
                    player.y = player.wallyRocketBoostStartY + (player.wallyRocketBoostTargetY - player.wallyRocketBoostStartY) * easeProgress;
                }
            }

            if (currentStyle === 'wally' && player.wallySpeedForceActive) {
                if (now >= player.wallySpeedForceEndTime) {
                    player.wallySpeedForceActive = false;
                    // Reset speed to original
                    player.maxSpd = player.wallySpeedForceOriginalMaxSpd;
                } else {
                    // Check if ball is in range and auto-attract it
                    const distToBall = Math.hypot(ball.x - player.x, ball.y - player.y);
                    if (distToBall <= WALLY_SPEED_FORCE_RANGE && !player.hasBall) {
                        const dx = player.x - ball.x;
                        const dy = player.y - ball.y;
                        const force = 0.8; // Attraction force
                        ball.vx += dx * force / distToBall;
                        ball.vy += dy * force / distToBall;
                    }
                    // Apply speed boost only when player does NOT have the ball
                    if (!player.hasBall && player.maxSpd === player.wallySpeedForceOriginalMaxSpd) {
                        player.maxSpd *= WALLY_SPEED_FORCE_SPEED_BOOST; // Apply 20% speed boost
                    } else if (player.hasBall && player.maxSpd > player.wallySpeedForceOriginalMaxSpd) {
                        // Remove speed boost when player gets the ball
                        player.maxSpd = player.wallySpeedForceOriginalMaxSpd;
                    }
                }
            }

            if (currentStyle === 'wally' && player.wallyFlashyLightningActive && now >= player.wallyFlashyLightningEndTime) {
                player.wallyFlashyLightningActive = false;
                // Reset speed to original
                player.maxSpd = player.wallyFlashyLightningOriginalMaxSpd;
            }

            // KORBIN Big Back Power ability timer and mechanics
            if (currentStyle === 'korbin' && player.korbinBigBackPowerActive) {
                if (now >= player.korbinBigBackPowerEndTime) {
                    // Auto-stop the move when duration ends
                    stopKorbinBigBackPower();
                } else {
                    // Keep player moving in the same direction while active
                    player.vx = player.korbinBigBackPowerDirection.x * KORBIN_BIG_BACK_POWER_SPEED;
                    player.vy = player.korbinBigBackPowerDirection.y * KORBIN_BIG_BACK_POWER_SPEED;
                    
                    // Check for wall collisions and stop if hit
                    const futureX = player.x + player.vx;
                    const futureY = player.y + player.vy;
                    
                    if (futureX <= margin + player.r || futureX >= W - margin - player.r ||
                        futureY <= margin + player.r || futureY >= H - margin - player.r) {
                        // Hit a wall, stop the move
                        stopKorbinBigBackPower();
                        showNotification('Hit wall! Big Back Power stopped!', 'info');
                    }
                    
                    // Generate wind trail effects while moving
                    if (Math.random() < 0.4) {
                        vfx.korbinBigBackPowerWindTrail.push({
                            x: player.x + (Math.random() - 0.5) * 40,
                            y: player.y + (Math.random() - 0.5) * 40,
                            vx: -player.vx * 0.3 + (Math.random() - 0.5) * 5,
                            vy: -player.vy * 0.3 + (Math.random() - 0.5) * 5,
                            life: 400 + Math.random() * 200,
                            t: 0,
                            size: 8 + Math.random() * 6,
                            intensity: 0.6 + Math.random() * 0.4,
                            spin: (Math.random() - 0.5) * 0.2
                        });
                    }
                }
            }

            if (currentStyle === 'zeus' && player.zeusOlympusFuryActive) {
                if (player.zeusOlympusFuryPhase === 'pulling') {
                    const pullTimeElapsed = now - player.zeusOlympusFuryPullStartTime;
                    if (pullTimeElapsed >= ZEUS_OLYMPUS_FURY_PULL_DURATION || player.hasBall) {
                        player.zeusOlympusFuryPhase = 'aiming';
                        player.zeusOlympusFuryAimStartTime = now;
                        player.hasBall = true;

                        vfx.zeusOlympusFuryPullLines = [];

                        vfx.zeusOlympusFuryAura.push({
                            x: player.x, y: player.y,
                            end: now + ZEUS_OLYMPUS_FURY_AIM_DURATION,
                            radius: player.r * 2.5,
                            t: 0, life: ZEUS_OLYMPUS_FURY_AIM_DURATION
                        });
                    } else {
                        vfx.zeusOlympusFuryPullLines.push(newZeusOlympusFuryPullLine(player.x, player.y, ball.x, ball.y));
                    }
                } else if (player.zeusOlympusFuryPhase === 'aiming') {
                    player.vx = 0;
                    player.vy = 0;

                    if (!player.zeusOlympusFuryShotFired && (now - player.zeusOlympusFuryAimStartTime) >= ZEUS_OLYMPUS_FURY_AIM_DURATION) {
                        zeusOlympusFuryShoot();
                    }
                }
            }
        }

function updateBall(dt){
            const currentR = player.r;
            if (player.asherStarfallCharging) {
                const elapsed = performance.now() - player.asherStarfallChargeStartTime;
                const angle = (elapsed / 1000) * ASHER_STARFALL_ORBIT_SPEED;

                ball.x = player.x + Math.cos(angle) * ASHER_STARFALL_ORBIT_RADIUS;
                ball.y = player.y + Math.sin(angle) * ASHER_STARFALL_ORBIT_RADIUS;
                ball.vx = 0;
                ball.vy = 0;

                // Add sparkling VFX during orbit
                if (Math.random() < 0.5) {
                    vfx.sparks.push({
                        x: ball.x, y: ball.y,
                        vx: (Math.random() - 0.5) * 1.5,
                        vy: (Math.random() - 0.5) * 1.5,
                        life: 150 + Math.random() * 150,
                        t: 0, r: 1 + Math.random() * 1.5,
                        color: 'rgba(233, 213, 255,'
                    });
                }
                return; // Skip the rest of the ball update logic
            }

            if (ball.isHoming) {
                const now = performance.now();
                if (now > ball.homingEndTime) {
                    ball.isHoming = false;
                    player.asherAutoGoalActive = false;
                    ball.maxSpeed = 18; // Reset max speed
                } else {
                    const targetDir = Math.atan2(ball.homingTargetY - ball.y, ball.homingTargetX - ball.x);
                    const currentDir = Math.atan2(ball.vy, ball.vx);

                    let angleDiff = targetDir - currentDir;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                    const newDir = currentDir + clamp(angleDiff, -ASHER_HOMING_TURN_RATE, ASHER_HOMING_TURN_RATE);

                    const currentSpeed = Math.hypot(ball.vx, ball.vy);
                    ball.vx = Math.cos(newDir) * currentSpeed;
                    ball.vy = Math.sin(newDir) * currentSpeed;
                }
            }

            if(player.hasBall && !player.gojoPurpleActive && !player.gojoRedCharging && !player.eddieVenomStrikeActive && !(currentStyle === 'eddie' && player.eddieSymbioteMontageActive) &&
               !player.zeusLightningCharging && !(player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming')){
                const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);
                let dist = currentR + ball.r + 4;

                ball.x=player.x+Math.cos(dir)*dist;
                ball.y=player.y+Math.sin(dir)*dist;
                ball.vx=player.vx; ball.vy=player.vy;
            } else if (player.telekinising || (currentStyle === 'eddie' && player.eddieVenomStrikeActive) ||
                       (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'pulling' && !player.hasBall)) {

                const dt_s = dt / 1000;

                const dx = player.x - ball.x;
                const dy = player.y - ball.y;
                const dist = Math.hypot(dx, dy);
                const dir = Math.atan2(dy, dx);

                let pullSpeed = EDDIE_VENOM_STRIKE_PULL_SPEED;
                if (currentStyle === 'zeus' && player.zeusOlympusFuryActive) {
                    pullSpeed = 400;
                }

                ball.vx = Math.cos(dir) * pullSpeed;
                ball.vy = Math.sin(dir) * pullSpeed;

                ball.x += ball.vx * dt_s;
                ball.y += ball.vy * dt_s;


                if(dist < currentR + ball.r + 6){
                    player.hasBall = true;
                    player.telekinising = false;
                    vfx.eclipseLines = [];

                    if (currentStyle === 'eddie' && player.eddieVenomStrikeActive) {

                        const shootDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                        ball.vx = Math.cos(shootDir) * EDDIE_VENOM_STRIKE_SHOT_POWER + player.vx * 0.3;
                        ball.vy = Math.sin(shootDir) * EDDIE_VENOM_STRIKE_SHOT_POWER + player.vy * 0.3;
                        player.hasBall = false;
                        player.eddieVenomStrikeActive = false;
                        vfx.eddieVenomBallSwirl = [];

                        vfx.eddieVenomShotTrail.push({
                            end: performance.now() + 600,
                            w: 20,
                            colorStart: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-start'),
                            colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-end')
                        });
                        shockwave(player.x, player.y, 25, 'eddie-venom');
                        const origFric = ball.friction;
                        ball.friction = 0.99;
                        setTimeout(() => { ball.friction = origFric; ball.maxSpeed = 18; }, 600);
                    } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive) {
                        ball.vx = player.vx;
                        ball.vy = player.vy;
                    }
                } else if ((currentStyle === 'eddie' && player.eddieVenomStrikeActive) || (currentStyle === 'zeus' && player.zeusOlympusFuryActive)) {
                     vfx.eddieVenomBallSwirl.push(newEddieVenomBallSwirlParticle(ball.x, ball.y, dir + Math.PI));
                }
            }
            else{
                // NEW SAJA-JIN Hypnotic Shot - Phase-based system
                if (player.sajaJinHypnoticShotActive) {
                    const now = performance.now();
                    const elapsedTime = now - player.sajaJinHypnoticShotStartTime;

                    if (player.sajaJinHypnoticShotPhase === 'spinning') {
                        // PHASE 1: Hypnotic multi-layered spinning with smooth circular motion
                        const spinProgress = elapsedTime / SAJA_JIN_HYPNOTIC_SHOT_SPIN_DURATION;
                        const smoothSpinSpeed = SAJA_JIN_HYPNOTIC_SHOT_SPIN_SPEED * (1 + Math.sin(elapsedTime * 0.003) * 0.3); // Pulsating speed
                        
                        // Validate spin calculations
                        if (isFinite(smoothSpinSpeed)) {
                            player.sajaJinHypnoticShotSpinAngle += smoothSpinSpeed;
                        }
                       
                        // Create hypnotic pulsating radius effect
                        const baseRadius = SAJA_JIN_HYPNOTIC_SHOT_SPIN_RADIUS;
                        const radiusPulse = baseRadius + Math.sin(elapsedTime * 0.005) * 15;
                        
                        // Validate all position calculations before setting ball position
                        if (isFinite(player.sajaJinHypnoticShotPlayerCenterX) && 
                            isFinite(player.sajaJinHypnoticShotPlayerCenterY) &&
                            isFinite(player.sajaJinHypnoticShotSpinAngle) && 
                            isFinite(radiusPulse) && radiusPulse > 0) {
                            
                            const newX = player.sajaJinHypnoticShotPlayerCenterX + Math.cos(player.sajaJinHypnoticShotSpinAngle) * radiusPulse;
                            const newY = player.sajaJinHypnoticShotPlayerCenterY + Math.sin(player.sajaJinHypnoticShotSpinAngle) * radiusPulse;
                            
                            if (isFinite(newX) && isFinite(newY)) {
                                ball.x = newX;
                                ball.y = newY;
                            }
                        }
                        ball.vx = 0;
                        ball.vy = 0;

                        // Create multiple spiral layers for hypnotic effect
                        for (let layer = 0; layer < SAJA_JIN_HYPNOTIC_SHOT_SPIRAL_LAYERS; layer++) {
                            const layerRadius = baseRadius * (0.6 + layer * 0.3);
                            const layerAngle = player.sajaJinHypnoticShotSpinAngle + (layer * Math.PI * 0.67);
                            
                            // Validate layer calculations before creating VFX
                            if (isFinite(layerRadius) && isFinite(layerAngle) && 
                                isFinite(player.sajaJinHypnoticShotPlayerCenterX) && 
                                isFinite(player.sajaJinHypnoticShotPlayerCenterY) && 
                                layerRadius > 0) {
                                
                                const layerX = player.sajaJinHypnoticShotPlayerCenterX + Math.cos(layerAngle) * layerRadius;
                                const layerY = player.sajaJinHypnoticShotPlayerCenterY + Math.sin(layerAngle) * layerRadius;
                                
                                if (isFinite(layerX) && isFinite(layerY)) {
                                    vfx.sajaJinHypnoticSpinTrail.push({
                                        x: layerX,
                                        y: layerY,
                                        life: 600 + layer * 100,
                                        t: 0,
                                        angle: layerAngle,
                                        layer: layer,
                                        intensity: 1 - (layer * 0.25)
                                    });
                                }
                            }
                        }

                        // Enhanced spinning VFX trail with varying intensities
                        if (isFinite(ball.x) && isFinite(ball.y) && isFinite(player.sajaJinHypnoticShotSpinAngle)) {
                            vfx.sajaJinHypnoticSpinTrail.push({
                                x: ball.x,
                                y: ball.y,
                                life: 800,
                                t: 0,
                                angle: player.sajaJinHypnoticShotSpinAngle,
                                layer: -1, // Main ball trail
                                intensity: 1.2
                            });
                        }

                        // Add pulsing hypnotic aura rings
                        if (Math.floor(elapsedTime / 200) % 2 === 0 && 
                            isFinite(player.sajaJinHypnoticShotPlayerCenterX) && 
                            isFinite(player.sajaJinHypnoticShotPlayerCenterY) && 
                            isFinite(baseRadius) && baseRadius > 0) {
                            
                            vfx.sajaJinHypnoticGlow.push({
                                x: player.sajaJinHypnoticShotPlayerCenterX,
                                y: player.sajaJinHypnoticShotPlayerCenterY,
                                radius: baseRadius * 1.5,
                                life: 1000,
                                t: 0,
                                type: 'pulse_ring'
                            });
                        }

                        if (elapsedTime >= SAJA_JIN_HYPNOTIC_SHOT_SPIN_DURATION) {
                            player.sajaJinHypnoticShotPhase = 'left';
                            player.sajaJinHypnoticShotStartTime = now;
                            showNotification('Ball slowly commanded to drift left...', 'info');
                        }
                    } else if (player.sajaJinHypnoticShotPhase === 'left') {
                        // PHASE 2: Small left nudge (tiny shift over the left phase)
                        // Move only a small total amount left so the player can't pick it up,
                        // but the ball doesn't travel all the way left. Scale by frame time.
                        const LEFT_TOTAL_SHIFT = 12; // total pixels to nudge left over the phase
                        const dt_s_local = (typeof dt !== 'undefined') ? dt / 1000 : 1/
                        60;
                        const perFrameShift = LEFT_TOTAL_SHIFT * (dt_s_local / (SAJA_JIN_HYPNOTIC_SHOT_LEFT_DURATION / 1000));
                        // zero out velocities so external physics doesn't override the nudge
                        ball.vx = 0;
                        ball.vy = 0;
                        ball.x -= perFrameShift;

                        if (elapsedTime >= SAJA_JIN_HYPNOTIC_SHOT_LEFT_DURATION) {
                            player.sajaJinHypnoticShotPhase = 'caption';
                            player.sajaJinHypnoticShotStartTime = now;
                            ball.vx = 0;
                            ball.vy = 0;

                            // Display the threatening caption
                            vfx.sajaJinHypnoticCaption.push({
                                text: "Ball, go in the goal or else I'll suck that soul outta you!",
                                x: W/2,
                                y: H/4,
                                life: SAJA_JIN_HYPNOTIC_SHOT_CAPTION_DURATION,
                                t: 0
                            });
                            showNotification("Saja Jin threatens the ball!", 'warning');
                        }
                    } else if (player.sajaJinHypnoticShotPhase === 'caption') {
                        // PHASE 3: Caption display - ball stays still
                        ball.vx = 0;
                        ball.vy = 0;

                        if (elapsedTime >= SAJA_JIN_HYPNOTIC_SHOT_CAPTION_DURATION) {
                            player.sajaJinHypnoticShotPhase = 'goal';
                            player.sajaJinHypnoticShotStartTime = now;
                            showNotification('Ball obeys and heads to goal!', 'success');
                        }
                    } else if (player.sajaJinHypnoticShotPhase === 'goal') {
                        // PHASE 4: Slow, mesmerizing curve toward goal with spinning motion
                        const goalX = W - margin - goalDepth/2;
                        const goalY = H/2;
                        const dx = goalX - ball.x;
                        const dy = goalY - ball.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        if (dist > 30) {
                            // Create a smooth curving path with spinning motion
                            const goalPhaseTime = elapsedTime;
                            const curveIntensity = Math.sin(goalPhaseTime * 0.008) * 0.3; // Subtle curve
                            
                            // Calculate perpendicular direction for curve
                            const perpX = -dy / dist;
                            const perpY = dx / dist;
                            
                            // Base movement toward goal
                            const baseVx = (dx / dist) * SAJA_JIN_HYPNOTIC_SHOT_GOAL_SPEED;
                            const baseVy = (dy / dist) * SAJA_JIN_HYPNOTIC_SHOT_GOAL_SPEED;
                            
                            // Add curve component
                            ball.vx = baseVx + perpX * curveIntensity;
                            ball.vy = baseVy + perpY * curveIntensity;
                            
                            ball.x += ball.vx;
                            ball.y += ball.vy;
                            
                            // Continue spinning motion during goal approach
                            const goalSpinAngle = goalPhaseTime * 0.05;
                            const spinTrailRadius = 15 + Math.sin(goalPhaseTime * 0.006) * 5;
                            
                            // Add rotating trail particles around the ball
                            for (let i = 0; i < 4; i++) {
                                const angle = goalSpinAngle + (i * Math.PI * 0.5);
                                vfx.sajaJinHypnoticTrail.push({
                                    x: ball.x + Math.cos(angle) * spinTrailRadius,
                                    y: ball.y + Math.sin(angle) * spinTrailRadius,
                                    life: 400,
                                    t: 0,
                                    angle: angle,
                                    type: 'goal_spiral'
                                });
                            }
                            
                            // Add hypnotic glow around ball
                            vfx.sajaJinHypnoticGlow.push({
                                x: ball.x,
                                y: ball.y,
                                radius: 25 + Math.sin(goalPhaseTime * 0.01) * 8,
                                life: 300,
                                t: 0,
                                type: 'moving_aura'
                            });
                            
                        } else {
                            // Close to goal - trigger enhanced burst phase
                            player.sajaJinHypnoticShotPhase = 'burst';
                            player.sajaJinHypnoticShotStartTime = now;
                            ball.vx = 0;
                            ball.vy = 0;

                            // Create massive hypnotic burst effect
                            vfx.sajaJinHypnoticBurst.push({
                                x: ball.x,
                                y: ball.y,
                                radius: SAJA_JIN_HYPNOTIC_SHOT_BURST_RADIUS,
                                life: 2000,
                                t: 0,
                                type: 'main_burst'
                            });
                            
                            // Create multiple burst rings
                            for (let ring = 0; ring < 4; ring++) {
                                setTimeout(() => {
                                    vfx.sajaJinHypnoticBurst.push({
                                        x: ball.x,
                                        y: ball.y,
                                        radius: SAJA_JIN_HYPNOTIC_SHOT_BURST_RADIUS * (0.7 + ring * 0.2),
                                        life: 1500,
                                        t: 0,
                                        type: 'ring_burst',
                                        delay: ring * 150
                                    });
                                }, ring * 150);
                            }

                            // Enhanced burst particles in spiral pattern
                            for (let i = 0; i < 80; i++) {
                                const angle = (Math.PI * 2 * i) / 80;
                                const spiralAngle = angle + (i * 0.2); // Create spiral effect
                                const speed = 8 + Math.random() * 8;
                                vfx.sajaJinSoulParticles.push({
                                    x: ball.x,
                                    y: ball.y,
                                    vx: Math.cos(spiralAngle) * speed,
                                    vy: Math.sin(spiralAngle) * speed,
                                    life: 1500 + Math.random() * 500,
                                    t: 0,
                                    size: Math.random() * 10 + 6,
                                    spiralAngle: spiralAngle
                                });
                            }
                            showNotification('HYPNOTIC BURST - GOAL INEVITABLE!', 'success');
                        }
                    } else if (player.sajaJinHypnoticShotPhase === 'burst') {
                        // PHASE 5: Burst effect then score
                        ball.vx = 0;
                        ball.vy = 0;

                        if (elapsedTime >= 800) { // Short burst duration
                            // Complete the shot - ball goes into goal
                            const goalX = W - margin - goalDepth/2;
                            const goalY = H/2;

                            // Nudge the ball a small amount toward the goal and then forcibly stop it shortly after
                            const NUDGE_FORWARD = Math.min(10, SAJA_JIN_HYPNOTIC_SHOT_GOAL_SPEED / 4); // small forward nudge
                            ball.x = goalX - NUDGE_FORWARD; // place slightly before the goal mouth
                            ball.y = goalY;
                            ball.vx = NUDGE_FORWARD; // small forward velocity into the goal
                            ball.vy = 0;

                            // Lock possession briefly so nobody can grab it while it finishes scoring
                            player.sajaJinHypnoticLockUntil = performance.now() + 1000;
                            player.sajaJinHypnoticShotActive = false;
                            showNotification('Hypnotic Shot COMPLETE!', 'success');

                            // Ensure the ball stops shortly after nudging so it won't fly off the field or into the other goal
                            setTimeout(() => {
                                try {
                                    if (gameState !== 'game') return;
                                    // Stop the ball cleanly and clamp it just inside the goal area to trigger scoring without overshoot
                                    ball.vx = 0;
                                    // Move the ball a tiny bit forward but clamp to not exceed the goalX position
                                    ball.x = Math.min((ball.x + NUDGE_FORWARD), goalX);
                                } catch (e) {
                                    // ignore if game state changed or variables are gone
                                }
                            }, 300);
                        }
                    }
                } else {
                    // Normal ball physics
                    ball.vx*=ball.friction; ball.vy*=ball.friction;
                    const sp=Math.hypot(ball.vx, ball.vy);
                    if(sp>ball.maxSpeed){ ball.vx*=ball.maxSpeed/sp; ball.vy*=ball.maxSpeed/sp; }
                    
                    // Shield deflection - check collision with Last Fear shield
                    if (player.lastFearActive && sp > 1) { // Only deflect if ball is moving
                        const distanceToPlayer = Math.hypot(ball.x - player.x, ball.y - player.y);
                        const shieldRadius = player.r * 3.5; // Shield is bigger than visual
                        
                        if (distanceToPlayer <= shieldRadius) {
                            // Calculate deflection angle - bounce off shield
                            const angleToPlayer = Math.atan2(ball.y - player.y, ball.x - player.x);
                            const currentSpeed = Math.hypot(ball.vx, ball.vy);
                            
                            // Reflect ball away from player with increased speed
                            ball.vx = Math.cos(angleToPlayer) * currentSpeed * 1.2;
                            ball.vy = Math.sin(angleToPlayer) * currentSpeed * 1.2;
                            
                            // Add deflection particles
                            for (let i = 0; i < 10; i++) {
                                vfx.sparks.push({
                                    x: ball.x + (Math.random() - 0.5) * 30,
                                    y: ball.y + (Math.random() - 0.5) * 30,
                                    vx: Math.cos(angleToPlayer + (Math.random() - 0.5)) * 5,
                                    vy: Math.sin(angleToPlayer + (Math.random() - 0.5)) * 5,
                                    life: 600,
                                    t: 0,
                                    r: 1.5 + Math.random() * 2,
                                    color: 'rgba(0, 255, 255,'
                                });
                            }
                            
                            showNotification('Shield deflected the ball!', 'success');
                        }
                    }
                    
                    ball.x+=ball.vx; ball.y+=ball.vy;

                    // Generate Fiery Apocalypse trail when ball is moving fast (optimized)
                    if (currentStyle === 'korbin' && sp > 15 && Math.random() < 0.4) { // Reduced from 0.8 to 0.4
                        // Create trailing fire effects (fewer particles)
                        for (let i = 0; i < 2; i++) { // Reduced from 3 to 2
                            vfx.korbinFireApocalypseTrail.push({
                                x: ball.x + (Math.random() - 0.5) * 20,
                                y: ball.y + (Math.random() - 0.5) * 20,
                                vx: -ball.vx * 0.15 + (Math.random() - 0.5) * 3,
                                vy: -ball.vy * 0.15 + (Math.random() - 0.5) * 3,
                                life: 300 + Math.random() * 200, // Much shorter - 0.3-0.5 seconds
                                t: 0,
                                size: 4 + Math.random() * 5, // Smaller
                                hue: Math.random() * 60,
                                intensity: 0.6 + Math.random() * 0.2,
                                loop: Math.sin(performance.now() * 0.01 + i) * 0.1 // Reduced loop
                            });
                        }

                        // Create ember sparks (fewer particles)
                        if (Math.random() < 0.2) { // Reduced from 0.4 to 0.2
                            vfx.korbinFireApocalypseEmbers.push({
                                x: ball.x + (Math.random() - 0.5) * 15,
                                y: ball.y + (Math.random() - 0.5) * 15,
                                vx: -ball.vx * 0.08 + (Math.random() - 0.5) * 5,
                                vy: -ball.vy * 0.08 + (Math.random() - 0.5) * 5,
                                life: 400 + Math.random() * 300, // Much shorter - 0.4-0.7 seconds
                                t: 0,
                                size: 1 + Math.random() * 3, // Smaller
                                hue: 15 + Math.random() * 30,
                                gravity: 0.03,
                                intensity: 0.6,
                                loop: Math.cos(performance.now() * 0.015) * 0.1 // Reduced loop
                            });
                        }
                    }
                }

                const left=margin+2, right=W-margin-2, top=margin+2, bottom=H-margin-2;

                // Enhanced ball collision with better bounce physics
                // Check for Abby Power Pin effect
                const now = performance.now();
                const powerPinActive = ball.abbyPowerPinActive && now < ball.abbyPowerPinEndTime;
               
                if(ball.x-ball.r<left){
                    ball.x=left+ball.r;
                    if(powerPinActive) {
                        // Power Pin: ball sticks to wall, no bounce
                        ball.vx = 0; ball.vy = 0;
                        // Create pin effect
                        for(let i = 0; i < 6; i++) {
                            vfx.trails.push({
                                x: ball.x, y: ball.y,
                                vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
                                life: 25, t: 0,
                                color: 'rgba(255, 69, 0, 0.8)', w: 4
                            });
                        }
                        showNotification('Ball pinned to wall!', 'info');
                    } else {
                        ball.vx*=-(ball.bounceDamping || 0.75);
                    }
                    impactWave(ball.x, ball.y, 10);
                }
                if(ball.x+ball.r>right){
                    ball.x=right-ball.r;
                    if(powerPinActive) {
                        ball.vx = 0; ball.vy = 0;
                        for(let i = 0; i < 6; i++) {
                            vfx.trails.push({
                                x: ball.x, y: ball.y,
                                vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
                                life: 25, t: 0,
                                color: 'rgba(255, 69, 0, 0.8)', w: 4
                            });
                        }
                        showNotification('Ball pinned to wall!', 'info');
                    } else {
                        ball.vx*=-(ball.bounceDamping || 0.75);
                    }
                    impactWave(ball.x, ball.y, 10);
                }
                if(ball.y-ball.r<top){
                    ball.y=top+ball.r;
                    if(powerPinActive) {
                        ball.vx = 0; ball.vy = 0;
                        for(let i = 0; i < 6; i++) {
                            vfx.trails.push({
                                x: ball.x, y: ball.y,
                                vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
                                life: 25, t: 0,
                                color: 'rgba(255, 69, 0, 0.8)', w: 4
                            });
                        }
                        showNotification('Ball pinned to wall!', 'info');
                    } else {
                        ball.vy*=-(ball.bounceDamping || 0.75);
                    }
                    impactWave(ball.x, ball.y, 10);
                }
                if(ball.y+ball.r>bottom){
                    ball.y=bottom-ball.r;
                    if(powerPinActive) {
                        ball.vx = 0; ball.vy = 0;
                        for(let i = 0; i < 6; i++) {
                            vfx.trails.push({
                                x: ball.x, y: ball.y,
                                vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
                                life: 25, t: 0,
                                color: 'rgba(255, 69, 0, 0.8)', w: 4
                            });
                        }
                        showNotification('Ball pinned to wall!', 'info');
                    } else {
                        ball.vy*=-(ball.bounceDamping || 0.75);
                    }
                    impactWave(ball.x, ball.y, 10);
                }
               
                // Clear power pin effect after expiration
                if(ball.abbyPowerPinActive && now >= ball.abbyPowerPinEndTime) {
                    ball.abbyPowerPinActive = false;
                    showNotification('Power Pin effect ended', 'info');
                }


                // Ball pickup: automatic on collision OR manual with 'E' key
                const d=Math.hypot(ball.x-player.x, ball.y-player.y);

                // Ball pickup logic - when AI enabled, require E key
                // Block pickups while Saja-Jin's Hypnotic Shot sequence is active or locked so the ball cannot be reclaimed mid-shot
                const hypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                const abbyDemonDriveLocked = player.abbyDemonDriveActive; // Prevent pickup during demon drive
                if (d < player.r + ball.r + 8 && !player.hasBall && !aiPlayer.hasBall &&
                    !player.eddieSymbioteMontageActive && !player.spinning && !player.charging &&
                    !player.telekinising && !player.dashing && !hypnoticLocked && !abbyDemonDriveLocked) {

                    if (aiEnabled) {
                        // When playing with AI, allow both E key and collision pickup for faster gameplay
                        if (keys['e'] || d < player.r + ball.r + 5) {
                            player.hasBall = true;
                            ball.vx = 0;
                            ball.vy = 0;
                            // Add feedback when player gets ball
                            if (d < player.r + ball.r + 5) {
                                showNotification('Ball collected!', 'success');
                            }
                        }
                    } else {
                        // When playing solo, auto pickup still works
                        player.hasBall = true;
                        ball.vx = 0;
                        ball.vy = 0;
                    }
                }

                if (currentStyle === 'gojo' && player.gojoLapseBlueActive && player.gojoLapseBlueBall) {
                    const orbitingBall = player.gojoLapseBlueBall;
                    const distToOrbitingBall = Math.hypot(ball.x - orbitingBall.x, ball.y - orbitingBall.y);
                    if (distToOrbitingBall < orbitingBall.r + ball.r) {
                        // Do not allow grabbing the ball while Saja-Jin's Hypnotic Shot is active or locked
                            const orbitHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                            if (!orbitHypnoticLocked) {
                            player.hasBall = true;
                            ball.vx = player.vx;
                            ball.vy = player.vy;
                            const snapDir = Math.atan2(player.y - ball.y, player.x - ball.x);
                            ball.x = player.x + Math.cos(snapDir) * (player.r + ball.r + 4);
                            ball.y = player.y + Math.sin(snapDir) * (player.r + ball.r + 4);

                            for(let i=0; i<10; i++) vfx.gojoLapseBluePullEffect.push(newGojoLapseBluePullParticle(ball.x, ball.y, player.x, player.y));
                            shockwave(ball.x, ball.y, ball.r * 1.5, 'gojo-blue');

                            player.gojoLapseBlueActive = false;
                            player.gojoLapseBlueBall = null;
                        }
                    }
                }


                if (currentStyle === 'robsan' && player.eclipseGraspActive && player.telekinising) {
    const dt_s = dt / 1000;
    const dx = player.x - ball.x;
    const dy = player.y - ball.y;
    const dist = Math.hypot(dx, dy);

    const speed = lerp(24, 8, Math.min(1, dist / 180));
    const moveAmount = speed * dt_s;

    ball.x += (dx / dist) * moveAmount;
    ball.y += (dy / dist) * moveAmount;

    if(Math.random() < 0.3) {
        vfx.robsanVoidPuffs.push(newRobsanVoidPuff(ball.x, ball.y, 'eclipse'));
    }

    if (dist < player.r + ball.r + 4) {
        // If Hypnotic Shot is controlling the ball or the final scoring lock is active, do not allow Robsan's eclipse grasp to instantly give possession
        const eclipseHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
        if (!eclipseHypnoticLocked) {
            player.hasBall = true;
            player.telekinising = false;
            player.eclipseGraspActive = false;
            ball.vx = 0;
            ball.vy = 0;

            shockwave(player.x, player.y, 20, 'eclipse');
            for(let i=0; i<12; i++) {
                vfx.sparks.push(newRobsanParticle(player.x, player.y));
            }
        }
    }
    return;
}

                if (currentStyle === 'zeus' && player.zeusHeavenlyShieldActive) {
                    const distToPlayer = Math.hypot(ball.x - player.x, ball.y - player.y);
                    if (distToPlayer < ZEUS_HEAVENLY_SHIELD_RADIUS + ball.r) {
                        ball.vx *= 0.05;
                        ball.vy *= 0.05;
                    }
                }

                if (currentStyle === 'leonardo' && player.leonardoShieldActive) {
                    const distToPlayer = Math.hypot(ball.x - player.x, ball.y - player.y);
                    if (distToPlayer < LEONARDO_SHIELD_RADIUS + ball.r) {
                        // Slowly pull the ball towards the player
                        const pullDir = Math.atan2(player.y - ball.y, player.x - ball.x);
                        ball.vx += Math.cos(pullDir) * LEONARDO_SHIELD_PULL_STRENGTH;
                        ball.vy += Math.sin(pullDir) * LEONARDO_SHIELD_PULL_STRENGTH;
                    }
                }
                // Check for Pattern Weave field
                for (const field of vfx.leonardoPatternField) {
                    const distToField = Math.hypot(ball.x - field.x, ball.y - field.y);
                    if (distToField < field.radius + ball.r) {
                        ball.vx *= 0.95; // Slow the ball down
                        ball.vy *= 0.95;
                    }
                }
            }
        }


        function shoot(scale){
            if(!player.hasBall) return;
            const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);
            const base=10;
            let power=base*scale;
            
            // Apply Lincoln's Gyatt Showdown 5x shot multiplier
            if (currentStyle === 'lincoln' && player.lincolnGyattShowdownActive) {
                power *= LINCOLN_GYATT_SHOWDOWN_SHOT_MULTIPLIER;
                
                // Generate extra VFX for powered shot
                for (let i = 0; i < 20; i++) {
                    const angle = dir + (Math.random() - 0.5) * 0.5;
                    vfx.lincolnGyattParticles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(angle) * (10 + Math.random() * 15),
                        vy: Math.sin(angle) * (10 + Math.random() * 15),
                        life: 1000 + Math.random() * 500,
                        t: 0,
                        size: 6 + Math.random() * 8,
                        hue: 280 + Math.random() * 80
                    });
                }
                showNotification('GYATT POWER SHOT! 5X DAMAGE!', 'success');
            }
            
            ball.vx=Math.cos(dir)*power + player.vx*0.3;
            ball.vy=Math.sin(dir)*power + player.vy*0.3;
            player.hasBall=false;
        }

        function tryKaiser(){
            if(currentStyle !== 'hudson') return;
            const now=performance.now();
            if(now < abilityReadyAt) return;
            if(!player.hasBall) {
                showNotification('hudson impact needs the ball bestie', 'warning');
                return;
            }


            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);
            const launch=22;

            ball.vx = Math.cos(dir)*launch + player.vx*0.25;
            ball.vy = Math.sin(dir)*launch + player.vy*0.25;
            ball.maxSpeed = 100000;
            player.hasBall=false;

            const endTime = now + 450;
            vfx.trail.push({end:endTime, w:16});
            for(let i=0;i<10;i++) vfx.lines.push(newLineBurst(player.x, player.y, dir));
            shockwave(player.x, player.y, 18);
            kaiserSparks(player.x, player.y, dir);

            const newTrails = newHudsonImpactBurst(player.x, player.y, dir);
            vfx.hudsonEmperorDribbleTrail.push(...newTrails);
            vfx.hudsonSpeedLines.push(...newHudsonSpeedLines(player.x, player.y, dir));
            vfx.hudsonEnergyWaves.push(newHudsonEnergyWave(player.x, player.y));

            for(let i = 0; i < 3; i++) {
                setTimeout(() => {
                    if(gameState === 'game') {
                        shockwave(player.x, player.y, 15 + i * 5, 'hudson');
                        vfx.energyResidue.push({
                            x: player.x + (Math.random() - 0.5) * 40,
                            y: player.y + (Math.random() - 0.5) * 40,
                            t: 0, life: 800, r: 3 + Math.random() * 4,
                            color: 'rgba(79, 209, 197,'
                        });
                    }
                }, i * 100);
            }

            const origFric = ball.friction;
            ball.friction = 0.994;
            setTimeout(()=>{ ball.friction = origFric; ball.maxSpeed=18; }, 450);

            abilityReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryHudsonEmperorDribble() {
            if (currentStyle !== 'hudson') return;
            const now = performance.now();
            if (now < hudsonEmperorDribbleReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive || player.hudsonEmperorDribbling) return;

            // Start emperor dribble
            hudsonEmperorDribbleReadyAt = now + HUDSON_EMPEROR_DRIBBLE_COOLDOWN;
            player.hudsonEmperorDribbling = true;
            player.hudsonEmperorDribbleStartTime = now;
            player.hudsonEmperorDribblePhase = 'left';
            player.hudsonEmperorDribbleStartX = player.x;
            player.hudsonEmperorDribbleStartY = player.y;
            // Capture mouse direction when ability is triggered
            player.hudsonEmperorDribbleMouseDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);

            // Stun AI player during the dribble
            if (aiEnabled) {
                aiPlayer.isStunned = true;
                aiPlayer.stunEndTime = now + HUDSON_EMPEROR_DRIBBLE_DURATION;
                showNotification('ai got stunned lmao', 'success');
            }

            showNotification('dribbling like an emperor activated', 'success');

            // Initial emperor aura burst
            vfx.hudsonEmperorDribbleAura.push({
                x: player.x, y: player.y,
                life: 300, t: 0,
                radius: player.r * 3,
                phase: 'burst'
            });
        }

        function tryRobsanShadowSpiral(){
            if(currentStyle !== 'robsan') return;
            const now=performance.now();
            if(now < shadowSpiralReadyAt) return;
            if(!player.hasBall) {
                showNotification('shadow spiral needs the ball bestie', 'warning');
                return;
            }


            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;


            player.spinning = true;
            player.spinTimer = ROBSAN_SPIN_DURATION;
            player.hasBall = false;

            const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);

            vfx.robsanAura.push({x:player.x, y:player.y, end:now + ROBSAN_SPIN_DURATION * 2, radius:player.r*1.5, t:0, life:ROBSAN_SPIN_DURATION * 2});
            for(let i=0; i<30; i++) {
                const angleOffset = Math.random() * Math.PI * 2;
                const radiusOffset = player.r * (0.5 + Math.random() * 0.5);
                vfx.robsanParticles.push(newRobsanParticle(player.x + Math.cos(angleOffset) * radiusOffset, player.y + Math.sin(angleOffset) * radiusOffset));
            }

            vfx.robsanShadowClones.push(...newRobsanShadowClones(player.x, player.y));
            vfx.robsanVoidRifts.push(newRobsanVoidRift(player.x, player.y));

            // EPIC NEW SHADOW SPIRAL VFX
            vfx.epicExplosions.push({
                x: player.x, y: player.y, t: 0, life: 1500,
                startRadius: 15, endRadius: 120, maxOpacity: 0.9
            });
            vfx.massiveShockwaves.push({
                x: player.x, y: player.y, t: 0, life: 2000,
                startRadius: 20, endRadius: 200, maxOpacity: 0.8
            });
            vfx.particleStorms.push({
                x: player.x, y: player.y, t: 0, life: 3000, intensity: 1.2,
                particles: Array.from({length: 80}, () => ({
                    x: player.x + (Math.random() - 0.5) * 60,
                    y: player.y + (Math.random() - 0.5) * 60,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    r: 2 + Math.random() * 4,
                    color: {r: 68 + Math.random() * 30, g: 10 + Math.random() * 20, b: 107 + Math.random() * 50}
                }))
            });

            for(let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 4;
                const radius = i * 2;
                vfx.robsanParticles.push({
                    x: player.x + Math.cos(angle) * radius,
                    y: player.y + Math.sin(angle) * radius,
                    vx: -Math.sin(angle) * 3,
                    vy: Math.cos(angle) * 3,
                    t: 0, life: 800 + Math.random() * 400,
                    r: 2 + Math.random() * 3,
                    color: 'rgba(68, 10, 107,'
                });
            }

            setTimeout(() => {
                if(gameState !== 'game') return;
                player.spinning = false;
                player.charging = true;
                player.chargeTimer = ROBSAN_CHARGE_DURATION;
                vfx.robsanChargeAura.push({x:player.x, y:player.y, end:performance.now() + ROBSAN_CHARGE_DURATION, radius:player.r*1.2, t:0, life:ROBSAN_CHARGE_DURATION});
            }, ROBSAN_SPIN_DURATION);


            setTimeout(() => {
                if(gameState !== 'game') return;
                player.charging = false;

                const launch = 28;
                ball.vx = Math.cos(dir)*launch + player.vx*0.2;
                ball.vy = Math.sin(dir)*launch + player.vy*0.2;
                ball.maxSpeed = 100000;

                const endTime = performance.now() + 600;
                vfx.shadowTrails.push({end:endTime, w:20});
                shockwave(player.x, player.y, 25, 'robsan');

                for(let i=0; i<5; i++) vfx.robsanGroundRupture.push(newRobsanGroundRupture(player.x, player.y, dir + (Math.random()-0.5)*Math.PI/2));

                // EPIC SHADOW SPIRAL LAUNCH VFX
                vfx.energyNovas.push({
                    x: player.x, y: player.y, t: 0, life: 1200,
                    startRadius: 10, endRadius: 100, maxOpacity: 0.8
                });
                vfx.cosmicRifts.push({
                    x: player.x, y: player.y, t: 0, life: 2500,
                    radius: 60, angle: dir
                });

                const origFric = ball.friction;
                ball.friction = 0.992;
                setTimeout(()=>{ ball.friction = origFric; ball.maxSpeed=18; }, 600);

                player.hasBall = false;

            }, ROBSAN_SPIN_DURATION + ROBSAN_CHARGE_DURATION);

            shadowSpiralReadyAt = now + ABILITY_COOLDOWN;
        }

function tryRobsanEclipseGrasp(){
    if(currentStyle !== 'robsan') return;
    const now = performance.now();
    if(now < eclipseGraspReadyAt) return;
    if(player.hasBall) {
        showNotification('eclipse grasp needs you to not have the ball', 'warning');
        return;
    }

    if (player.spinning || player.charging || player.telekinising || player.dashing ||
        player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
        player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
        player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

    player.telekinising = true;
    player.eclipseGraspActive = true;
    player.hasBall = false;

    vfx.eclipseAura.push({x:player.x, y:player.y, end:now + ECLIPSE_AURA_DURATION * 2, radius:player.r*2, t:0, life:ECLIPSE_AURA_DURATION * 2});
    for(let i=0; i<20; i++) {
        vfx.robsanEclipseWisps.push(newRobsanEclipseWisp(player.x, player.y));
        if(i % 2 === 0) {
            vfx.robsanVoidPuffs.push(newRobsanVoidPuff(player.x, player.y, 'eclipse'));
        }
    }

    const pulseInterval = setInterval(() => {
        if(!player.telekinising || gameState !== 'game') {
            clearInterval(pulseInterval);
            return;
        }
        vfx.robsanVoidPuffs.push(newRobsanVoidPuff(ball.x, ball.y, 'eclipse'));
    }, 100);

    setTimeout(() => {
        clearInterval(pulseInterval);
        if(player.telekinising) {
            player.telekinising = false;
            player.eclipseGraspActive = false;
        }
    }, 3000);

    eclipseGraspReadyAt = now + ABILITY_COOLDOWN;
}
        function tryRobsanVoidDash(){
            if(currentStyle !== 'robsan') return;
            const now = performance.now();
            if(now < voidDashReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.dashing = true;
            player.dashTimer = VOID_DASH_DURATION;

            const dashDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);

            player.vx = Math.cos(dashDir) * VOID_DASH_SPEED;
            player.vy = Math.sin(dashDir) * VOID_DASH_SPEED;

            vfx.voidTrails.push({
                x: player.x, y: player.y,
                end: now + VOID_DASH_DURATION + 100,
                trailColorStart: getComputedStyle(document.documentElement).getPropertyValue('--void-trail-color-start'),
                trailColorEnd: getComputedStyle(document.documentElement).getPropertyValue('--void-trail-color-end'),
                w: player.r * 1.5
            });
            vfx.robsanVoidPuffs.push(newRobsanVoidPuff(player.x, player.y, 'start'));

            // EPIC VOID DASH VFX  
            vfx.dimensionalTears.push({
                x: player.x, y: player.y, t: 0, life: 800,
                width: 80, height: 15, angle: dashDir
            });
            vfx.epicExplosions.push({
                x: player.x, y: player.y, t: 0, life: 600,
                startRadius: 8, endRadius: 40, maxOpacity: 0.7
            });
            vfx.particleStorms.push({
                x: player.x, y: player.y, t: 0, life: 1000, intensity: 0.8,
                particles: Array.from({length: 40}, () => ({
                    x: player.x + (Math.random() - 0.5) * 30,
                    y: player.y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    r: 1 + Math.random() * 2,
                    color: {r: 30 + Math.random() * 20, g: 27 + Math.random() * 20, b: 75 + Math.random() * 30}
                }))
            });

            setTimeout(() => {
                if(gameState !== 'game') return;
                player.dashing = false;
                player.vx *= 0.2;
                player.vy *= 0.2;
            }, VOID_DASH_DURATION);

            voidDashReadyAt = now + ABILITY_COOLDOWN;
        }


        function tryXDrakeSupernova() {
            if (currentStyle !== 'xdrake') return;
            const now = performance.now();
            if (now < supernovaReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.xdrakeSupernovaDashing = true;
            player.xdrakeSupernovaDashTimer = XDRAKE_SUPERNOVA_DASH_DURATION;

            const dashDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            player.vx = Math.cos(dashDir) * XDRAKE_SUPERNOVA_DASH_SPEED;
            player.vy = Math.sin(dashDir) * XDRAKE_SUPERNOVA_DASH_SPEED;


            vfx.xdrakeSupernovaTrails.push({
                x: player.x, y: player.y,
                end: now + XDRAKE_SUPERNOVA_DASH_DURATION + 100,
                trailColorStart: getComputedStyle(document.documentElement).getPropertyValue('--xdrake-dash-trail-start'),
                trailColorEnd: getComputedStyle(document.documentElement).getPropertyValue('--xdrake-dash-trail-end'),
                w: player.r * 1.8
            });
            shockwave(player.x, player.y, player.r, 'xdrake-supernova');

            vfx.xdrakeSupernovaGroundCrack.push(newXDrakeGroundCrack(player.x, player.y));
            vfx.xdrakeNatureSpirits.push(...newXDrakeNatureSpirits(player.x, player.y));
            vfx.xdrakeTerraforms.push(...newXDrakeTerraform(player.x, player.y, dashDir));

            for(let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                vfx.sparks.push({
                    x: player.x, y: player.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 400 + Math.random() * 300,
                    t: 0, r: 2 + Math.random() * 3,
                    color: 'rgba(34, 197, 94,'
                });
            }

            setTimeout(() => {
                if (gameState !== 'game') return;
                player.xdrakeSupernovaDashing = false;
                player.vx *= 0.2;
                player.vy *= 0.2;
            }, XDRAKE_SUPERNOVA_DASH_DURATION);

            supernovaReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryXDrakeFossilFootwork() {
            if (currentStyle !== 'xdrake') return;
            const now = performance.now();
            if (now < fossilFootworkReadyAt) return;
            if (!player.hasBall) {
                showNotification('fossilised footwork needs the ball bestie', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.xdrakeFossilFootworking = true;
            player.xdrakeFossilFootworkTimer = XDRAKE_FOSSIL_FOOTWORK_DURATION;

            const footworkDir = Math.atan2(mouse.y - player.y, mouse.x - player.x - 0.001);
            player.vx = Math.cos(footworkDir) * XDRAKE_FOSSIL_FOOTWORK_SPEED;
            player.vy = Math.sin(footworkDir) * XDRAKE_FOSSIL_FOOTWORK_SPEED;


            for(let i = 0; i < 8; i++) {
                vfx.xdrakeFootworkDust.push(newXDrakeFootworkParticle(player.x, player.y));
            }
            shockwave(player.x, player.y, player.r * 0.8, 'xdrake-footwork');

            for(let i=0; i<6; i++) vfx.xdrakeFootworkLeaves.push(newXDrakeFootworkLeaf(player.x, player.y, footworkDir));
            impactWave(player.x, player.y, player.r * 0.7);

            setTimeout(() => {
                if (gameState !== 'game') return;
                player.xdrakeFossilFootworking = false;
                player.vx *= 0.3;
                player.vy *= 0.3;
            }, XDRAKE_FOSSIL_FOOTWORK_DURATION);

            fossilFootworkReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryXDrakeAncientApex() {
            if (currentStyle !== 'xdrake') return;
            const now = performance.now();
            if (now < ancientApexReadyAt) return;
            if (!player.hasBall) {
                showNotification('ancient apex needs the ball bestie', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.xdrakeAncientApexCharging = true;
            player.ancientApexChargeTimer = now;


            powerBar.style.opacity = 1;



            ancientApexReadyAt = now + ABILITY_COOLDOWN;
        }

        function xdrakeAncientApexShoot(chargeProgress) {
            if (currentStyle !== 'xdrake' || !player.xdrakeAncientApexCharging) return;
            if (!player.hasBall) {
                player.xdrakeAncientApexCharging = false;
                return;
            }

            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            const launchPower = XDRAKE_ANCIENT_APEX_SHOT_POWER * chargeProgress;

            ball.vx = Math.cos(dir) * launchPower + player.vx * 0.2;
            ball.vy = Math.sin(dir) * launchPower + player.vy * 0.2;
            ball.maxSpeed = 100000;

            player.hasBall = false;
            player.xdrakeAncientApexCharging = false;

            const endTime = performance.now() + 800;
            vfx.xdrakeApexAura.push({
                x: player.x, y: player.y,
                end: endTime,
                radius: player.r * 2,
                t: 0, life: 800
            });
            shockwave(player.x, player.y, 30, 'xdrake-apex');

            for(let i=0; i<10; i++) vfx.xdrakeAncientApexGroundBurst.push(newXDrakeAncientApexGroundBurst(player.x, player.y));

            const origFric = ball.friction;
            ball.friction = 0.99;
            setTimeout(() => { ball.friction = origFric; ball.maxSpeed = 18; }, 800);
            endCharge();
        }


        function tryGojoRed() {
            if (currentStyle !== 'gojo') return;
            const now = performance.now();
            if (now < gojoRedReadyAt) return;
            if (!player.hasBall) {
                showNotification('red needs the ball bestie', 'warning');
                return;
            }


            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.gojoRedCharging = true;
            player.gojoRedChargeStartTime = now;


            powerBar.style.opacity = 1;


            autoTimer = setTimeout(() => {
                if (gameState !== 'game' || !player.gojoRedCharging) return;

                const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);

                ball.vx = Math.cos(dir) * GOJO_RED_SHOT_POWER + player.vx * 0.2;
                ball.vy = Math.sin(dir) * GOJO_RED_SHOT_POWER + player.vy * 0.2;
                ball.maxSpeed = 100000;

                player.hasBall = false;
                player.gojoRedCharging = false;
                player.gojoRedActive = true;

                vfx.gojoRedTrail.push({
                    end: now + 500,
                    w: 18,
                    colorStart: getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-trail-start'),
                    colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-trail-end')
                });
                shockwave(player.x, player.y, player.r, 'gojo-red');

                vfx.gojoRedExplosion.push(newGojoRedExplosion(player.x, player.y));

                const origFric = ball.friction;
                ball.friction = 0.99;
                setTimeout(() => {
                    if (gameState !== 'game') return;
                    ball.friction = origFric;
                    ball.maxSpeed = 18;
                    player.gojoRedActive = false;
                }, 500);
                endCharge();
            }, GOJO_RED_CHARGE_DURATION);

            gojoRedReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryGojoLapseBlue() {
            if (currentStyle !== 'gojo') return;
            const now = performance.now();
            if (now < gojoLapseBlueReadyAt) return;
            if (player.hasBall) {
                showNotification('lapse blue needs you to not have the ball', 'warning');
                return;
            }


            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.gojoLapseBlueActive = true;
            player.gojoLapseBlueBall = {
                x: player.x + GOJO_LAPSE_BLUE_ORBIT_RADIUS,
                y: player.y,
                r: GOJO_LAPSE_BLUE_BALL_RADIUS,
                angle: 0,
                orbitRadius: GOJO_LAPSE_BLUE_ORBIT_RADIUS,
                speed: GOJO_LAPSE_BLUE_ORBIT_SPEED,
                originTime: now,
                lifeTime: ABILITY_COOLDOWN * 0.8
            };


            for(let i=0; i<15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.5 + Math.random() * 1.5;
                const life = 200 + Math.random() * 300;
                vfx.sparks.push({x: player.x, y: player.y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life, t:0, r:2+Math.random()*2, color:'rgba(49, 130, 206,'});
            }
            shockwave(player.x, player.y, player.r * 1.2, 'gojo-blue');

            vfx.gojoInfinityBarriers.push(...newGojoInfinityBarrier(player.x, player.y));
            vfx.gojoDomainExpansions.push(newGojoDomainExpansion(player.x, player.y));

            setTimeout(() => {
                if(gameState !== 'game') return;
                player.gojoLapseBlueActive = false;
                player.gojoLapseBlueBall = null;
            }, player.gojoLapseBlueBall.lifeTime);

            gojoLapseBlueReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryGojoPurple() {
            if (currentStyle !== 'gojo') return;
            const now = performance.now();
            if (now < gojoPurpleReadyAt) return;
            if (!player.hasBall) {
                showNotification('purple needs the ball bestie', 'warning');
                return;
            }


            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.gojoPurpleActive = true;
            player.hasBall = false;

            player.gojoPurpleInitialDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);


            const dir = player.gojoPurpleInitialDir;
            const spreadDist = GOJO_PURPLE_SPREAD_DISTANCE;
            const leftSpreadX = player.x + Math.cos(dir - Math.PI/2) * spreadDist;
            const leftSpreadY = player.y + Math.sin(dir - Math.PI/2) * spreadDist;
            const rightSpreadX = player.x + Math.cos(dir + Math.PI/2) * spreadDist;
            const rightSpreadY = player.y + Math.sin(dir + Math.PI/2) * spreadDist;

            player.gojoPurpleLeftBall = {
                x: leftSpreadX,
                y: leftSpreadY,
                r: GOJO_LAPSE_BLUE_BALL_RADIUS * 0.8,
                vx: 0, vy: 0,
                color: 'var(--gojo-red-primary)'
            };

            player.gojoPurpleRightBall = {
                x: rightSpreadX,
                y: rightSpreadY,
                r: GOJO_LAPSE_BLUE_BALL_RADIUS * 0.8,
                vx: 0, vy: 0,
                color: 'var(--gojo-blue-primary)'
            };
            player.gojoPurpleConverging = true;
            player.gojoPurpleConvergenceStartTime = now;
            player.gojoPurpleShotFired = false;

            gojoPurpleReadyAt = now + ABILITY_COOLDOWN * 2;
        }

        function shootPurpleShot(x, y, initialMouseDir) {
            const dir = initialMouseDir;
            ball.vx = Math.cos(dir) * GOJO_PURPLE_FINAL_SHOT_POWER;
            ball.vy = Math.sin(dir) * GOJO_PURPLE_FINAL_SHOT_POWER;
            ball.maxSpeed = 100000;


            ball.x = x;
            ball.y = y;


            player.hasBall = false;

            vfx.gojoPurpleTrail.push({
                x: x, y: y,
                end: performance.now() + 1000,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--gojo-purple-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--gojo-purple-trail-end'),
                w: 30
            });

            const origFric = ball.friction;
            ball.friction = 0.99;
            setTimeout(() => {
                if (gameState !== 'game') return;
                ball.friction = origFric;
                ball.maxSpeed = 18;
            }, 1000);
        }

        function tryEddieWeAre() {
            if (currentStyle !== 'eddie') return;
            const now = performance.now();
            if (now < eddieWeAreReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;


            player.eddieWeAreActive = true;
            player.eddieWeAreOriginalMaxSpd = player.maxSpd;
            player.maxSpd *= EDDIE_WE_ARE_SPEED_BOOST;
            player.eddieWeAreEndTime = now + EDDIE_WE_ARE_DURATION;

            vfx.eddieWeAreAura.push({
                x: player.x, y: player.y,
                end: player.eddieWeAreEndTime,
                radius: player.r * 1.5,
                t: 0, life: EDDIE_WE_ARE_DURATION
            });
            for(let i=0; i<20; i++) {
                vfx.eddieWeAreParticles.push(newEddieWeAreParticle(player.x, player.y));
            }

            vfx.eddieWeAreRipples.push(newEddieWeAreRipple(player.x, player.y));
            vfx.eddieSymbioteSpikes.push(...newEddieSymbioteSpikes(player.x, player.y));
            vfx.eddieVenomDrops.push(...newEddieVenomDrops(player.x, player.y));

            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                vfx.eddieVenomTendrils.push({
                    startX: player.x,
                    startY: player.y,
                    endX: player.x + Math.cos(angle) * 40,
                    endY: player.y + Math.sin(angle) * 40,
                    t: 0, life: 600,
                    wiggleFreq: 0.2, wiggleAmp: 5
                });
            }

            eddieWeAreReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryEddieVenomStrike() {
            if (currentStyle !== 'eddie') return;
            const now = performance.now();
            if (now < eddieVenomStrikeReadyAt) return;
            if (player.hasBall) {
                showNotification('venom strike needs you to not have the ball', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;


            player.eddieVenomStrikeActive = true;

            vfx.eddieVenomTendrils.push({
                startX: player.x, startY: player.y,
                endX: ball.x, endY: ball.y,
                t: 0, life: 1000,
                wiggleFreq: 0.1, wiggleAmp: 8
            });

            eddieVenomStrikeReadyAt = now + ABILITY_COOLDOWN;
        }

        function startNewSymbioteMontageTeleport() {
            const now = performance.now();
            const minX = margin + player.r;
            const maxX = W - margin - player.r;
            const minY = margin + player.r;
            const maxY = H - margin - player.r;

            const targetX = minX + Math.random() * (maxX - minX);
            const targetY = minY + Math.random() * (maxY - minY);

            player.eddieSymbioteMontageCurrentTeleportTarget = {x: targetX, y: targetY};
            player.eddieSymbioteMontageTeleportStartTime = now;

            const dist = Math.hypot(player.x - targetX, player.y - targetY);
            const teleportDuration = Math.max(100, Math.min(500, dist / EDDIE_SYMBIOTE_MONTAGE_TELEPORT_SPEED * 1000));
            player.eddieSymbioteMontageTeleportEndTime = now + teleportDuration;
            player.eddieSymbioteMontageStartPlayerPos = {x: player.x, y: player.y};
            player.hasBall = true;

            shockwave(player.x, player.y, player.r, 'eddie-montage');
            vfx.eddieTeleportFlicker.push(newEddieTeleportFlicker(player.x, player.y));
        }


        function tryEddieSymbioteMontage() {
            if (currentStyle !== 'eddie') return;
            const now = performance.now();
            if (now < eddieSymbioteMontageReadyAt) return;
            if (!player.hasBall) {
                showNotification('symbiote montage needs the ball bestie', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.eddieSymbioteMontageActive = true;
            player.eddieSymbioteMontagePhase = 'teleporting';
            player.eddieSymbioteMontageTeleportCount = 0;
            player.eddieSymbioteMontageAimStartTime = 0;
            player.eddieSymbioteMontageShotFired = false;

            startNewSymbioteMontageTeleport();

            eddieSymbioteMontageReadyAt = now + ABILITY_COOLDOWN * 2;
        }

        // EDDIE AWAKENING MOVES - SUPER POWERFUL VERSIONS
        function tryEddieVenomDevastation() {
            if (currentStyle !== 'eddie' || !player.eddieAwakeningActive) return;
            const now = performance.now();
            if (now < eddieWeAreReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            // Super powerful speed boost and area devastation
            player.eddieWeAreActive = true;
            player.eddieWeAreOriginalMaxSpd = player.maxSpd;
            player.maxSpd *= EDDIE_WE_ARE_SPEED_BOOST * 2; // Double the normal speed boost
            player.eddieWeAreEndTime = now + EDDIE_WE_ARE_DURATION * 2; // Double duration

            // Massive black venom aura
            vfx.eddieWeAreAura.push({
                x: player.x, y: player.y,
                end: player.eddieWeAreEndTime,
                radius: player.r * 4, // Larger radius
                t: 0, life: EDDIE_WE_ARE_DURATION * 2,
                awakening: true
            });

            // Triple the particles for devastating effect
            for(let i=0; i<60; i++) {
                vfx.eddieWeAreParticles.push(newEddieWeAreParticle(player.x, player.y));
            }

            // Multiple ripples for devastation
            for(let i=0; i<5; i++) {
                setTimeout(() => {
                    vfx.eddieWeAreRipples.push(newEddieWeAreRipple(player.x, player.y));
                }, i * 200);
            }

            vfx.eddieSymbioteSpikes.push(...newEddieSymbioteSpikes(player.x, player.y));
            vfx.eddieVenomDrops.push(...newEddieVenomDrops(player.x, player.y));

            // More powerful tendrils in all directions
            for(let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                vfx.eddieVenomTendrils.push({
                    startX: player.x,
                    startY: player.y,
                    endX: player.x + Math.cos(angle) * 80, // Longer reach
                    endY: player.y + Math.sin(angle) * 80,
                    t: 0, life: 1200, // Longer lasting
                    wiggleFreq: 0.3, wiggleAmp: 10,
                    awakening: true
                });
            }

            eddieWeAreReadyAt = now + ABILITY_COOLDOWN * 0.5; // Faster cooldown
        }

        function tryEddieShadowRealm() {
            if (currentStyle !== 'eddie' || !player.eddieAwakeningActive) return;
            const now = performance.now();
            if (now < eddieVenomStrikeReadyAt) return;
            if (player.hasBall) {
                showNotification('shadow realm needs you to not have the ball', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.eddieVenomStrikeActive = true;

            // Create multiple shadow tendrils to ball
            for(let i = 0; i < 8; i++) {
                const offsetX = (Math.random() - 0.5) * 20;
                const offsetY = (Math.random() - 0.5) * 20;
                vfx.eddieVenomTendrils.push({
                    startX: player.x + offsetX, startY: player.y + offsetY,
                    endX: ball.x, endY: ball.y,
                    t: 0, life: 1500, // Longer lasting
                    wiggleFreq: 0.2, wiggleAmp: 12,
                    awakening: true
                });
            }

            // Instantly teleport ball to goal with immense force
            setTimeout(() => {
                if (gameState !== 'game') return;
                ball.x = W - margin - goalDepth + 5; // Right into the goal
                ball.y = H/2; // Center of goal
                ball.vx = 15; // Powerful shot
                ball.vy = 0;

                // Massive explosion effect at goal
                shockwave(ball.x, ball.y, 50, 'eddie-venom');
                for(let i=0; i<30; i++) {
                    vfx.eddieWeAreParticles.push(newEddieWeAreParticle(ball.x, ball.y));
                }
            }, 500);

            eddieVenomStrikeReadyAt = now + ABILITY_COOLDOWN * 0.3; // Much faster cooldown
        }

        function tryZeusLightningBolt() {
            if (currentStyle !== 'zeus') return;
            const now = performance.now();
            if (now < zeusLightningReadyAt) return;
            if (!player.hasBall) {
                showNotification('lightning bolt needs the ball bestie', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusHeavenlyShieldActive || player.zeusOlympusFuryActive || player.asherAutoGoalActive) return;

            player.zeusLightningCharging = true;
            player.zeusLightningChargeStartTime = now;
            powerBar.style.opacity = 1;

            autoTimer = setTimeout(() => {
                if (gameState !== 'game' || !player.zeusLightningCharging) return;
                zeusLightningShoot();
                player.zeusLightningCharging = false;
                vfx.zeusLightningChargeEffect = [];
                endCharge();
            }, ZEUS_LIGHTNING_CHARGE_DURATION);

            zeusLightningReadyAt = now + ABILITY_COOLDOWN;
        }

        function zeusLightningShoot() {
            if (currentStyle !== 'zeus' || !player.zeusLightningCharging) return;
            if (!player.hasBall) {
                player.zeusLightningCharging = false;
                return;
            }

            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.vx = Math.cos(dir) * ZEUS_LIGHTNING_SHOT_POWER + player.vx * 0.2;
            ball.vy = Math.sin(dir) * ZEUS_LIGHTNING_SHOT_POWER + player.vy * 0.2;
            ball.maxSpeed = 100000;
            player.hasBall = false;
            player.zeusLightningActive = true;

            vfx.zeusLightningTrail.push({
                end: performance.now() + 400,
                w: 18,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--zeus-lightning-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--zeus-lightning-trail-end')
            });
            shockwave(player.x, player.y, player.r, 'zeus-lightning');

            for (let i = 0; i < 15; i++) {
                vfx.zeusLightningParticles.push(newZeusLightningParticle(player.x, player.y, dir));
            }

            vfx.zeusThunderClouds.push(...newZeusThunderClouds(player.x, player.y));
            vfx.zeusLightningBolts.push(...newZeusLightningBolts(player.x, player.y));

            for(let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 60;
                vfx.zeusLightningParticles.push({
                    x: player.x + Math.cos(angle) * distance,
                    y: player.y + Math.sin(angle) * distance,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 300 + Math.random() * 200,
                    t: 0, r: 1 + Math.random() * 2,
                    color: 'rgba(255, 255, 255,'
                });
            }
            vfx.zeusLightningChargeEffect = [];

            const origFric = ball.friction;
            ball.friction = 0.99;
            setTimeout(() => {
                if (gameState !== 'game') return;
                ball.friction = origFric;
                ball.maxSpeed = 18;
                player.zeusLightningActive = false;
            }, 400);

            player.zeusLightningCharging = false;
            endCharge();
        }

        function tryZeusHeavenlyShield() {
            if (currentStyle !== 'zeus') return;
            const now = performance.now();
            if (now < zeusHeavenlyShieldReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.asherAutoGoalActive) return;

            player.zeusHeavenlyShieldActive = true;
            player.zeusHeavenlyShieldEndTime = now + ZEUS_HEAVENLY_SHIELD_DURATION;
            player.zeusHeavenlyShieldRadius = ZEUS_HEAVENLY_SHIELD_RADIUS;

            shockwave(player.x, player.y, player.r * 1.5, 'zeus-shield');
            vfx.zeusHeavenlyShieldAura.push({
                x: player.x, y: player.y,
                end: player.zeusHeavenlyShieldEndTime,
                radius: ZEUS_HEAVENLY_SHIELD_RADIUS,
                t: 0, life: ZEUS_HEAVENLY_SHIELD_DURATION
            });
            for(let i=0; i<10; i++) vfx.zeusHeavenlyShieldWaves.push(newZeusShieldWave(player.x, player.y));

            zeusHeavenlyShieldReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryZeusOlympusFury() {
            if (currentStyle !== 'zeus') return;
            const now = performance.now();
            if (now < zeusOlympusFuryReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.zeusOlympusFuryActive = true;
            player.zeusOlympusFuryPhase = 'pulling';
            player.zeusOlympusFuryPullStartTime = now;
            player.zeusOlympusFuryAimStartTime = 0;
            player.zeusOlympusFuryShotFired = false;
            player.zeusOlympusFuryOrigHasBall = player.hasBall;

            if (player.hasBall) {
                player.zeusOlympusFuryPhase = 'aiming';
                player.zeusOlympusFuryAimStartTime = now;
                vfx.zeusOlympusFuryAura.push({
                    x: player.x, y: player.y,
                    end: now + ZEUS_OLYMPUS_FURY_AIM_DURATION,
                    radius: player.r * 2.5,
                    t: 0, life: ZEUS_OLYMPUS_FURY_AIM_DURATION
                });
            } else {
                shockwave(player.x, player.y, player.r * 1.5, 'zeus-olympus-pull');
            }

            zeusOlympusFuryReadyAt = now + ABILITY_COOLDOWN * 2;
        }

        function zeusOlympusFuryShoot() {
            if (currentStyle !== 'zeus' || !player.zeusOlympusFuryActive || player.zeusOlympusFuryPhase !== 'aiming') return;
            if (!player.hasBall) {
                player.zeusOlympusFuryActive = false;
                return;
            }
            if (player.zeusOlympusFuryShotFired) return;

            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.vx = Math.cos(dir) * ZEUS_OLYMPUS_FURY_SHOT_POWER + player.vx * 0.1;
            ball.vy = Math.sin(dir) * ZEUS_OLYMPUS_FURY_SHOT_POWER + player.vy * 0.1;
            ball.maxSpeed = 100000;
            player.hasBall = false;
            player.zeusOlympusFuryShotFired = true;

            vfx.zeusOlympusFuryBallTrail.push({
                end: performance.now() + 800,
                w: 30,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--zeus-olympus-ball-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--zeus-olympus-ball-trail-end')
            });
            shockwave(player.x, player.y, player.r * 2, 'zeus-olympus-shot');

            vfx.zeusGroundScorches.push(newZeusGroundScorch(ball.x, ball.y));


            const origFric = ball.friction;
            ball.friction = 0.99;
            setTimeout(() => {
                if (gameState !== 'game') return;
                ball.friction = origFric;
                ball.maxSpeed = 18;
            }, 800);

            player.zeusOlympusFuryActive = false;
            player.zeusOlympusFuryPhase = '';
            player.zeusOlympusFuryPullStartTime = 0;
            player.zeusOlympusFuryAimStartTime = 0;
            player.zeusOlympusFuryShotFired = false;
            player.zeusOlympusFuryOrigHasBall = false;
            endCharge();
        }

        // NEW ASHER ABILITY FUNCTIONS
function tryAsherAutoGoal() {
            if (currentStyle !== 'asher') return;
            const now = performance.now();
            if (now < asherAutoGoalReadyAt) return;
            if (!player.hasBall) {
                showNotification('starfall shot needs the ball bestie', 'warning');
                return;
            }

            // Check if another ability is active
            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive) return;

            // Start the circling charge
            player.asherStarfallCharging = true;
            player.asherStarfallChargeStartTime = now;
            player.hasBall = false; // The ball is now controlled by the orbit logic

            shockwave(player.x, player.y, player.r * 1.5, 'asher');

            // Set a timer to launch the ball after the orbit duration
            setTimeout(() => {
                // Ensure the game is still running and the charge is active
                if (gameState !== 'game' || !player.asherStarfallCharging) return;

                player.asherStarfallCharging = false;
                player.asherAutoGoalActive = true;

                // Shoot from the ball's current position
                const dir = Math.atan2((H / 2) - ball.y, (W - margin) - ball.x);
                ball.vx = Math.cos(dir) * ASHER_HOMING_SHOT_POWER;
                ball.vy = Math.sin(dir) * ASHER_HOMING_SHOT_POWER;
                ball.maxSpeed = ASHER_HOMING_SHOT_POWER * 1.5;

                ball.isHoming = true;
                ball.homingTargetX = W - margin - (goalDepth / 2);
                ball.homingTargetY = H / 2;
                ball.homingEndTime = performance.now() + ASHER_HOMING_SHOT_DURATION;

                vfx.asherStarTrail.push({
                    end: ball.homingEndTime,
                    w: 18,
                    colorStart: getComputedStyle(document.documentElement).getPropertyValue('--asher-star-trail-start'),
                    colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--asher-star-trail-end')
                });

                const origFric = ball.friction;
                ball.friction = 0.998;
                setTimeout(() => {
                    if (gameState !== 'game') return;
                    ball.friction = origFric;
                    ball.maxSpeed = 18;
                    ball.isHoming = false;
                    player.asherAutoGoalActive = false;
                }, ASHER_HOMING_SHOT_DURATION);

            }, ASHER_STARFALL_CHARGE_DURATION);

            asherAutoGoalReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryAsherBallTeleport() {
            if (currentStyle !== 'asher') return;
            const now = performance.now();
            if (now < asherBallTeleportReadyAt) return;
            if (player.hasBall) {
                showNotification('celestial pull cant be used while you have the ball', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            // VFX at ball's original position
            for (let i = 0; i < 20; i++) {
                vfx.asherTeleportBurst.push(newAsherTeleportParticle(ball.x, ball.y));
            }
            shockwave(ball.x, ball.y, ball.r * 2, 'asher');

            // Teleport the ball
            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.x = player.x + Math.cos(dir) * (player.r + ball.r + 4);
            ball.y = player.y + Math.sin(dir) * (player.r + ball.r + 4);
            ball.vx = 0;
            ball.vy = 0;
            player.hasBall = true;

            // VFX at ball's new position
            for (let i = 0; i < 15; i++) {
                vfx.asherArrivalGlimmer.push(newAsherArrivalParticle(ball.x, ball.y));
            }
            shockwave(player.x, player.y, player.r, 'asher');

            asherBallTeleportReadyAt = now + ABILITY_COOLDOWN;
        }


        // NEW LEONARDO ABILITY FUNCTIONS
// NEW LEONARDO ABILITY FUNCTIONS (UPGRADED)
        function tryLeonardoFocusShot() {
            if (currentStyle !== 'leonardo') return;
            const now = performance.now();
            if (now < leonardoFocusShotReadyAt) return;
            if (!player.hasBall) {
                showNotification('focus shot needs the ball bestie', 'warning');
                return;
            }

            if (player.leonardoShieldActive || player.leonardoDashing) return;

            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.vx = Math.cos(dir) * LEONARDO_FOCUS_SHOT_POWER + player.vx * 0.25;
            ball.vy = Math.sin(dir) * LEONARDO_FOCUS_SHOT_POWER + player.vy * 0.25;
            ball.maxSpeed = 100000;
            player.hasBall = false;
            player.leonardoFocusShotActive = true;

            // Trigger the new "double door" text VFX
            vfx.leonardoFocusText.push({
                x: player.x, y: player.y,
                end: now + 1000,
                t: 0, life: 1000
            });

            // Add focus particles burst
            for (let i = 0; i < 25; i++) {
                vfx.leonardoFocusParticles.push(newLeonardoFocusParticle(player.x, player.y, dir));
            }

            // Add a lens flare effect
            vfx.flashes.push({
                x: player.x, y: player.y,
                t: 0, life: 400,
                radius: 80,
                color: 'rgba(165, 243, 252, 0.8)'
            });

            vfx.leonardoFocusTrail.push({
                end: performance.now() + 600,
                w: 22,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-focus-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-focus-trail-end')
            });


        Trycaption("AUTISM ATTACK!", "Zoom");
            shockwave(player.x, player.y, 20, 'leonardo');

            const origFric = ball.friction;
            ball.friction = 0.993;
            setTimeout(() => {
                ball.friction = origFric;
                ball.maxSpeed = 18;
                player.leonardoFocusShotActive = false;
            }, 600);

            leonardoFocusShotReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryLeonardoSensoryShield() {
            if (currentStyle !== 'leonardo') return;
            const now = performance.now();
            if (now < leonardoShieldReadyAt) return;

            if (player.leonardoFocusShotActive || player.leonardoDashing) return;

            player.leonardoShieldActive = true;
            player.leonardoShieldEndTime = now + LEONARDO_SHIELD_DURATION;

            // Trigger the new geometric shield VFX
            vfx.leonardoShieldAura.push({
                x: player.x, y: player.y,
                end: player.leonardoShieldEndTime,
                radius: LEONARDO_SHIELD_RADIUS,
                t: 0, life: LEONARDO_SHIELD_DURATION
            });

            // Add shield particles burst
            for (let i = 0; i < 20; i++) {
                vfx.leonardoShieldParticles.push(newLeonardoShieldParticle(player.x, player.y));
            }

            shockwave(player.x, player.y, player.r * 1.2, 'leonardo');

            leonardoShieldReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryLeonardoPatternWeave() {
            if (currentStyle !== 'leonardo') return;
            const now = performance.now();
            if (now < leonardoDashReadyAt) return;

            if (player.leonardoFocusShotActive || player.leonardoShieldActive) return;

            player.leonardoDashing = true;
            player.leonardoDashTimer = LEONARDO_DASH_DURATION;

            const dashDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            player.vx = Math.cos(dashDir) * LEONARDO_DASH_SPEED;
            player.vy = Math.sin(dashDir) * LEONARDO_DASH_SPEED;

            // Store the end position for the new VFX
            player.leonardoDashEndX = player.x + Math.cos(dashDir) * LEONARDO_DASH_SPEED * (LEONARDO_DASH_DURATION / 16.67);
            player.leonardoDashEndY = player.y + Math.sin(dashDir) * LEONARDO_DASH_SPEED * (LEONARDO_DASH_DURATION / 16.67);

            vfx.leonardoDashTrail.push({
                end: now + LEONARDO_DASH_DURATION + 150,
                w: player.r * 1.6,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-trail-end')
            });

            // Add dash particles burst
            for (let i = 0; i < 15; i++) {
                vfx.leonardoDashParticles.push(newLeonardoDashParticle(player.x, player.y, dashDir));
            }

            setTimeout(() => {
                if (gameState !== 'game') return;
                player.leonardoDashing = false;
                player.vx *= 0.2;
                player.vy *= 0.2;
                // Leave the pattern field behind
                vfx.leonardoPatternField.push({
                    x: player.x, y: player.y,
                    t: 0, life: LEONARDO_PATTERN_FIELD_DURATION,
                    radius: player.r * 3
                });
            }, LEONARDO_DASH_DURATION);

            leonardoDashReadyAt = now + ABILITY_COOLDOWN;
        }

function tryAngusPowerBurst() {
if (currentStyle !== 'angus') return;
const now = performance.now();

if (player.angusBurstUsesLeft <= 0) {
showNotification('power burst uses exhausted', 'warning');
return;
}

if (!player.hasBall) {
showNotification('power burst needs the ball bestie', 'warning');
return;
}

if (player.angusCharging) return;

// Start charging
player.angusCharging = true;
player.angusChargeStartTime = now;
TrySubtitle("AHH ITS COMING OUT");

// Charging particles effect + white puddle
const chargeInterval = setInterval(() => {
if (!player.angusCharging) {
clearInterval(chargeInterval);
return;
}

// Add white charging particles around player
for (let i = 0; i < 5; i++) {
vfx.angusChargeParticles.push(newAngusChargeParticle(player.x, player.y));
}

// Add white puddle effect under player
vfx.angusPuddles = vfx.angusPuddles || [];
vfx.angusPuddles.push({
x: player.x,
y: player.y + 10, // slightly below player to look like a puddle
t: 0,
life: ANGUS_CHARGE_DURATION, // disappear when charging ends
radius: 40, // size of puddle
alpha: 0.3 // semi-transparent white
});

}, 50);

setTimeout(() => {
if (!player.angusCharging || !player.hasBall) return;

player.angusCharging = false;
player.angusBurstUsesLeft--;

// Massive white burst effect
vfx.angusBurstVFX.push({
x: player.x, y: player.y,
t: 0, life: 800,
radius: 100
});

// Add burst particles
for (let i = 0; i < 40; i++) {
vfx.angusChargeParticles.push(newAngusBurstParticle(player.x, player.y));
}
TrySubtitle("oh.. it already did, jacob pls dont make it happen again");

// Super powerful shot
const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
ball.vx = Math.cos(dir) * ANGUS_BURST_POWER + player.vx * 0.1;
ball.vy = Math.sin(dir) * ANGUS_BURST_POWER + player.vy * 0.1;
ball.maxSpeed = 100000;
player.hasBall = false;


shockwave(player.x, player.y, 40, 'angus');


// Reset ball speed after some time
setTimeout(() => {
ball.maxSpeed = 18;
}, 1000);

clearInterval(chargeInterval);
}, ANGUS_CHARGE_DURATION);
}


        function tryAngusTimeStop() {
            if (currentStyle !== 'angus') return;
            const now = performance.now();
            if (now < angusTimeStopReadyAt) return;

            player.angusTimeStopActive = true;
            player.angusTimeStopEndTime = now + ANGUS_TIME_STOP_DURATION;

            // Time stop field effect
            vfx.angusTimeStopField.push({
                x: player.x, y: player.y,
                t: 0, life: ANGUS_TIME_STOP_DURATION,
                radius: 200
            });

            // Freeze ball movement during time stop
            const originalBallVx = ball.vx;
            const originalBallVy = ball.vy;
            ball.vx = 0;
            ball.vy = 0;

            setTimeout(() => {
                player.angusTimeStopActive = false;
                ball.vx = originalBallVx * 0.3; // Reduced speed when time resumes
                ball.vy = originalBallVy * 0.3;
            }, ANGUS_TIME_STOP_DURATION);

            angusTimeStopReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryAngusShadowTeleport() {
            if (currentStyle !== 'angus') return;
            const now = performance.now();
            if (now < angusTeleportReadyAt) return;

            const teleportDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            const newX = player.x + Math.cos(teleportDir) * ANGUS_TELEPORT_RANGE;
            const newY = player.y + Math.sin(teleportDir) * ANGUS_TELEPORT_RANGE;

            // Clamp to field boundaries
            const clampedX = clamp(newX, player.r + margin, W - player.r - margin);
            const clampedY = clamp(newY, player.r + margin, H - player.r - margin);

            // Teleport trail effect
            vfx.angusTeleportTrail.push({
                startX: player.x, startY: player.y,
                endX: clampedX, endY: clampedY,
                t: 0, life: 600
            });

            // Teleport the player
            player.x = clampedX;
            player.y = clampedY;

            shockwave(player.x, player.y, player.r * 1.5, 'angus');

            angusTeleportReadyAt = now + ABILITY_COOLDOWN;
        }


        function kaiserSparks(x,y,dir){
            for(let i=0;i<42;i++){
                const a = dir + (Math.random()*0.6-0.3);
                const sp = 4+Math.random()*6;
                const life = 300+Math.random()*500;
                vfx.sparks.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life, t:0, r:2+Math.random()*2, color:'rgba(96,165,250,'});
            }
        }
        function newRobsanParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 2;
            const life = 200 + Math.random() * 400;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 3, color: 'rgba(68, 10, 107,' };
        }
        function newXDrakeFootworkParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.2 + Math.random() * 1.5;
            const life = 150 + Math.random() * 250;
            const size = 2 + Math.random() * 4;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: size, color: 'rgba(109, 75, 46,' };
        }

        function newEddieWeAreParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.1 + Math.random() * 0.8;
            const life = 500 + Math.random() * 500;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 3, color: 'rgba(20, 20, 20,' };
        }

        function newBlackPuddle(x, y) {
            return {x, y, t: 0, life: PUDDLE_DURATION, r: player.r * 1.2, color: 'rgba(0,0,0,'};
        }

        function newZeusLightningParticle(x, y, dir) {
            const angle = dir + (Math.random() * 0.8 - 0.4);
            const speed = 2 + Math.random() * 5;
            const life = 200 + Math.random() * 300;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(255, 255, 255,' };
        }

        function newZeusLightningChargeParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 1.5;
            const life = 150 + Math.random() * 250;
            const offsetRadius = player.r * (0.5 + Math.random() * 0.5);
            return {
                x: x + Math.cos(angle) * offsetRadius,
                y: y + Math.sin(angle) * offsetRadius,
                vx: Math.cos(angle) * speed * 0.5,
                vy: Math.sin(angle) * speed * 0.5,
                life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(59, 130, 246,'
            };
        }

        function newZeusShieldWave(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 2;
            const life = 300 + Math.random() * 400;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 3, color: 'rgba(59, 130, 246,' };
        }

        function newZeusOlympusFuryPullLine(playerX, playerY, ballX, ballY) {
            const angle = Math.atan2(ballY - playerY, ballX - playerX);
            const startX = playerX + Math.cos(angle) * player.r;
            const startY = playerY + Math.sin(angle) * player.r;
            const endX = ballX - Math.cos(angle) * ball.r;
            const endY = ballY - Math.sin(angle) * ball.r;
            return {
                startX, startY, endX, endY,
                t: 0, life: 200 + Math.random() * 100,
                thickness: 2 + Math.random() * 2,
                color: `rgba(255, 255, 255,`
            };
        }

        function newZeusGroundScorch(x, y) {
            return {
                x, y,
                t: 0, life: 1200 + Math.random() * 500,
                r: 10 + Math.random() * 10,
                startColor: 'rgba(253, 224, 71,',
                endColor: 'rgba(59, 130, 246,'
            };
        }

        // NEW ASHER PARTICLE FUNCTIONS
        function newAsherTeleportParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 3 + Math.random() * 6;
            const life = 300 + Math.random() * 400;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(233, 213, 255,' };
        }

        function newAsherArrivalParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 2;
            const life = 250 + Math.random() * 300;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 2, color: 'rgba(209, 213, 219,' };
        }

        function newHudsonSpeedLines(x, y, dir) {
            const lines = [];
            for(let i = 0; i < 8; i++) {
                lines.push({
                    x: x + (Math.random() - 0.5) * 60,
                    y: y + (Math.random() - 0.5) * 60,
                    dir: dir + (Math.random() - 0.5) * 0.3,
                    length: 40 + Math.random() * 30,
                    t: 0, life: 300 + Math.random() * 200,
                    color: 'rgba(79, 209, 197,'
                });
            }
            return lines;
        }

        function newHudsonEnergyWave(x, y) {
            return {
                x, y, t: 0, life: 800,
                initialRadius: 5, maxRadius: 80,
                color: 'rgba(79, 209, 197,'
            };
        }

        function newHudsonEmperorTrail(x, y, phase) {
            const color = phase === 'left' ?
                getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-pink') :
                getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-blue');

            return {
                x, y,
                life: 400, t: 0,
                width: 12,
                color: color,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2
            };
        }

        function newHudsonEmperorParticle(x, y, phase) {
            const color = phase === 'left' ?
                'rgba(233, 30, 99, 0.8)' :
                'rgba(63, 81, 181, 0.8)';

            return {
                x: x + (Math.random() - 0.5) * 30,
                y: y + (Math.random() - 0.5) * 30,
                life: 600, t: 0,
                r: 3 + Math.random() * 4,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                color: color
            };
        }

        function newHudsonEmperorAura(x, y) {
            return {
                x, y,
                life: 500, t: 0,
                radius: 25 + Math.random() * 15,
                phase: 'normal'
            };
        }

        // NEW LEONARDO PARTICLE FUNCTIONS
        function newLeonardoFocusParticle(x, y, dir) {
            const angle = dir + (Math.random() - 0.5) * 0.4;
            const speed = 3 + Math.random() * 8;
            const life = 400 + Math.random() * 300;
            return {
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life, t: 0, r: 1 + Math.random() * 3,
                color: 'rgba(165, 243, 252,'
            };
        }

        function newLeonardoShieldParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 2;
            const life = 300 + Math.random() * 400;
            return {
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life, t: 0, r: 2 + Math.random() * 2,
                color: 'rgba(6, 182, 212,'
            };
        }

        function newLeonardoDashParticle(x, y, dir) {
            const angle = dir + (Math.random() - 0.5) * 1.2;
            const speed = 2 + Math.random() * 5;
            const life = 250 + Math.random() * 200;
            return {
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life, t: 0, r: 1 + Math.random() * 2,
                color: 'rgba(165, 243, 252,'
            };
        }

        // NEW ANGUS PARTICLE FUNCTIONS
        function newAngusChargeParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 2;
            const life = 400 + Math.random() * 300;
            const offsetRadius = player.r * (1 + Math.random() * 2);
            return {
                x: x + Math.cos(angle) * offsetRadius,
                y: y + Math.sin(angle) * offsetRadius,
                vx: Math.cos(angle) * speed * 0.5,
                vy: Math.sin(angle) * speed * 0.5,
                life, t: 0, r: 2 + Math.random() * 3,
                color: 'rgba(255, 255, 255,'
            };
        }

        function newAngusBurstParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 3 + Math.random() * 8;
            const life = 500 + Math.random() * 400;
            return {
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life, t: 0, r: 2 + Math.random() * 4,
                color: 'rgba(255, 255, 255,'
            };
        }

        function newRobsanShadowClones(x, y) {
            const clones = [];
            for(let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                clones.push({
                    x: x + Math.cos(angle) * 25,
                    y: y + Math.sin(angle) * 25,
                    t: 0, life: 600 + Math.random() * 300,
                    r: player.r * 0.8,
                    opacity: 0.7
                });
            }
            return clones;
        }

        function newRobsanVoidRift(x, y) {
            return {
                x, y, t: 0, life: 1000,
                width: 3, maxWidth: 15,
                height: 40, color: 'rgba(0, 0, 0,'
            };
        }

        function newXDrakeNatureSpirits(x, y) {
            const spirits = [];
            for(let i = 0; i < 6; i++) {
                const angle = Math.random() * Math.PI * 2;
                spirits.push({
                    x: x + Math.cos(angle) * 20,
                    y: y + Math.sin(angle) * 20,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    t: 0, life: 800 + Math.random() * 400,
                    r: 2 + Math.random() * 3,
                    color: 'rgba(34, 197, 94,'
                });
            }
            return spirits;
        }

        function newXDrakeTerraform(x, y, dir) {
            const formations = [];
            for(let i = 0; i < 4; i++) {
                formations.push({
                    x: x + Math.cos(dir + i * 0.5) * (20 + i * 15),
                    y: y + Math.sin(dir + i * 0.5) * (20 + i * 15),
                    t: 0, life: 600 + i * 200,
                    height: 5 + i * 3,
                    color: 'rgba(109, 75, 46,'
                });
            }
            return formations;
        }

        function newGojoInfinityBarrier(x, y) {
            const barriers = [];
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                barriers.push({
                    x: x + Math.cos(angle) * 30,
                    y: y + Math.sin(angle) * 30,
                    angle: angle,
                    t: 0, life: 1200,
                    length: 20,
                    color: 'rgba(99, 102, 241,'
                });
            }
            return barriers;
        }

        function newGojoDomainExpansion(x, y) {
            return {
                x, y, t: 0, life: 2000,
                initialRadius: 10, maxRadius: 150,
                intensity: 1, color: 'rgba(99, 102, 241,'
            };
        }

        function newEddieSymbioteSpikes(x, y) {
            const spikes = [];
            for(let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                spikes.push({
                    x: x + Math.cos(angle) * 15,
                    y: y + Math.sin(angle) * 15,
                    dir: angle,
                    t: 0, life: 400 + Math.random() * 300,
                    length: 15 + Math.random() * 10,
                    color: 'rgba(0, 0, 0,'
                });
            }
            return spikes;
        }

        function newEddieVenomDrops(x, y) {
            const drops = [];
            for(let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                drops.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y + (Math.random() - 0.5) * 40,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    t: 0, life: 800 + Math.random() * 400,
                    r: 2 + Math.random() * 3,
                    color: 'rgba(100, 0, 150,'
                });
            }
            return drops;
        }

        function newZeusThunderClouds(x, y) {
            const clouds = [];
            for(let i = 0; i < 3; i++) {
                clouds.push({
                    x: x + (Math.random() - 0.5) * 100,
                    y: y - 30 - i * 20,
                    t: 0, life: 1500 + Math.random() * 500,
                    r: 15 + Math.random() * 10,
                    opacity: 0.6,
                    color: 'rgba(75, 85, 99,'
                });
            }
            return clouds;
        }

        function newZeusLightningBolts(x, y) {
            const bolts = [];
            for(let i = 0; i < 5; i++) {
                const segments = [];
                let currentX = x;
                let currentY = y - 50;

                for(let j = 0; j < 8; j++) {
                    const nextX = currentX + (Math.random() - 0.5) * 20;
                    const nextY = currentY + 15;
                    segments.push({x: currentX, y: currentY, x2: nextX, y2: nextY});
                    currentX = nextX;
                    currentY = nextY;
                }

                bolts.push({
                    segments: segments,
                    t: 0, life: 200 + Math.random() * 200,
                    thickness: 2 + Math.random() * 3,
                    color: 'rgba(255, 255, 255,'
                });
            }
            return bolts;
        }

        function newHudsonImpactBurst(x, y, dir) {
            const trails = [];
            for(let i = 0; i < 12; i++) {
                const angle = dir + (Math.random() - 0.5) * 0.8;
                const phase = Math.random() > 0.5 ? 'left' : 'right';
                const color = phase === 'left' ?
                    getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-pink') :
                    getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-blue');

                trails.push({
                    x: x + Math.cos(angle) * (5 + Math.random() * 15),
                    y: y + Math.sin(angle) * (5 + Math.random() * 15),
                    life: 400, t: 0,
                    width: 12,
                    color: color,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3
                });
            }
            return trails;
        }

        function newRobsanGroundRupture(x, y, dir) {
            return {
                x, y,
                dir,
                t: 0, life: 500,
                length: 10 + Math.random() * 20,
                width: 2 + Math.random() * 3,
                color: 'rgba(20, 0, 40,'
            };
        }

        function newRobsanEclipseWisp(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.1 + Math.random() * 0.5;
            const life = 300 + Math.random() * 200;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(30, 0, 50,' };
        }

        function newRobsanVoidPuff(x, y, type) {
            const life = 200 + Math.random() * 100;
            const r = player.r * (0.5 + Math.random() * 0.3);
            return { x, y, t: 0, life, r, type, color: 'rgba(0, 0, 0,' };
        }

        function newXDrakeGroundCrack(x, y) {
            return {
                x, y,
                t: 0, life: 800 + Math.random() * 200,
                size: 15 + Math.random() * 10,
                color: 'rgba(5, 150, 105,'
            };
        }

        function newXDrakeFootworkLeaf(x, y, dir) {
            const angle = dir + (Math.random() * 0.8 - 0.4);
            const speed = 1 + Math.random() * 2;
            const life = 250 + Math.random() * 150;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 2, color: 'rgba(16, 185, 129,' };
        }

        function newXDrakeAncientApexGroundBurst(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 3;
            const life = 400 + Math.random() * 200;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 3 + Math.random() * 4, color: 'rgba(100, 200, 100,' };
        }

        function newGojoRedExplosion(x, y) {
            return {
                x, y,
                t: 0, life: 300,
                radius: player.r * 1.5,
                color: 'rgba(229, 62, 62,'
            };
        }

        function newGojoLapseBluePullParticle(startX, startY, endX, endY) {
            const dir = Math.atan2(endY - startY, endX - startX);
            const speed = 2 + Math.random() * 3;
            const life = 200 + Math.random() * 100;
            return {
                x: startX, y: startY,
                vx: Math.cos(dir) * speed * (0.8 + Math.random() * 0.4),
                vy: Math.sin(dir) * speed * (0.8 + Math.random() * 0.4),
                life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(49, 130, 206,'
            };
        }

        function newGojoPurpleArc(x, y, initialAngle) {
            return {
                x, y,
                initialAngle,
                t: 0, life: 600 + Math.random() * 200,
                radius: 10 + Math.random() * 20,
                color: 'rgba(128, 90, 213,'
            };
        }

        function newEddieWeAreRipple(x, y) {
            return {
                x, y,
                t: 0, life: 700 + Math.random() * 300,
                initialRadius: player.r * 1.5,
                maxRadius: player.r * 3,
                color: 'rgba(20, 20, 20,'
            };
        }

        function newEddieVenomBallSwirlParticle(x, y, dir) {
            const angleOffset = (Math.random() - 0.5) * Math.PI / 4;
            const speed = 0.5 + Math.random() * 1.5;
            const life = 150 + Math.random() * 100;
            return {
                x, y,
                vx: Math.cos(dir + angleOffset) * speed,
                vy: Math.sin(dir + angleOffset) * speed,
                life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(100, 0, 150,'
            };
        }

        function newEddieTeleportFlicker(x, y) {
            return {
                x, y,
                t: 0, life: 100,
                radius: player.r * 1.5,
                color: 'rgba(0, 0, 0,'
            };
        }


        function shockwave(x,y,r0, style='hudson'){

            let strokeColor1 = 'rgba(96,165,250,';
            let strokeColor2 = 'rgba(244,114,182,';

            if (style === 'robsan') {
                strokeColor1 = 'var(--robsan-dark-primary)';
                strokeColor2 = 'var(--robsan-dark-secondary)';
            } else if (style === 'eclipse') {
                strokeColor1 = 'var(--eclipse-line-color)';
                strokeColor2 = 'var(--eclipse-line-glow)';
            } else if (style === 'xdrake-supernova') {
                strokeColor1 = 'var(--xdrake-green-primary)';
                strokeColor2 = 'var(--xdrake-green-secondary)';
            } else if (style === 'xdrake-footwork') {
                strokeColor1 = 'var(--xdrake-footwork-color)';
                strokeColor2 = 'var(--xdrake-green-secondary)';
            } else if (style === 'xdrake-apex') {
                strokeColor1 = 'var(--xdrake-apex-aura-start)';
                strokeColor2 = 'var(--xdrake-apex-aura-end)';
            } else if (style === 'gojo-red') {
                strokeColor1 = 'var(--gojo-red-primary)';
                strokeColor2 = 'var(--gojo-red-secondary)';
            } else if (style === 'gojo-blue') {
                strokeColor1 = 'var(--gojo-blue-primary)';
                strokeColor2 = 'var(--gojo-blue-secondary)';
            } else if (style === 'gojo-purple') {
                strokeColor1 = 'var(--gojo-purple-primary)';
                strokeColor2 = 'var(--gojo-purple-secondary)';
            } else if (style === 'eddie-we-are') {
                strokeColor1 = 'var(--eddie-primary)';
                strokeColor2 = 'var(--eddie-secondary)';
            } else if (style === 'eddie-venom') {
                strokeColor1 = 'var(--eddie-venom-strike-trail-start)';
                strokeColor2 = 'var(--eddie-venom-strike-trail-end)';
            } else if (style === 'eddie-montage') {
                strokeColor1 = getComputedStyle(document.documentElement).getPropertyValue('--eddie-symbiote-montage-trail').trim();
                strokeColor2 = 'var(--eddie-primary)';
            } else if (style === 'zeus-lightning') {
                strokeColor1 = 'var(--zeus-lightning-trail-start)';
                strokeColor2 = 'var(--zeus-lightning-trail-end)';
            } else if (style === 'zeus-shield') {
                strokeColor1 = 'var(--zeus-primary)';
                strokeColor2 = 'var(--zeus-shield-glow)';
            } else if (style === 'zeus-olympus-pull') {
                strokeColor1 = 'var(--zeus-olympus-aura-start)';
                strokeColor2 = 'var(--zeus-secondary)';
            } else if (style === 'zeus-olympus-shot') {
                strokeColor1 = 'var(--zeus-olympus-ball-trail-start)';
                strokeColor2 = 'var(--zeus-olympus-aura-end)';
            } else if (style === 'asher') { // NEW ASHER
                strokeColor1 = 'var(--asher-primary)';
                strokeColor2 = 'var(--asher-secondary)';
            } else if (style === 'angus') { // NEW ANGUS
                strokeColor1 = 'var(--angus-primary)';
                strokeColor2 = 'var(--angus-secondary)';
            }

            const rootStyle = getComputedStyle(document.documentElement);
            if (strokeColor1.startsWith('var(')) {
                strokeColor1 = rootStyle.getPropertyValue(strokeColor1.match(/var\(([^)]+)\)/)[1]).trim();
            }
            if (strokeColor2.startsWith('var(')) {
                strokeColor2 = rootStyle.getPropertyValue(strokeColor2.match(/var\(([^)]+)\)/)[1]).trim();
            }
            vfx.shockwaves.push({x,y,r:r0, t:0, life:420, color1:strokeColor1, color2:strokeColor2});
        }
        function impactWave(x,y,r0){ vfx.shockwaves.push({x,y,r:r0, t:0, life:260, color1:'rgba(96,165,250,', color2:'rgba(244,114,182,'}); }
        function newLineBurst(x,y,dir){
            const spread=(Math.random()*0.6-0.3);
            const a=dir+spread; return {x,y,a,len:40+Math.random()*80, t:0, life:300+Math.random()*300};
        }

        // AI Logic Functions
        function updateAI(dt) {
            if (!aiEnabled) return;

            const now = performance.now();

            // AI thinks every thinkInterval milliseconds (not super fast)
            if (now - aiPlayer.lastThinkTime > aiPlayer.thinkInterval) {
                aiPlayer.lastThinkTime = now;
                aiThink();
            }

            // Update AI movement
            aiMove(dt);

            // Update AI shooting
            aiShoot(dt);

            // Apply physics to AI
            aiPlayer.vx *= aiPlayer.drag;
            aiPlayer.vy *= aiPlayer.drag;
            aiPlayer.x += aiPlayer.vx;
            aiPlayer.y += aiPlayer.vy;

            // Keep AI in bounds
            aiPlayer.x = Math.max(aiPlayer.r, Math.min(W - aiPlayer.r, aiPlayer.x));
            aiPlayer.y = Math.max(aiPlayer.r, Math.min(H - aiPlayer.r, aiPlayer.y));

            // Handle AI stunning
            if (aiPlayer.isStunned && now > aiPlayer.stunEndTime) {
                aiPlayer.isStunned = false;
            }

            // Check AI-ball collision and pickup attempts - BUT ALLOW AGGRESSIVE SHOOTING!
            const dx = ball.x - aiPlayer.x;
            const dy = ball.y - aiPlayer.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const playerDistToBall = Math.sqrt((ball.x - player.x)**2 + (ball.y - player.y)**2);

            // AI can grab ball from distance when in shoot mode - NO COLLISION REQUIRED!
            if (aiPlayer.state === 'shoot' && !aiPlayer.hasBall && !player.hasBall && !aiPlayer.isStunned) {
                // Prevent AI from grabbing the ball while Saja-Jin's Hypnotic Shot is active or locked
                const aiHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                // Prevent AI from grabbing ball during Big Back Power
                const korbinBallProtected = ball.korbinBigBackProtected && player.korbinBigBackPowerActive;
                if (!aiHypnoticLocked && !korbinBallProtected && dist < 120) { // Much larger range for shooting!
                    aiPlayer.hasBall = true;
                    ball.vx = 0;
                    ball.vy = 0;
                    showNotification('AI grabs ball for shot!', 'warning');
                }
            }
            // Regular collision-based pickup for non-shooting situations
            else if (dist < aiPlayer.r + ball.r + 6 && !aiPlayer.isStunned) {
                // Prevent AI from grabbing the ball while Saja-Jin's Hypnotic Shot is active or locked
                const aiHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                // Prevent AI from grabbing ball during Big Back Power
                const korbinBallProtected = ball.korbinBigBackProtected && player.korbinBigBackPowerActive;
                if (aiHypnoticLocked || korbinBallProtected) return;

                if (!aiPlayer.hasBall && !player.hasBall) {
                    // Check if player is close to ball - give player priority (but not for shooting!)
                    if (playerDistToBall < player.r + ball.r + 25) {
                        // Player is close - don't let AI grab it, wait for player action
                        return; // Exit early, don't pick up ball
                    }

                    // Check if player is dribbling nearby
                    const playerDist = Math.sqrt((player.x - aiPlayer.x)**2 + (player.y - aiPlayer.y)**2);
                    if (player.isDribbling && playerDist < 50) {
                        // AI tried to pick up ball while player is dribbling - stun AI!
                        aiPlayer.isStunned = true;
                        aiPlayer.stunEndTime = now + 500; // 0.5 second stun
                        aiPlayer.lastBallPickupAttempt = now;
                        showNotification('ai got stunned for trying to steal while youre dribbling lol', 'success');
                    } else {
                        // Normal AI ball pickup - but only if player isn't close
                        aiPlayer.hasBall = true;
                        ball.vx = 0;
                        ball.vy = 0;
                    }
                }
            }

            // Keep ball with AI if AI has it - position ball in FRONT of AI
            if (aiPlayer.hasBall) {
                // Calculate direction AI is facing based on movement or toward goal
                let faceDir = 0; // Default facing left (toward goal)
                if (Math.abs(aiPlayer.vx) > 0.1 || Math.abs(aiPlayer.vy) > 0.1) {
                    // AI is moving, face movement direction
                    faceDir = Math.atan2(aiPlayer.vy, aiPlayer.vx);
                } else {
                    // AI not moving, face toward goal (left)
                    const goalX = margin;
                    const goalY = H/2;
                    faceDir = Math.atan2(goalY - aiPlayer.y, goalX - aiPlayer.x);
                }

                // Position ball in front of AI based on facing direction
                ball.x = aiPlayer.x + Math.cos(faceDir) * (aiPlayer.r + ball.r + 3);
                ball.y = aiPlayer.y + Math.sin(faceDir) * (aiPlayer.r + ball.r + 3);
                ball.vx = aiPlayer.vx;
                ball.vy = aiPlayer.vy;
            }
        }

        function aiThink() {
            // Don't think while stunned
            if (aiPlayer.isStunned) return;

            const now = performance.now(); // Fix: Define the now variable
            const distToBall = Math.sqrt((ball.x - aiPlayer.x)**2 + (ball.y - aiPlayer.y)**2);
            const distToPlayer = Math.sqrt((player.x - aiPlayer.x)**2 + (player.y - aiPlayer.y)**2);
            const goalX = margin; // Left goal (player's goal)
            const goalY = H/2;

            // Smart AI decision making - SUPER AGGRESSIVE SHOOTING!
            const distToGoal = Math.sqrt((goalX - aiPlayer.x)**2 + (goalY - aiPlayer.y)**2);
            const timeSinceLastShot = now - (aiPlayer.lastShotTime || 0);
            
            // AI shoots WAY more often - every 800ms and from much farther distances!
            const shouldShootAggressively = timeSinceLastShot > 800 && distToGoal < 400;
            
            if (aiPlayer.hasBall) {
                // If AI has ball, ALWAYS shoot immediately - no positioning needed
                aiPlayer.state = 'shoot';
            } else if (shouldShootAggressively && !player.hasBall && Math.random() < 0.7) {
                // SUPER AGGRESSIVE: AI tries to shoot even without ball if it's close enough!
                aiPlayer.state = 'shoot';
                // Try to grab ball aggressively for shooting
                if (distToBall < 80) {
                    const shootHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                    const korbinBallProtected = ball.korbinBigBackProtected && player.korbinBigBackPowerActive;
                    if (!shootHypnoticLocked && !korbinBallProtected) {
                        aiPlayer.hasBall = true;
                        ball.vx = 0;
                        ball.vy = 0;
                    }
                }
            } else if (player.hasBall) {
                // Player has ball - try to steal it or defend goal
                const distToPlayer = Math.sqrt((player.x - aiPlayer.x)**2 + (player.y - aiPlayer.y)**2);

                if (distToPlayer < 50 && Math.random() < 0.8) { // Increased steal range and probability
                    // Close to player - try to steal ball! (But respect 1.0s cooldown after being stolen from)
                    const timeSinceStolen = now - (aiPlayer.lastStolenFromTime || 0);
                    // Can't steal during Big Back Power
                    const korbinBallProtected = ball.korbinBigBackProtected && player.korbinBigBackPowerActive;
                    if (timeSinceStolen > 1000 && !korbinBallProtected) { // Reduced cooldown to 1 second
                        player.hasBall = false;
                        aiPlayer.hasBall = true;
                        ball.vx = 0;
                        ball.vy = 0;
                        aiPlayer.lastStolenFromTime = now;
                        showNotification('AI stole the ball!', 'warning');
                        // Immediately switch to shooting
                        aiPlayer.state = 'shoot';
                    }
                } else if (distToPlayer > 70) {
                    // Too far - chase player more aggressively to get close enough to steal
                    aiPlayer.state = 'chase';
                    aiPlayer.targetX = player.x;
                    aiPlayer.targetY = player.y;
                } else {
                    // Defend goal while moving closer
                    aiPlayer.state = 'defend';
                    aiPlayer.targetX = aiPlayer.defensiveX;
                    aiPlayer.targetY = player.y; // Mirror player's Y position
                }
            } else {
                // Neither has ball - chase it more aggressively OR try to shoot!
                if (shouldShootAggressively && distToBall < 60 && Math.random() < 0.5) {
                    // Try to grab ball and shoot immediately!
                    aiPlayer.state = 'shoot';
                } else if (distToBall < distToPlayer * 1.5 || Math.random() < 0.6) { // More aggressive ball chasing
                    aiPlayer.state = 'chase';
                    aiPlayer.targetX = ball.x;
                    aiPlayer.targetY = ball.y;
                } else {
                    // Sometimes position defensively instead of always chasing
                    aiPlayer.state = 'defend';
                    aiPlayer.targetX = aiPlayer.defensiveX;
                    aiPlayer.targetY = ball.y;
                }
            }
        }

        function aiMove(dt) {
            if (aiPlayer.state === 'shoot' || aiPlayer.isStunned) return; // Don't move while shooting or stunned

            const dx = aiPlayer.targetX - aiPlayer.x;
            const dy = aiPlayer.targetY - aiPlayer.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist > 5) {
                const moveX = (dx / dist) * aiPlayer.accel;
                const moveY = (dy / dist) * aiPlayer.accel;

                aiPlayer.vx += moveX;
                aiPlayer.vy += moveY;

                // Limit speed
                const speed = Math.sqrt(aiPlayer.vx*aiPlayer.vx + aiPlayer.vy*aiPlayer.vy);
                if (speed > aiPlayer.maxSpd) {
                    aiPlayer.vx = (aiPlayer.vx / speed) * aiPlayer.maxSpd;
                    aiPlayer.vy = (aiPlayer.vy / speed) * aiPlayer.maxSpd;
                }
            }
        }

        function aiShoot(dt) {
            const now = performance.now();

            // SUPER AGGRESSIVE AI SHOOTING - shoots way more often!
            if (aiPlayer.state === 'shoot') {

                // If AI doesn't have ball but is trying to shoot, try to grab it VERY aggressively
                if (!aiPlayer.hasBall && !player.hasBall) {
                    // Respect Hypnotic Shot: don't allow AI to claim the ball while it's being commanded or locked
                    const shootHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                    const korbinBallProtected = ball.korbinBigBackProtected && player.korbinBigBackPowerActive;
                    if (!shootHypnoticLocked && !korbinBallProtected) {
                        const ballDist = Math.sqrt((ball.x - aiPlayer.x)**2 + (ball.y - aiPlayer.y)**2);
                        if (ballDist < 120) { // MUCH larger pickup range for aggressive shooting
                            aiPlayer.hasBall = true;
                            ball.vx = 0;
                            ball.vy = 0;
                        }
                    }
                }

                // AI can also shoot without having ball if close enough - SUPER AGGRESSIVE!
                const ballDist = Math.sqrt((ball.x - aiPlayer.x)**2 + (ball.y - aiPlayer.y)**2);
                const canShootWithoutBall = ballDist < 50 && !player.hasBall;
                
                if (!aiPlayer.shootCharging && (aiPlayer.hasBall || canShootWithoutBall)) {
                    // Start charging shot
                    aiPlayer.shootCharging = true;
                    aiPlayer.shootStartTime = now;
                    aiPlayer.shootPower = 0;
                } else if (aiPlayer.shootCharging) {
                    // Charge shot (but not too long - AI is smart, not perfect)
                    const chargeTime = now - aiPlayer.shootStartTime;

                    // AI shoots INSTANTLY - almost no charge time needed!
                    const maxChargeTime = 5 + Math.random() * 10; // 5-15ms maximum - INSTANT shooting!

                    aiPlayer.shootPower = Math.min(chargeTime / maxChargeTime, 0.98 + aiPlayer.skill * 0.02);

                    // Shoot immediately when conditions are met - SUPER fast!
                    if (chargeTime > 3 || aiPlayer.shootPower > 0.001) { // Shoot after just 3ms!
                        // Calculate smart shot direction
                        const goalX = margin;
                        const goalY = H/2;
                        let targetX = goalX;
                        let targetY = goalY;

                        // Better accuracy for aggressive shooting
                        const accuracy = aiPlayer.skill * 90; // Even better base accuracy
                        const accuracyVariation = 50 - accuracy;
                        targetX += (Math.random() - 0.5) * accuracyVariation;
                        targetY += (Math.random() - 0.5) * accuracyVariation * 0.5; // Less vertical variation

                        const shotDir = Math.atan2(targetY - aiPlayer.y, targetX - aiPlayer.x);
                        const power = 18 + aiPlayer.shootPower * 25; // Even more power!

                        // If shooting without ball, kick the ball from its current position
                        if (!aiPlayer.hasBall && canShootWithoutBall) {
                            // Add velocity to the ball based on shot direction and power
                            ball.vx += Math.cos(shotDir) * power * 0.8;
                            ball.vy += Math.sin(shotDir) * power * 0.8;
                        } else {
                            // Normal shooting with ball possession
                            ball.vx = Math.cos(shotDir) * power;
                            ball.vy = Math.sin(shotDir) * power;
                        }

                        aiPlayer.hasBall = false;
                        aiPlayer.shootCharging = false;
                        aiPlayer.lastShotTime = now;
                        aiPlayer.state = 'chase'; // Go back to chasing after shooting
                       
                        // Add visual feedback when AI shoots
                        showNotification('AI shoots aggressively!', 'warning');
                    }
                }
            }

            // Reset shooting state if not in shoot mode
            if (aiPlayer.state !== 'shoot') {
                aiPlayer.shootCharging = false;
                aiPlayer.shootPower = 0;
            }
        }

        function updateVFX(dt){
            const now = performance.now();

            vfx.trail = vfx.trail.filter(t=>performance.now()<t.end);
            if(vfx.trail.length){
                if(!ball._trail) ball._trail=[];
                ball._trail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                while(ball._trail.length>40) ball._trail.pop();
            } else {
                ball._trail = [];
            }


            vfx.shadowTrails = vfx.shadowTrails.filter(t=>performance.now()<t.end);
            if(vfx.shadowTrails.length){
                if(!ball._shadowTrail) ball._shadowTrail=[];
                ball._shadowTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                while(ball._shadowTrail.length>40) ball._shadowTrail.pop();
            } else {
                ball._shadowTrail = [];
            }


            vfx.voidTrails = vfx.voidTrails.filter(t=>performance.now()<t.end);
            if(player.dashing && currentStyle === 'robsan'){
                if(!player._voidDashTrail) player._voidDashTrail=[];
                player._voidDashTrail.unshift({x:player.x, y:player.y, time:performance.now()});
                while(player._voidDashTrail.length>20) player._voidDashTrail.pop();
            } else {
                player._voidDashTrail = [];
            }


            vfx.xdrakeSupernovaTrails = vfx.xdrakeSupernovaTrails.filter(t=>performance.now()<t.end);
            if(player.xdrakeSupernovaDashing && currentStyle === 'xdrake'){
                if(!player._xdrakeSupernovaTrail) player._xdrakeSupernovaTrail=[];
                player._xdrakeSupernovaTrail.unshift({x:player.x, y:player.y, time:performance.now()});
                while(player._xdrakeSupernovaTrail.length>25) player._xdrakeSupernovaTrail.pop();
            } else {
                player._xdrakeSupernovaTrail = [];
            }


            vfx.gojoRedTrail = vfx.gojoRedTrail.filter(t=>performance.now()<t.end);
            if(player.gojoRedActive && ball.vx !== 0 && ball.vy !== 0){
                if(!ball._gojoRedTrail) ball._gojoRedTrail=[];
                ball._gojoRedTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                while(ball._gojoRedTrail.length>40) ball._gojoRedTrail.pop();
            } else {
                ball._gojoRedTrail = [];
            }

            // NEW DIDDY OIL TRAIL SYSTEM
            if(ball.hasOilTrail && now < ball.oilTrailEndTime){
                if(!ball._diddyOilTrail) ball._diddyOilTrail=[];
                ball._diddyOilTrail.unshift({x:ball.x, y:ball.y, time:now});
                while(ball._diddyOilTrail.length>35) ball._diddyOilTrail.pop();

                // Create smaller oil droplets along the trail
                if(Math.random() < 0.4){
                    vfx.diddySlickTrail.push({
                        x: ball.x + (Math.random() - 0.5) * 10,
                        y: ball.y + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 1,
                        vy: (Math.random() - 0.5) * 1,
                        life: 600 + Math.random() * 300,
                        t: 0,
                        r: 1 + Math.random() * 2
                    });
                }
            } else {
                ball._diddyOilTrail = [];
                ball.hasOilTrail = false;
            }

            // SAJA-JIN GHOST TRAIL SYSTEM
            if(ball.hasGhostTrail && now < ball.ghostTrailEndTime){
                if(!ball._sajaJinGhostTrail) ball._sajaJinGhostTrail=[];
                ball._sajaJinGhostTrail.unshift({x:ball.x, y:ball.y, time:now});
                while(ball._sajaJinGhostTrail.length>50) ball._sajaJinGhostTrail.pop();

                // Create ghostly wisps along the trail
                if(Math.random() < 0.6){
                    vfx.sajaJinGhostTrail.push({
                        x: ball.x + (Math.random() - 0.5) * 20,
                        y: ball.y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 800 + Math.random() * 400,
                        t: 0,
                        r: 2 + Math.random() * 4,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            } else {
                ball._sajaJinGhostTrail = [];
                ball.hasGhostTrail = false;
            }

            // Leonardo Dash Trail
            vfx.leonardoDashTrail = vfx.leonardoDashTrail.filter(t => performance.now() < t.end);
            if (player.leonardoDashing && currentStyle === 'leonardo') {
                if (!player._leonardoDashTrail) player._leonardoDashTrail = [];
                player._leonardoDashTrail.unshift({ x: player.x, y: player.y, time: performance.now() });
                while (player._leonardoDashTrail.length > 20) player._leonardoDashTrail.pop();
            } else {
                player._leonardoDashTrail = [];
            }


            vfx.gojoPurpleTrail = vfx.gojoPurpleTrail.filter(t=>performance.now()<t.end);
            if (vfx.gojoPurpleTrail.length > 0 && ball.vx !== 0 && ball.vy !== 0) {
                if (!ball._gojoPurpleTrail) ball._gojoPurpleTrail = [];
                ball._gojoPurpleTrail.unshift({x: ball.x, y: ball.y, time: performance.now()});
                while(ball._gojoPurpleTrail.length > 50) ball._gojoPurpleTrail.pop();
            } else {
                ball._gojoPurpleTrail = [];
            }


            vfx.eddieVenomShotTrail = vfx.eddieVenomShotTrail.filter(t=>performance.now()<t.end);
            if (vfx.eddieVenomShotTrail.length > 0 && ball.vx !== 0 && ball.vy !== 0) {
                if (!ball._eddieVenomShotTrail) ball._eddieVenomShotTrail = [];
                ball._eddieVenomShotTrail.unshift({x: ball.x, y: ball.y, time: performance.now()});
                while(ball._eddieVenomShotTrail.length > 40) ball._eddieVenomShotTrail.pop();
            } else {
                ball._eddieVenomShotTrail = [];
            }

            vfx.zeusLightningTrail = vfx.zeusLightningTrail.filter(t=>performance.now()<t.end);
            if(player.zeusLightningActive && ball.vx !== 0 && ball.vy !== 0){
                if(!ball._zeusLightningTrail) ball._zeusLightningTrail=[];
                ball._zeusLightningTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                while(ball._zeusLightningTrail.length>30) ball._zeusLightningTrail.pop();
            } else {
                ball._zeusLightningTrail = [];
            }

            vfx.zeusOlympusFuryBallTrail = vfx.zeusOlympusFuryBallTrail.filter(t=>performance.now()<t.end);
            if(vfx.zeusOlympusFuryBallTrail.length > 0 && ball.vx !== 0 && ball.vy !== 0){
                if(!ball._zeusOlympusFuryBallTrail) ball._zeusOlympusFuryBallTrail=[];
                ball._zeusOlympusFuryBallTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                while(ball._zeusOlympusFuryBallTrail.length>50) ball._zeusOlympusFuryBallTrail.pop();
            } else {
                ball._zeusOlympusFuryBallTrail = [];
            }

            // Asher Star Trail
            vfx.asherStarTrail = vfx.asherStarTrail.filter(t => performance.now() < t.end);
            if (ball.isHoming) {
                if (!ball._asherStarTrail) ball._asherStarTrail = [];
                ball._asherStarTrail.unshift({ x: ball.x, y: ball.y, time: performance.now() });
                while (ball._asherStarTrail.length > 40) ball._asherStarTrail.pop();
            } else {
                ball._asherStarTrail = [];
            }


            vfx.eddieSymbioteMontageAimAura = vfx.eddieSymbioteMontageAimAura.filter(a => performance.now() < a.end);
            vfx.blackPuddles = vfx.blackPuddles.filter(p => (p.t += dt) < p.life);


            vfx.sparks = vfx.sparks.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.sparks){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.98; p.vy*=0.98; }

            vfx.robsanParticles = vfx.robsanParticles.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.robsanParticles){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.95; p.vy*=0.95; }

            vfx.xdrakeFootworkDust = vfx.xdrakeFootworkDust.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.xdrakeFootworkDust){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.92; p.vy*=0.92; }


            vfx.gojoBlueOrbitParticles = vfx.gojoBlueOrbitParticles.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.gojoBlueOrbitParticles){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }


            for(const p of vfx.eddieWeAreParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life; const a = f*0.8;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9;

            }
            vfx.eddieWeAreParticles = vfx.eddieWeAreParticles.filter(p=> p.t < p.life);

            vfx.zeusLightningParticles = vfx.zeusLightningParticles.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.zeusLightningParticles){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.95; p.vy*=0.95; }

            vfx.zeusHeavenlyShieldWaves = vfx.zeusHeavenlyShieldWaves.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.zeusHeavenlyShieldWaves){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }

            vfx.zeusLightningChargeEffect = vfx.zeusLightningChargeEffect.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.zeusLightningChargeEffect){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }

            vfx.zeusOlympusFuryPullLines = vfx.zeusOlympusFuryPullLines.filter(l => (l.t += dt) < l.life);

            vfx.zeusGroundScorches = vfx.zeusGroundScorches.filter(s => (s.t += dt) < s.life);

            // Asher VFX update
            vfx.asherTeleportBurst = vfx.asherTeleportBurst.filter(p => (p.t += dt) < p.life);
            for (const p of vfx.asherTeleportBurst) { p.x += p.vx * (dt / 16); p.y += p.vy * (dt / 16); p.vx *= 0.96; p.vy *= 0.96; }
            vfx.asherArrivalGlimmer = vfx.asherArrivalGlimmer.filter(p => (p.t += dt) < p.life);
            for (const p of vfx.asherArrivalGlimmer) { p.x += p.vx * (dt / 16); p.y += p.vy * (dt / 16); p.vx *= 0.92; p.vy *= 0.92; }

            // 67 KID VFX Updates
            vfx.sixtySevenKidTextClones = vfx.sixtySevenKidTextClones.filter(t => (t.t += dt) < t.life);
            vfx.sixtySevenKidMayhemAura = vfx.sixtySevenKidMayhemAura.filter(a => (a.t += dt) < a.life);
            vfx.sixtySevenKidBlackoutOverlay = vfx.sixtySevenKidBlackoutOverlay.filter(o => (o.t += dt) < o.life);


            vfx.robsanChargeAura = vfx.robsanChargeAura.filter(a=> (a.t+=dt) < a.life);

            vfx.eclipseAura = vfx.eclipseAura.filter(a=> (a.t+=dt) < a.life);

            vfx.eclipseLines = vfx.eclipseLines.filter(l=> (l.t+=dt) < l.life);

            vfx.xdrakeApexAura = vfx.xdrakeApexAura.filter(a=> (a.t+=dt) < a.life);

            vfx.gojoPurpleCombineVFX = vfx.gojoPurpleCombineVFX.filter(v=> (v.t+=dt) < v.life);


            for(const aura of vfx.eddieWeAreAura){
                aura.t += dt;

            }
            vfx.eddieWeAreAura = vfx.eddieWeAreAura.filter(a => a.t < a.life);

            vfx.zeusHeavenlyShieldAura = vfx.zeusHeavenlyShieldAura.filter(a => (a.t+=dt) < a.life);

            vfx.zeusOlympusFuryAura = vfx.zeusOlympusFuryAura.filter(a => (a.t+=dt) < a.life);

            for(const line of vfx.eddieVenomTendrils){
                line.t += dt;

                line.endX = ball.x;
                line.endY = ball.y;
            }
            vfx.eddieVenomTendrils = vfx.eddieVenomTendrils.filter(l => l.t < l.life);

            vfx.eddieVenomBallSwirl = vfx.eddieVenomBallSwirl.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.eddieVenomBallSwirl){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }

            vfx.robsanGroundRupture = vfx.robsanGroundRupture.filter(r => (r.t += dt) < r.life);
            vfx.robsanEclipseWisps = vfx.robsanEclipseWisps.filter(w => (w.t += dt) < w.life);
            for(const wisp of vfx.robsanEclipseWisps){ wisp.x+=wisp.vx*(dt/16); wisp.y+=wisp.vy*(dt/16); wisp.vx*=0.95; wisp.vy*=0.95; }
            vfx.robsanVoidPuffs = vfx.robsanVoidPuffs.filter(p => (p.t += dt) < p.life);
            vfx.xdrakeSupernovaGroundCrack = vfx.xdrakeSupernovaGroundCrack.filter(c => (c.t += dt) < c.life);
            vfx.xdrakeFootworkLeaves = vfx.xdrakeFootworkLeaves.filter(l => (l.t += dt) < l.life);
            for(const leaf of vfx.xdrakeFootworkLeaves){ leaf.x+=leaf.vx*(dt/16); leaf.y+=leaf.vy*(dt/16); leaf.vx*=0.9; leaf.vy*=0.9; }
            vfx.xdrakeAncientApexGroundBurst = vfx.xdrakeAncientApexGroundBurst.filter(b => (b.t += dt) < b.life);
            for(const b of vfx.xdrakeAncientApexGroundBurst){ b.x+=b.vx*(dt/16); b.y+=b.vy*(dt/16); b.vx*=0.9; b.vy*=0.9; }
            vfx.gojoRedExplosion = vfx.gojoRedExplosion.filter(e => (e.t += dt) < e.life);
            vfx.gojoLapseBluePullEffect = vfx.gojoLapseBluePullEffect.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.gojoLapseBluePullEffect){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.85; p.vy*=0.85; }
            vfx.gojoPurpleArcs = vfx.gojoPurpleArcs.filter(a => (a.t += dt) < a.life);
            vfx.eddieWeAreRipples = vfx.eddieWeAreRipples.filter(r => (r.t += dt) < r.life);
            vfx.eddieTeleportFlicker = vfx.eddieTeleportFlicker.filter(f => (f.t += dt) < f.life);

            vfx.hudsonSpeedLines = vfx.hudsonSpeedLines.filter(line => (line.t += dt) < line.life);
            vfx.hudsonEnergyWaves = vfx.hudsonEnergyWaves.filter(wave => (wave.t += dt) < wave.life);
            vfx.hudsonEmperorDribbleTrail = vfx.hudsonEmperorDribbleTrail.filter(trail => (trail.t += dt) < trail.life);
            vfx.hudsonEmperorDribbleParticles = vfx.hudsonEmperorDribbleParticles.filter(particle => (particle.t += dt) < particle.life);
            vfx.hudsonEmperorDribbleAura = vfx.hudsonEmperorDribbleAura.filter(aura => (aura.t += dt) < aura.life);

            vfx.robsanShadowClones = vfx.robsanShadowClones.filter(clone => (clone.t += dt) < clone.life);
            vfx.robsanVoidRifts = vfx.robsanVoidRifts.filter(rift => (rift.t += dt) < rift.life);

            vfx.xdrakeNatureSpirits = vfx.xdrakeNatureSpirits.filter(spirit => (spirit.t += dt) < spirit.life);
            for(const spirit of vfx.xdrakeNatureSpirits) {
                spirit.x += spirit.vx * (dt / 16);
                spirit.y += spirit.vy * (dt / 16);
                spirit.vx *= 0.98;
                spirit.vy *= 0.98;
            }
            vfx.xdrakeTerraforms = vfx.xdrakeTerraforms.filter(terra => (terra.t += dt) < terra.life);

            vfx.gojoInfinityBarriers = vfx.gojoInfinityBarriers.filter(barrier => (barrier.t += dt) < barrier.life);
            vfx.gojoDomainExpansions = vfx.gojoDomainExpansions.filter(domain => (domain.t += dt) < domain.life);

            vfx.eddieSymbioteSpikes = vfx.eddieSymbioteSpikes.filter(spike => (spike.t += dt) < spike.life);
            vfx.eddieVenomDrops = vfx.eddieVenomDrops.filter(drop => (drop.t += dt) < drop.life);
            for(const drop of vfx.eddieVenomDrops) {
                drop.x += drop.vx * (dt / 16);
                drop.y += drop.vy * (dt / 16);
                drop.vx *= 0.95;
                drop.vy *= 0.95;
            }

            vfx.zeusThunderClouds = vfx.zeusThunderClouds.filter(cloud => (cloud.t += dt) < cloud.life);
            vfx.zeusLightningBolts = vfx.zeusLightningBolts.filter(bolt => (bolt.t += dt) < bolt.life);

            vfx.energyResidue = vfx.energyResidue.filter(residue => (residue.t += dt) < residue.life);
            vfx.fieldCracks = vfx.fieldCracks.filter(crack => (crack.t += dt) < crack.life);
            vfx.shockwaveRings = vfx.shockwaveRings.filter(ring => (ring.t += dt) < ring.life);


            vfx.shockwaves = vfx.shockwaves.filter(s=> (s.t+=dt) < s.life);
            for(const s of vfx.shockwaves){
                const t = s.t/s.life; const r = s.r + t*80;
                const a = (1-t)*0.8;

                const sColor1 = getRGBA(s.color1, a);
                const sColor2 = getRGBA(s.color2, a * 0.8);

                ctx.strokeStyle=sColor1;
                ctx.lineWidth=3; ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.stroke();
                ctx.strokeStyle=sColor2;
                ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(s.x,s.y,r*1.12,0,Math.PI*2); ctx.stroke();
            }
            for(const l of vfx.lines){
                const t=l.t/l.life; const a=(1-t)*0.6;
                const x2 = l.x + Math.cos(l.a)*l.len;
                const y2 = l.y + Math.sin(l.a)*l.len;
                ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=2;
                ctx.beginPath(); ctx.moveTo(l.x,l.y); ctx.lineTo(x2,y2); ctx.stroke();
            }

            for(const a of vfx.robsanAura){
                const progress = a.t / a.life;
                const currentRadius = lerp(a.radius * 0.5, a.radius * 2, progress);
                const opacity = (1 - progress) * 0.7;

                const grd = ctx.createRadialGradient(a.x, a.y, a.radius * 0.5, a.x, a.y, currentRadius);
                grd.addColorStop(0, `rgba(49, 46, 129, ${opacity * 0.8})`);
                grd.addColorStop(0.7, `rgba(76, 29, 149, ${opacity * 0.4})`);
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(a.x, a.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            if (vfx.voidTrails.length && player._voidDashTrail && player._voidDashTrail.length > 1) {
                for(let i=0;i<player._voidDashTrail.length-1;i++){
                    const p=player._voidDashTrail[i], n=player._voidDashTrail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/(VOID_DASH_DURATION + 100), 0, 1)*0.9;
                    const w = lerp(vfx.voidTrails[0].w,2,i/player._voidDashTrail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,getRGBA(vfx.voidTrails[0].trailColorStart,a));
                    g.addColorStop(1,getRGBA(vfx.voidTrails[0].trailColorEnd,a*0.6));
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }
            }

            if (vfx.xdrakeSupernovaTrails.length && player._xdrakeSupernovaTrail && player._xdrakeSupernovaTrail.length > 1) {
                for(let i=0;i<player._xdrakeSupernovaTrail.length-1;i++){
                    const p=player._xdrakeSupernovaTrail[i], n=player._xdrakeSupernovaTrail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/(XDRAKE_SUPERNOVA_DASH_DURATION + 100), 0, 1)*0.9;
                    const w = lerp(vfx.xdrakeSupernovaTrails[0].w,2,i/player._xdrakeSupernovaTrail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorStart,a));
                    g.addColorStop(1,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorEnd,a*0.6));
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }



            }

            // LINCOLN SIMPLIFIED VFX UPDATES
            vfx.lincolnShrekTrail = vfx.lincolnShrekTrail.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.lincolnShrekTrail) {
                p.x += p.vx * (dt / 16);
                p.y += p.vy * (dt / 16);
                p.vx *= 0.95;
                p.vy *= 0.95;
            }

            vfx.lincolnShrekParticles = vfx.lincolnShrekParticles.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.lincolnShrekParticles) {
                p.x += p.vx * (dt / 16);
                p.y += p.vy * (dt / 16);
                p.vx *= 0.96;
                p.vy *= 0.96;
            }
        }

              function drawField(){
            ctx.save();
            ctx.strokeStyle='rgba(255,255,255,0.7)';
            ctx.lineWidth=3;
            roundRect(ctx, margin, margin, W-2*margin, H-2*margin, 16);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(W/2, margin); ctx.lineTo(W/2, H-margin); ctx.stroke();
            ctx.beginPath(); ctx.arc(W/2, H/2, 70, 0, Math.PI*2); ctx.stroke();
            drawGoal(margin, H/2-goalW/2, true);
            drawGoal(W-margin-goalDepth, H/2-goalW/2, false);
            ctx.restore();
        }

        function drawGoal(x,y,left){
            ctx.save();
            ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=2.5;
            ctx.strokeRect(x, y, goalDepth, goalW);
            const areaW=70, areaH=goalW+60;
            const gx = left ? margin : W-margin-areaW;
            ctx.strokeRect(gx, H/2-areaH/2, areaW, areaH);
            ctx.restore();
        }

        function drawPlayer(){
            ctx.save();

            const currentR = player.r; // Define currentR at the beginning of drawPlayer

            // Draw Zeus Ground Scorches
            for(const scorch of vfx.zeusGroundScorches){
                const progress = scorch.t / scorch.life;
                const opacity = (1 - progress) * 0.4;
                const currentRadius = scorch.r * (1 + progress * 0.5);

                const grd = ctx.createRadialGradient(scorch.x, scorch.y, 0, scorch.x, scorch.y, currentRadius);
                const rootStyle = getComputedStyle(document.documentElement);
                const startColor = rootStyle.getPropertyValue('--zeus-olympus-aura-start').trim();
                const endColor = rootStyle.getPropertyValue('--zeus-primary').trim();
                grd.addColorStop(0, getRGBA(startColor, opacity * 0.8));
                grd.addColorStop(1, getRGBA(endColor, opacity * 0.2));
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(scorch.x, scorch.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            }


            if (player.spinning && currentStyle === 'robsan') {
                const spinProgress = 1 - (player.spinTimer / ROBSAN_SPIN_DURATION);
                const auraRadius = player.r * (1 + spinProgress * 1.5);
                const auraOpacity = (1 - spinProgress) * 0.6;
                const pulseOffset = Math.sin(performance.now() * 0.02) * 2;

                const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                grd.addColorStop(0, `rgba(49, 46, 129, ${auraOpacity * 0.8})`);
                grd.addColorStop(0.5, `rgba(76, 29, 149, ${auraOpacity * 0.5})`);
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                ctx.fill();

                for (let i = 0; i < 3; i++) {
                    const offset = i * (spinProgress * 8);
                    const angle = spinProgress * Math.PI * 4 + i * (Math.PI / 6);
                    const sx = player.x + Math.cos(angle) * offset;
                    const sy = player.y + Math.sin(angle) * offset;
                    const shadowOpacity = (1 - spinProgress) * (0.3 - i * 0.1);
                    if (shadowOpacity > 0) {
                        ctx.fillStyle = `rgba(0,0,0,${shadowOpacity})`;
                        ctx.beginPath();
                        ctx.arc(sx, sy, player.r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }


            if (player.charging && currentStyle === 'robsan') {
                const chargeProgress = 1 - (player.chargeTimer / ROBSAN_CHARGE_DURATION);
                const auraRadius = player.r * (1.2 + chargeProgress * 0.8);
                const auraOpacity = chargeProgress * 0.5 + 0.2;
                const pulseOffset = Math.sin(performance.now() * 0.05) * 3;

                const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                grd.addColorStop(0, `rgba(30, 0, 50, ${auraOpacity * 0.6})`);
                grd.addColorStop(0.5, `rgba(40, 0, 60, ${auraOpacity * 0.3})`);
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const aura of vfx.eclipseAura){
                const progress = aura.t / aura.life;
                const currentAuraRadius = lerp(aura.radius * 0.5, aura.radius * 2, progress);
                const opacity = (1 - progress) * 0.6;

                const grd = ctx.createRadialGradient(aura.x, aura.y, aura.radius * 0.5, aura.x, aura.y, currentAuraRadius);
                grd.addColorStop(0, `rgba(0, 0, 0, ${opacity * 0.8})`);
                grd.addColorStop(0.7, `rgba(30, 0, 50, ${opacity * 0.4})`);
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(aura.x, aura.y, currentAuraRadius, 0, Math.PI * 2);
                ctx.fill();
            }


            if (player.xdrakeSupernovaDashing && currentStyle === 'xdrake') {
                const dashProgress = 1 - (player.xdrakeSupernovaDashTimer / XDRAKE_SUPERNOVA_DASH_DURATION);
                const auraRadius = player.r * (1.2 + dashProgress * 0.8);
                const auraOpacity = (1 - dashProgress) * 0.7;
                const pulseOffset = Math.sin(performance.now() * 0.08) * 4;

                const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                const rootStyle = getComputedStyle(document.documentElement);
                const startColor = rootStyle.getPropertyValue('--xdrake-green-primary').trim();
                const endColor = rootStyle.getPropertyValue('--xdrake-green-secondary').trim();

                grd.addColorStop(0, getRGBA(startColor, auraOpacity * 0.8));
                grd.addColorStop(0.5, getRGBA(endColor, auraOpacity * 0.5));
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                ctx.fill();
            }


            if (player.xdrakeAncientApexCharging && currentStyle === 'xdrake') {
                const now = performance.now();
                const chargeProgress = clamp((now - player.ancientApexChargeTimer) / XDRAKE_ANCIENT_APEX_CHARGE_DURATION, 0.0, 1.0);
                const auraRadius = player.r * (1.5 + chargeProgress * 1.5);
                const auraOpacity = chargeProgress * 0.6 + 0.2;
                const pulseOffset = Math.sin(now * 0.08) * 5;

                const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                const rootStyle = getComputedStyle(document.documentElement);
                const startColor = rootStyle.getPropertyValue('--xdrake-apex-aura-start').trim();
                const midColor = rootStyle.getPropertyValue('--xdrake-green-primary').trim();
                const endColor = rootStyle.getPropertyValue('--xdrake-apex-aura-end').trim();

                grd.addColorStop(0, getRGBA(startColor, auraOpacity * 0.9));
                grd.addColorStop(0.5, getRGBA(midColor, auraOpacity * 0.7));
                grd.addColorStop(1, getRGBA(endColor, auraOpacity * 0.4));
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                ctx.fill();
            }


            if (currentStyle === 'gojo' && (player.gojoRedActive || player.gojoLapseBlueActive || player.gojoPurpleActive || player.gojoRedCharging)) {
                const glowStrength = Math.sin(performance.now() * 0.01) * 0.1 + 0.3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(99, 102, 241, ${glowStrength})`;
            }


            if (currentStyle === 'eddie' && player.eddieWeAreActive) {
                const now = performance.now();
                const progress = 1 - (player.eddieWeAreEndTime - now) / EDDIE_WE_ARE_DURATION;
                const auraRadius = currentR * (1.2 + Math.sin(now * 0.02) * 0.2); // Use currentR
                const auraOpacity = 0.5 + Math.cos(now * 0.03) * 0.2;

                const grd = ctx.createRadialGradient(player.x, player.y, currentR, player.x, player.y, auraRadius);
                grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-we-are-aura').trim(), auraOpacity * 0.8));
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius, 0, Math.PI * 2); // Use auraRadius here
                ctx.fill();

                ctx.shadowBlur = 20;
                ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-we-are-glow').trim();
            }

            // Symbiote Montage aiming aura
            if (currentStyle === 'eddie' && player.eddieSymbioteMontageActive && player.eddieSymbioteMontagePhase === 'aiming') {
                for(const aura of vfx.eddieSymbioteMontageAimAura){
                    const progress = (performance.now() - aura.t) / aura.life;
                    const currentAuraRadius = lerp(player.r * 1.5, aura.radius, progress);
                    const opacity = (1 - progress) * 0.7; // Fade out

                    const grd = ctx.createRadialGradient(aura.x, aura.y, player.r, aura.x, aura.y, currentAuraRadius);
                    grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-symbiote-montage-trail').trim(), opacity * 0.8));
                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(aura.x, aura.y, currentAuraRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Zeus Lightning Bolt charge aura
            if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                const now = performance.now();
                const chargeProgress = clamp((now - player.zeusLightningChargeStartTime) / ZEUS_LIGHTNING_CHARGE_DURATION, 0.0, 1.0);
                const auraRadius = player.r * (1.2 + chargeProgress * 0.8);
                const auraOpacity = chargeProgress * 0.7;
                const pulseOffset = Math.sin(now * 0.1) * 3;

                const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                const rootStyle = getComputedStyle(document.documentElement);
                grd.addColorStop(0, getRGBA(rootStyle.getPropertyValue('--zeus-lightning-trail-start'), auraOpacity * 0.8));
                grd.addColorStop(0.5, getRGBA(rootStyle.getPropertyValue('--zeus-lightning-trail-end'), auraOpacity * 0.5));
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                ctx.fill();
            }

            // Zeus Heavenly Shield Aura
            if (currentStyle === 'zeus' && player.zeusHeavenlyShieldActive) {
                for (const aura of vfx.zeusHeavenlyShieldAura) {
                    const progress = aura.t / aura.life;
                    const currentRadius = lerp(aura.radius * 0.5, aura.radius, progress);
                    const opacity = (1 - progress) * 0.6; // Fade out slightly over time

                    const grd = ctx.createRadialGradient(aura.x, aura.y, player.r, aura.x, aura.y, currentRadius);
                    grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--zeus-shield-aura'), opacity * 0.8));
                    grd.addColorStop(0.8, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--zeus-shield-glow'), opacity * 0.4));
                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(aura.x, aura.y, currentRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Zeus Olympus Fury aiming aura
            if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming') {
                for(const aura of vfx.zeusOlympusFuryAura){
                    const progress = (performance.now() - aura.t) / aura.life;
                    const currentAuraRadius = lerp(player.r * 1.5, aura.radius, progress);
                    const opacity = (1 - progress) * 0.7; // Fade out

                    const grd = ctx.createRadialGradient(aura.x, aura.y, player.r, aura.x, aura.y, currentAuraRadius);
                    grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--zeus-olympus-aura-start'), opacity * 0.8));
                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(aura.x, aura.y, currentAuraRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }


            if(player.hasBall && currentStyle === 'hudson'){
                const grd=ctx.createRadialGradient(player.x, player.y, player.r*0.6, player.x, player.y, player.r*1.8);
                grd.addColorStop(0,'rgba(79,209,197,0.35)');
                grd.addColorStop(1,'rgba(79,209,197,0)');
                ctx.fillStyle=grd;
                ctx.beginPath(); ctx.arc(player.x, player.y, player.r*2.2, 0, Math.PI*2); ctx.fill();
            }


            let playerFillColor = '#2dd4bf';
            if (currentStyle === 'xdrake') {
                if (player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging) {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--xdrake-green-primary');
                } else {
                    playerFillColor = '#2dd4bf';
                }
            } else if (currentStyle === 'gojo') {
                playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-primary');
            } else if (currentStyle === 'eddie') {
                if (player.eddieWeAreActive || player.eddieAwakeningActive) {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-secondary'); // Black
                } else {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-primary'); // Dark grey
                }
            } else if (currentStyle === 'zeus') { // NEW: Zeus Player Color
                playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--zeus-primary');
                if (player.zeusHeavenlyShieldActive || player.zeusLightningCharging || player.zeusOlympusFuryActive) {
                    // Slight color shift when abilities are active
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--zeus-secondary');
                }
            } else if (currentStyle === 'cristiano') {
                if (player.cristianoPortugueseSpiritActive) {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--cristiano-primary'); // Red when boosted
                } else {
                    playerFillColor = '#2dd4bf'; // Default cyan
                }
            } else if (currentStyle === 'wally') {
                if (player.wallyFlashyLightningActive) {
                    playerFillColor = '#ffffff'; // White when using Flashy Lightning
                } else {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--wally-primary'); // Cyan
                }
            }

            // WALLY VISUAL EFFECTS
            if (currentStyle === 'wally') {
                // Rocket Boost trail effect
                if (player.wallyRocketBoostActive) {
                    const boostPulse = Math.sin(performance.now() * 0.02) * 0.3 + 0.7;
                    const boostRadius = player.r * (2.0 + boostPulse * 0.5);
                    const boostOpacity = boostPulse * 0.8;

                    const boostGrd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, boostRadius);
                    boostGrd.addColorStop(0, `rgba(0, 188, 212, ${boostOpacity * 0.9})`);
                    boostGrd.addColorStop(0.5, `rgba(21, 101, 192, ${boostOpacity * 0.6})`);
                    boostGrd.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = boostGrd;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, boostRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Speed Force dome effect
                if (player.wallySpeedForceActive) {
                    const domeOpacity = 0.3 + Math.sin(performance.now() * 0.008) * 0.2;
                    ctx.strokeStyle = `rgba(0, 188, 212, ${domeOpacity})`;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, WALLY_SPEED_FORCE_RANGE, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Flashy Lightning glow effect
                if (player.wallyFlashyLightningActive) {
                    const lightningPulse = Math.sin(performance.now() * 0.025) * 0.4 + 0.8;
                    const lightningRadius = player.r * (3.0 + lightningPulse * 1.0);
                    const lightningOpacity = lightningPulse * 0.9;

                    const lightningGrd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, lightningRadius);
                    lightningGrd.addColorStop(0, `rgba(255, 255, 255, ${lightningOpacity * 0.8})`);
                    lightningGrd.addColorStop(0.3, `rgba(0, 188, 212, ${lightningOpacity * 0.7})`);
                    lightningGrd.addColorStop(0.7, `rgba(129, 212, 250, ${lightningOpacity * 0.4})`);
                    lightningGrd.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = lightningGrd;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, lightningRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Add white glow effect
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                }
            }

            // EDDIE AWAKENING BLACK GLOW EFFECT
            if (currentStyle === 'eddie' && player.eddieAwakeningActive) {
                const awakePulse = Math.sin(performance.now() * 0.008) * 0.4 + 0.6;
                const awakeRadius = player.r * (2.5 + awakePulse * 0.5);
                const awakeOpacity = awakePulse * 0.7;

                const awakeGrd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, awakeRadius);
                awakeGrd.addColorStop(0, `rgba(0, 0, 0, ${awakeOpacity * 0.8})`);
                awakeGrd.addColorStop(0.4, `rgba(20, 20, 30, ${awakeOpacity * 0.6})`);
                awakeGrd.addColorStop(0.8, `rgba(40, 40, 60, ${awakeOpacity * 0.3})`);
                awakeGrd.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = awakeGrd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, awakeRadius, 0, Math.PI * 2);
                ctx.fill();

                // Add shadow effect
                ctx.shadowBlur = 25;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            }

            // CRISTIANO PORTUGUESE SPIRIT GLOW EFFECT
            if (currentStyle === 'cristiano' && player.cristianoPortugueseSpiritActive) {
                const spiritPulse = Math.sin(performance.now() * 0.012) * 0.5 + 0.7;
                const spiritRadius = player.r * (3.5 + spiritPulse * 0.8);
                const spiritOpacity = spiritPulse * 0.8;

                ctx.save();

                // Outer red aura layer
                const redAura = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, spiritRadius);
                redAura.addColorStop(0, `rgba(220, 38, 38, ${spiritOpacity * 0.6})`);
                redAura.addColorStop(0.4, `rgba(255, 50, 50, ${spiritOpacity * 0.4})`);
                redAura.addColorStop(0.7, `rgba(255, 215, 0, ${spiritOpacity * 0.3})`);
                redAura.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = redAura;
                ctx.beginPath();
                ctx.arc(player.x, player.y, spiritRadius, 0, Math.PI * 2);
                ctx.fill();

                // Inner green core layer
                const greenCore = ctx.createRadialGradient(player.x, player.y, player.r * 0.5, player.x, player.y, spiritRadius * 0.6);
                greenCore.addColorStop(0, `rgba(22, 163, 74, ${spiritOpacity * 0.7})`);
                greenCore.addColorStop(0.5, `rgba(34, 197, 94, ${spiritOpacity * 0.5})`);
                greenCore.addColorStop(1, `rgba(22, 163, 74, ${spiritOpacity * 0.2})`);
                ctx.fillStyle = greenCore;
                ctx.beginPath();
                ctx.arc(player.x, player.y, spiritRadius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // Add powerful shadow effect
                ctx.shadowBlur = 30;
                ctx.shadowColor = `rgba(255, 215, 0, ${spiritOpacity})`;

                ctx.restore();
            }

            ctx.fillStyle=playerFillColor;
            ctx.strokeStyle='rgba(0,0,0,.45)';
            ctx.lineWidth=2;
            ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.shadowBlur = 0;

            // Awakening visual effects
            if(player.awakeningActive){
                // Draw deep blue faded aura around player
                ctx.save();
                ctx.globalAlpha = 0.4;
                const auraSize = player.r * 2.5;
                const gradient = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraSize);
                gradient.addColorStop(0, 'rgba(0, 100, 200, 0.6)');
                gradient.addColorStop(0.7, 'rgba(0, 50, 150, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 100, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            const ang=Math.atan2(mouse.y-player.y, mouse.x-player.x);
            const ex=player.x+Math.cos(ang)*player.r*0.5;
            const ey=player.y+Math.sin(ang)*player.r*0.5;
            // Draw cyan glowing eyes when awakened, normal eyes otherwise
            if(player.awakeningActive){
                ctx.save();
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 10;
                ctx.fillStyle='#00FFFF';
                ctx.beginPath(); 
                ctx.arc(ex, ey, 3.5, 0, Math.PI*2); 
                ctx.fill();
                ctx.restore();
            } else {
                ctx.fillStyle='#083344'; ctx.beginPath(); ctx.arc(ex, ey, 3.5, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();


            if(player.hasBall && !player.gojoPurpleActive && !player.gojoRedCharging && !(currentStyle === 'eddie' && player.eddieSymbioteMontageActive) &&
               !player.zeusLightningCharging && !(currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming')){ // NEW ZEUS CONDITIONS
                ctx.save();
                ctx.strokeStyle='rgba(255,255,255,.8)'; ctx.setLineDash([8,6]); ctx.lineWidth=2;
                ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(ball.x, ball.y); ctx.stroke();
                ctx.restore();
            }


            if (player.gojoLapseBlueActive && player.gojoLapseBlueBall) {
                const lb = player.gojoLapseBlueBall;
                ctx.save();
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-primary');
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-secondary');
                ctx.lineWidth = 2;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(49, 130, 206, 0.7)`;
                ctx.beginPath();
                ctx.arc(lb.x, lb.y, lb.r, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }


            if (player.gojoPurpleActive) {
                ctx.save();
                ctx.shadowBlur = 20;

                if (player.gojoPurpleLeftBall) {
                    const lb = player.gojoPurpleLeftBall;
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-primary');
                    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-secondary');
                    ctx.shadowColor = `rgba(229, 62, 62, 0.7)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(lb.x, lb.y, lb.r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }

                if (player.gojoPurpleRightBall) {
                    const rb = player.gojoPurpleRightBall;
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-primary');
                    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-secondary');
                    ctx.shadowColor = `rgba(49, 130, 206, 0.7)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(rb.x, rb.y, rb.r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

      function drawBall(){

            if(vfx.trail.length && ball._trail && ball._trail.length > 1){
                for(let i=0;i<ball._trail.length-1;i++){
                    const p=ball._trail[i], n=ball._trail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/450, 0, 1)*0.8;
                    const w = lerp(14,2,i/ball._trail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,`rgba(96,165,250,${a})`);
                    g.addColorStop(1,`rgba(244,114,182,${a})`);
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }
            }

            if(vfx.shadowTrails.length && ball._shadowTrail && ball._shadowTrail.length > 1){
                for(let i=0;i<ball._shadowTrail.length-1;i++){
                    const p=ball._shadowTrail[i], n=ball._shadowTrail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/600, 0, 1)*0.9;
                    const w = lerp(20,4,i/ball._shadowTrail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,`rgba(20, 0, 40, ${a})`);
                    g.addColorStop(1,`rgba(10, 0, 20, ${a * 0.6})`);
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }
            }

            if (vfx.xdrakeApexAura.length && ball._xdrakeApexTrail && ball._xdrakeApexTrail.length > 1) {
                 for(let i = 0; i < ball._xdrakeApexTrail.length - 1; i++){
                    const p = ball._xdrakeApexTrail[i], n = ball._xdrakeApexTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / (vfx.xdrakeApexAura[0].life + 100), 0, 1) * 0.9;
                    const w = lerp(24, 6, i / ball._xdrakeApexTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    const rootStyle = getComputedStyle(document.documentElement);
                    const startColor = rootStyle.getPropertyValue('--xdrake-apex-ball-trail-start').trim();
                    const endColor = rootStyle.getPropertyValue('--xdrake-apex-ball-trail-end').trim();
                    g.addColorStop(0, getRGBA(startColor, a));
                    g.addColorStop(1, getRGBA(endColor, a * 0.7));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                 }
            }


            if (vfx.gojoRedTrail.length && ball._gojoRedTrail && ball._gojoRedTrail.length > 1) {
                for (let i = 0; i < ball._gojoRedTrail.length - 1; i++) {
                    const p = ball._gojoRedTrail[i], n = ball._gojoRedTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 500, 0, 1) * 0.9;
                    const w = lerp(vfx.gojoRedTrail[0].w, 2, i / ball._gojoRedTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.gojoRedTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.gojoRedTrail[0].colorEnd, a * 0.6));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                }
            }


            if (vfx.gojoPurpleTrail.length && ball._gojoPurpleTrail && ball._gojoPurpleTrail.length > 1) {
                for (let i = 0; i < ball._gojoPurpleTrail.length - 1; i++) {
                    const p = ball._gojoPurpleTrail[i], n = ball._gojoPurpleTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 1000, 0, 1) * 0.9;
                    const w = lerp(vfx.gojoPurpleTrail[0].w, 2, i / ball._gojoPurpleTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.gojoPurpleTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.gojoPurpleTrail[0].colorEnd, a * 0.6));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                }
            }


            if (vfx.eddieVenomShotTrail.length && ball._eddieVenomShotTrail && ball._eddieVenomShotTrail.length > 1) {
                for (let i = 0; i < ball._eddieVenomShotTrail.length - 1; i++) {
                    const p = ball._eddieVenomShotTrail[i], n = ball._eddieVenomShotTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 600, 0, 1) * 0.9;
                    const w = lerp(vfx.eddieVenomShotTrail[0].w, 2, i / ball._eddieVenomShotTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.eddieVenomShotTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.eddieVenomShotTrail[0].colorEnd, a * 0.6));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                }
            }

            // Zeus Lightning Trail
            if (vfx.zeusLightningTrail.length && ball._zeusLightningTrail && ball._zeusLightningTrail.length > 1) {
                for (let i = 0; i < ball._zeusLightningTrail.length - 1; i++) {
                    const p = ball._zeusLightningTrail[i], n = ball._zeusLightningTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 400, 0, 1) * 0.9;
                    const w = lerp(vfx.zeusLightningTrail[0].w, 2, i / ball._zeusLightningTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.zeusLightningTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.zeusLightningTrail[0].colorEnd, a * 0.8));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                }
            }

            // Zeus Olympus Fury Ball Trail
            if (vfx.zeusOlympusFuryBallTrail.length && ball._zeusOlympusFuryBallTrail && ball._zeusOlympusFuryBallTrail.length > 1) {
                for (let i = 0; i < ball._zeusOlympusFuryBallTrail.length - 1; i++) {
                    const p = ball._zeusOlympusFuryBallTrail[i], n = ball._zeusOlympusFuryBallTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 800, 0, 1) * 0.9;
                    const w = lerp(vfx.zeusOlympusFuryBallTrail[0].w, 4, i / ball._zeusOlympusFuryBallTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.zeusOlympusFuryBallTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.zeusOlympusFuryBallTrail[0].colorEnd, a * 0.7));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                }
            }


            ctx.save();
            ctx.fillStyle='rgba(0,0,0,.25)';
            ctx.beginPath(); ctx.ellipse(ball.x+1.5, ball.y+ball.r*0.85, ball.r*0.9, ball.r*0.5, 0, 0, Math.PI*2); ctx.fill();


            let ballColor = '#f8fafc';
            if (currentStyle === 'gojo') {
                if (player.gojoRedActive) {
                    ballColor = getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-primary');
                } else if (vfx.gojoPurpleTrail.length > 0) {
                    ballColor = getComputedStyle(document.documentElement).getPropertyValue('--gojo-purple-primary');
                }
            } else if (currentStyle === 'eddie' && vfx.eddieVenomShotTrail.length > 0) {
                 ballColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-secondary');
            } else if (currentStyle === 'zeus') { // NEW: Zeus Ball Color
                if (player.zeusLightningActive || vfx.zeusOlympusFuryBallTrail.length > 0) {
                    ballColor = getComputedStyle(document.documentElement).getPropertyValue('--zeus-lightning-trail-end');
                } else {
                    ballColor = '#f8fafc'; // Default white
                }
            }
            ctx.fillStyle=ballColor;

            ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle='#0f172a'; ctx.lineWidth=1.5; ctx.stroke();
            ctx.beginPath();
            for(let i=0;i<5;i++){
                const a=(-Math.PI/2)+i*(2*Math.PI/5);
                const x=ball.x+Math.cos(a)*ball.r*0.55;
                const y=ball.y+Math.sin(a)*ball.r*0.55;
                if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.closePath(); ctx.stroke();
            ctx.restore();
        }

        function drawAI(){
            if (!aiEnabled) return;

            ctx.save();

            // Draw AI player with different color to distinguish from human player
            ctx.shadowColor = 'rgba(255, 100, 100, 0.6)';
            ctx.shadowBlur = aiPlayer.shootCharging ? 15 : 8;

            // AI player color - reddish to distinguish from player
            let aiFillColor = '#ef4444'; // Red color for AI
            if (aiPlayer.shootCharging) {
                aiFillColor = '#dc2626'; // Darker red when charging
            }

            ctx.fillStyle = aiFillColor;
            ctx.strokeStyle = 'rgba(0,0,0,.45)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(aiPlayer.x, aiPlayer.y, aiPlayer.r, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Draw AI aim line when it has the ball
            if (aiPlayer.hasBall && aiPlayer.state === 'shoot') {
                const goalX = margin;
                const goalY = H/2;
                ctx.save();
                ctx.strokeStyle = 'rgba(255,100,100,.6)';
                ctx.setLineDash([8,6]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(aiPlayer.x, aiPlayer.y);
                ctx.lineTo(goalX, goalY);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        }

        function drawUI(){
            const now = performance.now();
            const rootStyle = getComputedStyle(document.documentElement);


            if(mouse.down && player.hasBall && chargeStart && !player.gojoRedCharging){
                const held=Math.min(now - chargeStart, AUTO_MS);
                const pct=held/AUTO_MS*100;
                powerFill.style.width=pct.toFixed(1)+'%';
            } else if (currentStyle === 'xdrake' && player.xdrakeAncientApexCharging) {
                const held = Math.min(now - player.ancientApexChargeTimer, XDRAKE_ANCIENT_APEX_CHARGE_DURATION);
                const pct = (held / XDRAKE_ANCIENT_APEX_CHARGE_DURATION) * 100;
                powerFill.style.width = pct.toFixed(1) + '%';
            } else if (currentStyle === 'gojo' && player.gojoRedCharging) {
                const held = Math.min(now - player.gojoRedChargeStartTime, GOJO_RED_CHARGE_DURATION);
                const pct = (held / GOJO_RED_CHARGE_DURATION) * 100;
                powerFill.style.width = pct.toFixed(1) + '%';
            } else if (currentStyle === 'eddie' && player.eddieSymbioteMontageActive && player.eddieSymbioteMontagePhase === 'aiming') {
                const held = Math.min(now - player.eddieSymbioteMontageAimStartTime, EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION);
                const pct = (held / EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION) * 100;
                powerFill.style.width = pct.toFixed(1) + '%';
            } else if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                const held = Math.min(now - player.zeusLightningChargeStartTime, ZEUS_LIGHTNING_CHARGE_DURATION);
                const pct = (held / ZEUS_LIGHTNING_CHARGE_DURATION) * 100;
                powerFill.style.width = pct.toFixed(1) + '%';
            } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming') {
                const held = Math.min(now - player.zeusOlympusFuryAimStartTime, ZEUS_OLYMPUS_FURY_AIM_DURATION);
                const pct = (held / ZEUS_OLYMPUS_FURY_AIM_DURATION) * 100;
                powerFill.style.width = pct.toFixed(1) + '%';
            }
            else {
                powerFill.style.width = '0%';
            }



            let cdLeftC = 0;
            slotC.classList.remove('ready');
            slotC.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher', 'leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');

            if (currentStyle === 'hudson') {
                cdLeftC = Math.max(0, abilityReadyAt - now);
                slotC.classList.add('hudson');
                abilityNameCEl.textContent = 'Hudson Impact';
            } else if (currentStyle === 'robsan') {
                cdLeftC = Math.max(0, shadowSpiralReadyAt - now);
                slotC.classList.add('robsan');
                abilityNameCEl.textContent = 'Shadow Spiral';
            } else if (currentStyle === 'xdrake') {
                cdLeftC = Math.max(0, supernovaReadyAt - now);
                slotC.classList.add('xdrake');
                abilityNameCEl.textContent = 'Supernova';
            } else if (currentStyle === 'gojo') {
                cdLeftC = Math.max(0, gojoRedReadyAt - now);
                slotC.classList.add('gojo');
                abilityNameCEl.textContent = 'Red';
            } else if (currentStyle === 'eddie') {
                cdLeftC = Math.max(0, eddieWeAreReadyAt - now);
                slotC.classList.add('eddie');
                abilityNameCEl.textContent = 'We Are';
            } else if (currentStyle === 'zeus') {
                cdLeftC = Math.max(0, zeusLightningReadyAt - now);
                slotC.classList.add('zeus');
                abilityNameCEl.textContent = 'Lightning Bolt';
            } else if (currentStyle === 'asher') { // NEW ASHER
                cdLeftC = Math.max(0, asherAutoGoalReadyAt - now);
                slotC.classList.add('asher');
                abilityNameCEl.textContent = 'Starfall Shot';
            } else if (currentStyle === 'leonardo') { // NEW LEONARDO
                cdLeftC = Math.max(0, leonardoFocusShotReadyAt - now);
                slotC.classList.add('leonardo');
                abilityNameCEl.textContent = 'Focus Shot';
            } else if (currentStyle === 'angus') { // NEW ANGUS
                // Special handling for Angus - no cooldown, just usage limit
                cdLeftC = 0; // Always show as ready if uses left
                slotC.classList.add('angus');
                abilityNameCEl.textContent = `Power Burst (${player.angusBurstUsesLeft}/3)`;
            } else if (currentStyle === 'diddy') { // NEW DIDDY
                cdLeftC = Math.max(0, diddyBabyOilReadyAt - now);
                slotC.classList.add('diddy');
                abilityNameCEl.textContent = 'Baby Oil Ascension';
            } else if (currentStyle === 'cristiano') {
                cdLeftC = Math.max(0, cristianoPowerShotReadyAt - now);
                slotC.classList.add('cristiano');
                abilityNameCEl.textContent = 'Power Shot';
            } else if (currentStyle === 'saja-jin') {
                cdLeftC = Math.max(0, sajaJinDemonicHeroismReadyAt - now);
                slotC.classList.add('saja-jin');
                abilityNameCEl.textContent = 'Demonic Heroism';
            } else if (currentStyle === 'abby') {
                cdLeftC = Math.max(0, abbyColossalCalvesReadyAt - now);
                slotC.classList.add('abby');
                abilityNameCEl.textContent = 'Colossal Calves';
            } else if (currentStyle === 'lincoln') {
                cdLeftC = Math.max(0, lincolnShrekMoveReadyAt - now);
                slotC.classList.add('lincoln');
                abilityNameCEl.textContent = 'Shrek Move';
            } else if (currentStyle === 'korbin') {
                cdLeftC = Math.max(0, korbinFieryApocalypseReadyAt - now);
                slotC.classList.add('korbin');
                abilityNameCEl.textContent = 'Fiery Apocalypse';
            } else if (currentStyle === '67kid') {
                cdLeftC = Math.max(0, sixtySevenKidMayhemReadyAt - now);
                slotC.classList.add('67kid');
                abilityNameCEl.textContent = '67 Mayhem';
            } else if (currentStyle === 'wally') {
                cdLeftC = Math.max(0, wallyRocketBoostReadyAt - now);
                slotC.classList.add('wally');
                abilityNameCEl.textContent = 'Rocket Boost';
            }
            const coolPctC = clamp(1 - cdLeftC / ABILITY_COOLDOWN, 0, 1) * 100;
            const coolElC = document.getElementById('coolC');
            const coolTxC = document.getElementById('coolCText');
            coolElC.style.width = `${coolPctC}%`;

            if(cdLeftC > 0){
                coolTxC.textContent = (cdLeftC/1000).toFixed(1)+'s';
                if(currentStyle === 'xdrake') slotC.classList.add('xdrake');
                if(currentStyle === 'gojo') slotC.classList.add('gojo-red-cool');
                if(currentStyle === 'eddie') slotC.classList.add('eddie');
                if(currentStyle === 'zeus') slotC.classList.add('zeus');
                if(currentStyle === 'asher') slotC.classList.add('asher'); // NEW
                if(currentStyle === 'leonardo') slotC.classList.add('leonardo'); // NEW
                if(currentStyle === 'angus') slotC.classList.add('angus'); // NEW ANGUS
                if(currentStyle === 'diddy') slotC.classList.add('diddy'); // NEW DIDDY
                if(currentStyle === 'cristiano') slotC.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotC.classList.add('saja-jin');
                if(currentStyle === 'abby') slotC.classList.add('abby');
                if(currentStyle === 'lincoln') slotC.classList.add('lincoln');
                if(currentStyle === 'korbin') slotC.classList.add('korbin');
                if(currentStyle === '67kid') slotC.classList.add('67kid');
                if(currentStyle === 'wally') slotC.classList.add('wally');

            } else {
                slotC.classList.add('ready');
                coolTxC.textContent = '';
                if(currentStyle === 'xdrake') slotC.classList.add('xdrake');
                if(currentStyle === 'gojo') slotC.classList.add('gojo-red-ready');
                if(currentStyle === 'eddie') slotC.classList.add('eddie');
                if(currentStyle === 'zeus') slotC.classList.add('zeus');
                if(currentStyle === 'asher') slotC.classList.add('asher'); // NEW
                if(currentStyle === 'leonardo') slotC.classList.add('leonardo'); // NEW
                if(currentStyle === 'angus') slotC.classList.add('angus'); // NEW ANGUS
                if(currentStyle === 'diddy') slotC.classList.add('diddy'); // NEW DIDDY
                if(currentStyle === 'cristiano') slotC.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotC.classList.add('saja-jin');
                if(currentStyle === 'abby') slotC.classList.add('abby');
                if(currentStyle === 'lincoln') slotC.classList.add('lincoln');
                if(currentStyle === 'korbin') slotC.classList.add('korbin');
                if(currentStyle === '67kid') slotC.classList.add('67kid');
                if(currentStyle === 'wally') slotC.classList.add('wally');

            }
            if (currentStyle === 'none') { slotC.style.display = 'none'; } else { slotC.style.display = 'flex'; }



            let cdLeftV = 0;
            slotV.classList.remove('ready');
            slotV.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher', 'leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');

            if (currentStyle === 'robsan') {
                cdLeftV = Math.max(0, eclipseGraspReadyAt - now);
                slotV.classList.add('robsan');
                abilityNameVEl.textContent = 'Eclipse Grasp';
            } else if (currentStyle === 'xdrake') {
                cdLeftV = Math.max(0, fossilFootworkReadyAt - now);
                slotV.classList.add('xdrake');
                abilityNameVEl.textContent = 'Fossilised Footwork';
            } else if (currentStyle === 'gojo') {
                cdLeftV = Math.max(0, gojoLapseBlueReadyAt - now);
                slotV.classList.add('gojo');
                abilityNameVEl.textContent = 'Lapse Blue';
            } else if (currentStyle === 'eddie') {
                cdLeftV = Math.max(0, eddieVenomStrikeReadyAt - now);
                slotV.classList.add('eddie');
                abilityNameVEl.textContent = 'Venom Strike';
            } else if (currentStyle === 'zeus') {
                cdLeftV = Math.max(0, zeusHeavenlyShieldReadyAt - now);
                slotV.classList.add('zeus');
                abilityNameVEl.textContent = 'Heavenly Shield';
            } else if (currentStyle === 'asher') { // NEW ASHER
                cdLeftV = Math.max(0, asherBallTeleportReadyAt - now);
                slotV.classList.add('asher');
                abilityNameVEl.textContent = 'Celestial Pull';
            } else if (currentStyle === 'leonardo') { // NEW LEONARDO
                cdLeftV = Math.max(0, leonardoShieldReadyAt - now);
                slotV.classList.add('leonardo');
                abilityNameVEl.textContent = 'Sensory Shield';
            } else if (currentStyle === 'angus') { // NEW ANGUS
                cdLeftV = Math.max(0, angusTimeStopReadyAt - now);
                slotV.classList.add('angus');
                abilityNameVEl.textContent = 'Time Stop';
            } else if (currentStyle === 'diddy') { // NEW DIDDY
                cdLeftV = Math.max(0, diddySlickShotReadyAt - now);
                slotV.classList.add('diddy');
                abilityNameVEl.textContent = 'Slick Shot';
            } else if (currentStyle === 'cristiano') {
                cdLeftV = Math.max(0, cristianoGoatTackleReadyAt - now);
                slotV.classList.add('cristiano');
                abilityNameVEl.textContent = "GOAT's Tackle";
            } else if (currentStyle === 'saja-jin') {
                cdLeftV = Math.max(0, sajaJinSoulSuckingShotReadyAt - now);
                slotV.classList.add('saja-jin');
                abilityNameVEl.textContent = 'Soul-Sucking Shot';
            } else if (currentStyle === 'hudson') {
                cdLeftV = Math.max(0, hudsonEmperorDribbleReadyAt - now);
                slotV.classList.add('hudson');
                abilityNameVEl.textContent = 'dribble like an emperor';
            } else if (currentStyle === 'abby') {
                cdLeftV = Math.max(0, abbyPowerPinReadyAt - now);
                slotV.classList.add('abby');
                abilityNameVEl.textContent = 'Power Pin';
            } else if (currentStyle === 'lincoln') {
                cdLeftV = Math.max(0, lincolnKissMoveReadyAt - now);
                slotV.classList.add('lincoln');
                abilityNameVEl.textContent = 'Kiss Move';
            } else if (currentStyle === 'korbin') {
                cdLeftV = Math.max(0, korbinBigBackPowerReadyAt - now);
                slotV.classList.add('korbin');
                abilityNameVEl.textContent = 'Big Back Power';
            } else if (currentStyle === 'wally') {
                cdLeftV = Math.max(0, wallySpeedForceReadyAt - now);
                slotV.classList.add('wally');
                abilityNameVEl.textContent = 'Speed Force';
            }
            let cooldownDuration = ABILITY_COOLDOWN;
            if (currentStyle === 'hudson') cooldownDuration = HUDSON_EMPEROR_DRIBBLE_COOLDOWN;
            if (currentStyle === 'korbin') cooldownDuration = KORBIN_BIG_BACK_POWER_COOLDOWN;
            const coolPctV = clamp(1 - cdLeftV / cooldownDuration, 0, 1) * 100;
            const coolElV = document.getElementById('coolV');
            const coolTxV = document.getElementById('coolVText');
            coolElV.style.width = `${coolPctV}%`;

            if(cdLeftV > 0){
                coolTxV.textContent = (cdLeftV/1000).toFixed(1)+'s';
                if(currentStyle === 'robsan') slotV.classList.add('eclipse-cool');
                if(currentStyle === 'xdrake') slotV.classList.add('footwork-cool');
                if(currentStyle === 'gojo') slotV.classList.add('gojo-blue-cool');
                if(currentStyle === 'eddie') slotV.classList.add('eddie');
                if(currentStyle === 'zeus') slotV.classList.add('zeus');
                if(currentStyle === 'asher') slotV.classList.add('asher'); // NEW
                if(currentStyle === 'leonardo') slotV.classList.add('leonardo'); // NEW
                if(currentStyle === 'angus') slotV.classList.add('angus'); // NEW ANGUS
                if(currentStyle === 'diddy') slotV.classList.add('diddy'); // NEW DIDDY
                if(currentStyle === 'cristiano') slotV.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotV.classList.add('saja-jin');
                if(currentStyle === 'hudson') slotV.classList.add('hudson');
                if(currentStyle === 'abby') slotV.classList.add('abby');
                if(currentStyle === 'lincoln') slotV.classList.add('lincoln');
                if(currentStyle === 'korbin') slotV.classList.add('korbin');
                if(currentStyle === 'wally') slotV.classList.add('wally');
            } else {
                slotV.classList.add('ready');
                coolTxV.textContent = '';
                if(currentStyle === 'robsan') slotV.classList.add('eclipse-ready');
                if(currentStyle === 'xdrake') slotV.classList.add('footwork-ready');
                if(currentStyle === 'gojo') slotV.classList.add('gojo-blue-ready');
                if(currentStyle === 'eddie') slotV.classList.add('eddie');
                if(currentStyle === 'zeus') slotV.classList.add('zeus');
                if(currentStyle === 'asher') slotV.classList.add('asher'); // NEW
                if(currentStyle === 'leonardo') slotV.classList.add('leonardo'); // NEW
                if(currentStyle === 'angus') slotV.classList.add('angus'); // NEW ANGUS
                if(currentStyle === 'diddy') slotV.classList.add('diddy'); // NEW DIDDY
                if(currentStyle === 'cristiano') slotV.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotV.classList.add('saja-jin');
                if(currentStyle === 'hudson') slotV.classList.add('hudson');
                if(currentStyle === 'abby') slotV.classList.add('abby');
                if(currentStyle === 'lincoln') slotV.classList.add('lincoln');
                if(currentStyle === 'wally') slotV.classList.add('wally');
            }
            if (currentStyle === 'none') { slotV.style.display = 'none'; } else { slotV.style.display = 'flex'; }



            let cdLeftX = 0;
            slotX.classList.remove('ready');
            slotX.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher', 'leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'korbin', 'wally', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');

            if (currentStyle === 'robsan') {
                cdLeftX = Math.max(0, voidDashReadyAt - now);
                slotX.classList.add('robsan');
                abilityNameXEl.textContent = 'Void Dash';
            } else if (currentStyle === 'xdrake') {
                cdLeftX = Math.max(0, ancientApexReadyAt - now);
                slotX.classList.add('xdrake');
                abilityNameXEl.textContent = 'Ancient Apex';
            } else if (currentStyle === 'gojo') {
                cdLeftX = Math.max(0, gojoPurpleReadyAt - now);
                slotX.classList.add('gojo');
                abilityNameXEl.textContent = 'Purple';
            } else if (currentStyle === 'eddie') {
                cdLeftX = Math.max(0, eddieSymbioteMontageReadyAt - now);
                slotX.classList.add('eddie');
                abilityNameXEl.textContent = 'Symbiote Montage';
            } else if (currentStyle === 'zeus') {
                cdLeftX = Math.max(0, zeusOlympusFuryReadyAt - now);
                slotX.classList.add('zeus');
                abilityNameXEl.textContent = 'Olympus\' Fury';
            } else if (currentStyle === 'leonardo') { // NEW LEONARDO
                cdLeftX = Math.max(0, leonardoDashReadyAt - now);
                slotX.classList.add('leonardo');
                abilityNameXEl.textContent = 'Pattern Weave';
            } else if (currentStyle === 'angus') { // NEW ANGUS
                cdLeftX = Math.max(0, angusTeleportReadyAt - now);
                slotX.classList.add('angus');
                abilityNameXEl.textContent = 'Shadow Teleport';
            } else if (currentStyle === 'diddy') { // NEW DIDDY
                cdLeftX = Math.max(0, diddyOilSlickReadyAt - now);
                slotX.classList.add('diddy');
                abilityNameXEl.textContent = 'Baby Oil Blindness';
            } else if (currentStyle === 'cristiano') {
                cdLeftX = Math.max(0, cristianoPortugueseSpiritReadyAt - now);
                slotX.classList.add('cristiano');
                abilityNameXEl.textContent = 'Portuguese Spirit';
            } else if (currentStyle === 'saja-jin') {
                cdLeftX = Math.max(0, sajaJinHypnoticShotReadyAt - now);
                slotX.classList.add('saja-jin');
                abilityNameXEl.textContent = 'Hypnotic Shot';
            } else if (currentStyle === 'abby') {
                cdLeftX = Math.max(0, abbyDemonDriveReadyAt - now);
                slotX.classList.add('abby');
                abilityNameXEl.textContent = 'Demon Drive';
            } else if (currentStyle === 'korbin') {
                cdLeftX = Math.max(0, korbinBigShotReadyAt - now);
                slotX.classList.add('korbin');
                abilityNameXEl.textContent = 'Big Shot';
            } else if (currentStyle === 'lincoln') {
                cdLeftX = Math.max(0, lincolnGyattShowdownReadyAt - now);
                slotX.classList.add('lincoln');
                abilityNameXEl.textContent = 'Gyatt Showdown';
            } else if (currentStyle === 'wally') {
                cdLeftX = Math.max(0, wallyFlashyLightningReadyAt - now);
                slotX.classList.add('wally');
                abilityNameXEl.textContent = 'Flashy Lightning';
            }
            const coolPctX = clamp(1 - cdLeftX / (currentStyle === 'gojo' || currentStyle === 'eddie' || currentStyle === 'zeus' ? ABILITY_COOLDOWN * 2 : 
                currentStyle === 'korbin' ? KORBIN_BIG_SHOT_COOLDOWN : ABILITY_COOLDOWN), 0, 1) * 100;
            const coolElX = document.getElementById('coolX');
            const coolTxX = document.getElementById('coolXText');
            coolElX.style.width = `${coolPctX}%`;

            if(cdLeftX > 0){
                coolTxX.textContent = (cdLeftX/1000).toFixed(1)+'s';
                if(currentStyle === 'robsan') slotX.classList.add('void-cool');
                if(currentStyle === 'xdrake') slotX.classList.add('apex-cool');
                if(currentStyle === 'gojo') slotX.classList.add('gojo-purple-cool');
                if(currentStyle === 'eddie') slotX.classList.add('eddie');
                if(currentStyle === 'zeus') slotX.classList.add('zeus');
                if(currentStyle === 'leonardo') slotX.classList.add('leonardo'); // NEW
                if(currentStyle === 'angus') slotX.classList.add('angus'); // NEW ANGUS
                if(currentStyle === 'diddy') slotX.classList.add('diddy'); // NEW DIDDY
                if(currentStyle === 'cristiano') slotX.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotX.classList.add('saja-jin');
                if(currentStyle === 'abby') slotX.classList.add('abby');
                if(currentStyle === 'korbin') slotX.classList.add('korbin');
                if(currentStyle === 'lincoln') slotX.classList.add('lincoln');
                if(currentStyle === 'wally') slotX.classList.add('wally');
            } else {
                slotX.classList.add('ready');
                coolTxX.textContent = '';
                if(currentStyle === 'robsan') slotX.classList.add('void-ready');
                if(currentStyle === 'xdrake') slotX.classList.add('apex-ready');
                if(currentStyle === 'gojo') slotX.classList.add('gojo-purple-ready');
                if(currentStyle === 'eddie') slotX.classList.add('eddie');
                if(currentStyle === 'zeus') slotX.classList.add('zeus');
                if(currentStyle === 'leonardo') slotX.classList.add('leonardo'); // NEW
                if(currentStyle === 'angus') slotX.classList.add('angus'); // NEW ANGUS
                if(currentStyle === 'diddy') slotX.classList.add('diddy'); // NEW DIDDY
                if(currentStyle === 'cristiano') slotX.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotX.classList.add('saja-jin');
                if(currentStyle === 'abby') slotX.classList.add('abby');
                if(currentStyle === 'korbin') slotX.classList.add('korbin');
                if(currentStyle === 'lincoln') slotX.classList.add('lincoln');
                if(currentStyle === 'wally') slotX.classList.add('wally');
            }
            if (currentStyle === 'none' || currentStyle === 'hudson' || currentStyle === 'asher') { slotX.style.display = 'none'; } else { slotX.style.display = 'flex'; }
        }

        function checkGoal(){
            if(ball.x - ball.r <= margin + goalDepth && ball.y > H/2 - goalW/2 && ball.y < H/2 + goalW/2){
                scoreR++;
                // Awakening progress only for Wally style (only when not in awakening mode)
                if (currentStyle === 'wally' && !player.awakeningActive && player.awakeningProgress < AWAKENING_GOALS_REQUIRED) {
                    player.awakeningProgress++;
                    updateAwakeningBar();
                }
                // Increase Eddie's awakening progress by 10% when scoring goals (legacy system)
                if (currentStyle === 'eddie' && player.eddieAwakeningProgress < 100) {
                    player.eddieAwakeningProgress = Math.min(100, player.eddieAwakeningProgress + 10);
                }
                updatePlayerLevel();
                resetRound();
            }
            if(ball.x + ball.r >= W - margin - goalDepth && ball.y > H/2 - goalW/2 && ball.y < H/2 + goalW/2){
                scoreL++;
                updatePlayerLevel();
                // Awakening progress only for Wally style (only when not in awakening mode)
                if (currentStyle === 'wally' && !player.awakeningActive && player.awakeningProgress < AWAKENING_GOALS_REQUIRED) {
                    player.awakeningProgress++;
                    updateAwakeningBar();
                }
                // Increase Eddie's awakening progress by 10% when scoring goals (legacy system)
                if (currentStyle === 'eddie' && player.eddieAwakeningProgress < 100) {
                    player.eddieAwakeningProgress = Math.min(100, player.eddieAwakeningProgress + 10);
                }
                resetRound();
            }
        }

        function updateAwakeningBar() {
            const awakeningLabel = document.getElementById('awakening-label');
            
            if (player.awakeningActive) {
                // During awakening - show time remaining as countdown
                const now = performance.now();
                const timeLeft = Math.max(0, player.awakeningEndTime - now);
                const timeLeftPercentage = (timeLeft / AWAKENING_DURATION) * 100;
                const timeLeftSeconds = Math.ceil(timeLeft / 1000);
                
                awakeningFill.style.width = `${timeLeftPercentage}%`;
                awakeningLabel.textContent = `G - Awakening: ${timeLeftSeconds}s remaining`;
                
                // Change bar color during awakening to show it's active
                awakeningFill.style.background = 'linear-gradient(90deg, #ff6b6b, #ffd93d)';
                awakeningBar.classList.remove('full');
            } else {
                // Charging up - show goals progress
                const progressPercentage = (player.awakeningProgress / AWAKENING_GOALS_REQUIRED) * 100;
                awakeningFill.style.width = `${progressPercentage}%`;
                awakeningLabel.textContent = `G - Awakening: ${Math.round(progressPercentage)}%`;
                
                // Reset to normal color when charging
                awakeningFill.style.background = 'linear-gradient(90deg, #00ffff, #0080ff)';
                
                if (player.awakeningProgress >= AWAKENING_GOALS_REQUIRED) {
                    awakeningBar.classList.add('full');
                    awakeningLabel.textContent = 'G - Awakening: READY!';
                } else {
                    awakeningBar.classList.remove('full');
                }
            }
            
            // Legacy Eddie awakening system (if needed)
            if (currentStyle === 'eddie' && player.eddieAwakeningProgress >= 100) {
                // Eddie specific awakening logic can stay here if needed
            }
        }

        function triggerEddieAwakening() {
            // Set awakening state
            player.eddieAwakeningActive = true;
            player.eddieAwakeningEndTime = performance.now() + 100000; // 100 seconds
            player.eddieAwakeningVideoPlaying = true;

            // Create and play video
            const video = document.createElement('video');
            video.src = 'venomawk.mp4';
            video.style.position = 'fixed';
            video.style.top = '50%';
            video.style.left = '50%';
            video.style.transform = 'translate(-50%, -50%)';
            video.style.zIndex = '9999';
            video.style.width = '100%';
            video.style.height = '100%';
            video.style.objectFit = 'contain';
            video.autoplay = true;
            video.muted = false;

            document.body.appendChild(video);

            // Remove video after 5 seconds
            setTimeout(() => {
                video.remove();
                player.eddieAwakeningVideoPlaying = false;
            }, 5000);

            // Update moves to awakening versions
            updateEddieAwakeningMoves();

            // Reset awakening progress
            player.eddieAwakeningProgress = 100; // Keep at 100 during awakening
            updateAwakeningBar();
        }

        function updateEddieAwakeningMoves() {
            if (currentStyle === 'eddie') {
                if (player.eddieAwakeningActive) {
                    abilityNameCEl.textContent = 'Venom Devastation';
                    abilityNameVEl.textContent = 'Shadow Realm';
                    abilityNameXEl.textContent = 'Symbiote Montage';
                } else {
                    abilityNameCEl.textContent = 'We Are';
                    abilityNameVEl.textContent = 'Venom Strike';
                    abilityNameXEl.textContent = 'Symbiote Montage';
                }
            }
        }

        function updateEddieAwakeningTimer() {
            if (currentStyle === 'eddie' && player.eddieAwakeningActive) {
                const now = performance.now();
                const timeLeft = player.eddieAwakeningEndTime - now;

                if (timeLeft <= 0) {
                    // Awakening ended
                    player.eddieAwakeningActive = false;
                    player.eddieAwakeningProgress = 0;
                    updateAwakeningBar();
                    updateEddieAwakeningMoves();
                } else {
                    // Update awakening progress (decreases from 100% to 0% over 100 seconds)
                    const progressPercent = (timeLeft / 100000) * 100;
                    player.eddieAwakeningProgress = Math.max(0, progressPercent);
                    updateAwakeningBar();
                }
            }
        }

        // ===== UNIVERSAL AWAKENING SYSTEM =====
        
        function triggerAwakening() {
            // Set awakening state
            player.awakeningActive = true;
            player.awakeningEndTime = performance.now() + AWAKENING_DURATION;
            player.awakeningEyesActive = true;
            player.awakeningAuraActive = true;
            player.autoEyesClosedTriggered = false; // Reset auto teleport flag

            // Show typewriter subtitle
            showAwakeningSubtitle("My... Ordinary... Life..", () => {
                // After subtitle completes, show moves change
                showNotification('Awakening activated! New abilities unlocked!', 'success');
            });

            // Add awakening visual effects
            addAwakeningEffects();

            // Update moves UI
            updateAwakeningMoves();

            // Reset progress during awakening
            updateAwakeningBar();
        }

        function showAwakeningSubtitle(text, callback) {
            // Create subtitle element
            const subtitleEl = document.createElement('div');
            subtitleEl.style.position = 'fixed';
            subtitleEl.style.top = '20%'; /* Move to top area instead of center */
            subtitleEl.style.left = '50%';
            subtitleEl.style.transform = 'translate(-50%, -50%)';
            subtitleEl.style.background = 'rgba(0, 0, 0, 0.9)';
            subtitleEl.style.color = '#00ffff';
            subtitleEl.style.padding = '15px 30px'; /* Smaller padding */
            subtitleEl.style.borderRadius = '12px';
            subtitleEl.style.fontSize = '2rem'; /* Slightly smaller font */
            subtitleEl.style.fontFamily = 'Nunito, sans-serif';
            subtitleEl.style.fontWeight = '900';
            subtitleEl.style.textAlign = 'center';
            subtitleEl.style.zIndex = '10000';
            subtitleEl.style.border = '2px solid #00ffff';
            subtitleEl.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.4)';
            subtitleEl.style.textShadow = '0 0 8px rgba(0, 255, 255, 0.6)';
            document.body.appendChild(subtitleEl);

            // Typewriter effect
            let charIndex = 0;
            const typeInterval = setInterval(() => {
                subtitleEl.textContent = text.substring(0, charIndex);
                charIndex++;
                
                if (charIndex > text.length) {
                    clearInterval(typeInterval);
                    setTimeout(() => {
                        subtitleEl.remove();
                        if (callback) callback();
                    }, 2000);
                }
            }, 100); // 100ms per character
        }

        function addAwakeningEffects() {
            // Add cyan glowing eyes effect
            player.awakeningEyesActive = true;
            
            // Add deep blue faded aura
            player.awakeningAuraActive = true;
            
            // No field color changes - keep field normal
            
            // Add particle effects around player
            for (let i = 0; i < 30; i++) { /* Fewer particles for better performance */
                vfx.sparks.push({
                    x: player.x + (Math.random() - 0.5) * 80,
                    y: player.y + (Math.random() - 0.5) * 80,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    life: 1500 + Math.random() * 800,
                    t: 0,
                    r: 1.5 + Math.random() * 2,
                    color: 'rgba(0, 255, 255,'
                });
            }
        }

        function updateAwakeningMoves() {
            if (player.awakeningActive) {
                // Grey out normal moves bar
                document.querySelector('.movesbar').style.filter = 'grayscale(1) brightness(0.5)';
                
                // Show awakened moves bar
                document.getElementById('awakened-movesbar').style.display = 'flex';
            } else {
                // Restore normal moves bar
                document.querySelector('.movesbar').style.filter = 'none';
                
                // Hide awakened moves bar
                document.getElementById('awakened-movesbar').style.display = 'none';
            }
        }

        function updateAwakeningTimer() {
            if (currentStyle === 'wally' && player.awakeningActive) {
                const now = performance.now();
                const timeLeft = player.awakeningEndTime - now;

                // Check if Last Fear shield should end
                if (player.lastFearActive && now >= player.lastFearEndTime) {
                    player.lastFearActive = false;
                    showNotification('Last Fear shield ended!', 'info');
                }

                // Update the awakening bar countdown
                updateAwakeningBar();

                // Auto Eyes Closed in final 5 seconds (only once)
                if (timeLeft <= 5000 && timeLeft > 4000 && !player.autoEyesClosedTriggered) {
                    player.autoEyesClosedTriggered = true;
                    
                    // Quick teleport without the dramatic text - just 0.3 second black screen
                    const quickBlackScreen = document.createElement('div');
                    quickBlackScreen.style.position = 'fixed';
                    quickBlackScreen.style.top = '0';
                    quickBlackScreen.style.left = '0';
                    quickBlackScreen.style.width = '100vw';
                    quickBlackScreen.style.height = '100vh';
                    quickBlackScreen.style.backgroundColor = 'black';
                    quickBlackScreen.style.zIndex = '10000';
                    quickBlackScreen.style.opacity = '0';
                    quickBlackScreen.style.transition = 'opacity 0.05s ease-in';
                    document.body.appendChild(quickBlackScreen);

                    // Quick fade in
                    setTimeout(() => {
                        quickBlackScreen.style.opacity = '1';
                    }, 10);

                    // Auto teleport after 0.3 seconds
                    setTimeout(() => {
                        // Teleport to RIGHT goal (where player scores)
                        player.x = W - margin - goalDepth - 25;
                        player.y = H/2;
                        
                        // Position ball for easy score in RIGHT goal
                        ball.x = W - margin - goalDepth + 3;
                        ball.y = H/2;
                        ball.vx = 0;
                        ball.vy = 0;
                        
                        // Quick particles
                        for (let i = 0; i < 8; i++) {
                            vfx.sparks.push({
                                x: player.x + (Math.random() - 0.5) * 40,
                                y: player.y + (Math.random() - 0.5) * 40,
                                vx: (Math.random() - 0.5) * 3,
                                vy: (Math.random() - 0.5) * 3,
                                life: 500,
                                t: 0,
                                r: 1 + Math.random(),
                                color: 'rgba(0, 255, 255,'
                            });
                        }
                        
                        // Trigger goal
                        setTimeout(() => checkGoal(), 50);
                        
                        // Quick fade out
                        quickBlackScreen.style.opacity = '0';
                        setTimeout(() => quickBlackScreen.remove(), 100);
                        
                        showNotification('Final teleport before awakening ends!', 'warning');
                    }, 300);
                }

                if (timeLeft <= 0) {
                    // Awakening ended
                    endAwakening();
                }
            }
        }

        function endAwakening() {
            player.awakeningActive = false;
            player.awakeningEyesActive = false;
            player.awakeningAuraActive = false;
            player.lastFearActive = false;
            player.partOfMyDesireActive = false;
            
            // Reset boosts
            if (player.partOfMyDesireOriginalMaxSpd) {
                player.maxSpd = player.partOfMyDesireOriginalMaxSpd;
            }
            if (player.partOfMyDesireOriginalShotPower) {
                player.shotPower = player.partOfMyDesireOriginalShotPower;
            }
            
            // Reset awakening progress to 0 so player needs 10 goals again
            player.awakeningProgress = 0;
            
            // Reset screen effects
            canvas.style.filter = 'none';
            
            // Update UI
            updateAwakeningMoves();
            updateAwakeningBar(); // Update bar to show 0% charging state
            
            showNotification('Awakening ended! Need 10 more goals to awaken again.', 'info');
        }

        // ===== AWAKENING ABILITIES =====

        function tryLastFear() {
            if (!player.awakeningActive) return;
            
            const now = performance.now();
            if (player.lastFearActive) {
                showNotification('Last Fear already active!', 'warning');
                return;
            }

            // Activate shield
            player.lastFearActive = true;
            player.lastFearEndTime = now + LAST_FEAR_DURATION;

            // Create better shield effect - multiple layers for more impressive look
            for (let i = 0; i < 3; i++) {
                vfx.sparks.push({
                    x: player.x,
                    y: player.y,
                    vx: 0,
                    vy: 0,
                    life: LAST_FEAR_DURATION,
                    t: 0,
                    r: player.r * (3 + i * 0.5), // Multiple shield layers
                    color: `rgba(0, 255, 255, ${0.4 - i * 0.1})`, // Decreasing opacity
                    isShield: true,
                    shieldLayer: i,
                    attachedToPlayer: true // Flag to follow player movement
                });
            }

            // Add sparkle effects around the shield
            for (let i = 0; i < 15; i++) {
                const angle = (i / 15) * Math.PI * 2;
                const dist = player.r * 3.5;
                vfx.sparks.push({
                    x: player.x + Math.cos(angle) * dist,
                    y: player.y + Math.sin(angle) * dist,
                    vx: Math.cos(angle) * 0.5,
                    vy: Math.sin(angle) * 0.5,
                    life: LAST_FEAR_DURATION,
                    t: 0,
                    r: 2 + Math.random() * 2,
                    color: 'rgba(0, 255, 255,',
                    isShieldSparkle: true,
                    attachedToPlayer: true,
                    orbitalAngle: angle,
                    orbitalDistance: dist
                });
            }

            showNotification('Last Fear activated! Shield up!', 'success');
        }

        function tryEyesClosed() {
            if (!player.awakeningActive) return;

            // Create quick black screen - just 0.5 seconds
            const blackScreen = document.createElement('div');
            blackScreen.style.position = 'fixed';
            blackScreen.style.top = '0';
            blackScreen.style.left = '0';
            blackScreen.style.width = '100vw';
            blackScreen.style.height = '100vh';
            blackScreen.style.backgroundColor = 'black';
            blackScreen.style.zIndex = '10000';
            blackScreen.style.opacity = '0';
            blackScreen.style.transition = 'opacity 0.1s ease-in';
            document.body.appendChild(blackScreen);

            // Quick fade in
            setTimeout(() => {
                blackScreen.style.opacity = '1';
            }, 10);

            // Teleport after 0.5 seconds
            setTimeout(() => {
                // Teleport player very close to RIGHT goal (where player scores)
                player.x = W - margin - goalDepth - 30; // Just outside RIGHT goal
                player.y = H/2; // Center height
                
                // Position ball right at the RIGHT goal line for easy score
                ball.x = W - margin - goalDepth + 5; // Just inside RIGHT goal
                ball.y = H/2; // Center of goal
                ball.vx = 0; // Stop the ball
                ball.vy = 0;
                
                // Add teleportation particles around player
                for (let i = 0; i < 15; i++) {
                    vfx.sparks.push({
                        x: player.x + (Math.random() - 0.5) * 60,
                        y: player.y + (Math.random() - 0.5) * 60,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 800,
                        t: 0,
                        r: 1.5 + Math.random() * 2,
                        color: 'rgba(0, 255, 255,'
                    });
                }
                
                // Trigger goal check
                setTimeout(() => {
                    checkGoal();
                }, 50);
                
                // Quick fade out
                blackScreen.style.opacity = '0';
                setTimeout(() => {
                    blackScreen.remove();
                }, 100);
                
                showNotification('Teleported to enemy goal!', 'success');
            }, 500); // 0.5 second duration

            showNotification('Eyes Closed activated!', 'success');
        }

        function tryPartOfMyDesire() {
            if (!player.awakeningActive) return;
            
            const now = performance.now();
            if (player.partOfMyDesireActive) {
                showNotification('Part of my Desire already active!', 'warning');
                return;
            }

            // Activate boosts
            player.partOfMyDesireActive = true;
            player.partOfMyDesireEndTime = now + PART_OF_MY_DESIRE_DURATION;
            player.partOfMyDesireOriginalMaxSpd = player.maxSpd;
            player.partOfMyDesireOriginalShotPower = player.shotPower || 1.0; // Store original shot power
            
            // Apply boosts
            player.maxSpd *= PART_OF_MY_DESIRE_SPEED_BOOST;
            player.shotPower = (player.shotPower || 1.0) * PART_OF_MY_DESIRE_STRENGTH_BOOST;

            // Add visual boost effects - speed lines trailing the player
            for (let i = 0; i < 40; i++) {
                vfx.sparks.push({
                    x: player.x + (Math.random() - 0.5) * 100,
                    y: player.y + (Math.random() - 0.5) * 100,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: PART_OF_MY_DESIRE_DURATION,
                    t: 0,
                    r: 1 + Math.random() * 2,
                    color: 'rgba(255, 215, 0,', // Golden particles for speed
                    isSpeedBoost: true,
                    attachedToPlayer: true
                });
            }

            // Add glowing aura around player for boost duration
            vfx.sparks.push({
                x: player.x,
                y: player.y,
                vx: 0,
                vy: 0,
                life: PART_OF_MY_DESIRE_DURATION,
                t: 0,
                r: player.r * 2,
                color: 'rgba(255, 215, 0, 0.3)',
                isSpeedAura: true,
                attachedToPlayer: true
            });

            showNotification('Part of my Desire activated! 30% speed & strength boost!', 'success');
        }

        function updatePlayerLevel() {
            // Update player level system
            playerGoals++;
            localStorage.setItem('playerGoals', playerGoals);
           
            // Calculate progress percentage
            const progressPercent = (playerGoals / goalsForNextLevel) * 100;
            document.getElementById('level-progress').style.width = `${progressPercent}%`;
            document.getElementById('goals-progress').textContent = playerGoals;
            document.getElementById('goals-needed').textContent = goalsForNextLevel;
           
            // Check for level up
            if (playerGoals >= goalsForNextLevel) {
                playerLevel++;
                playerGoals = 0;
                localStorage.setItem('playerLevel', playerLevel);
                localStorage.setItem('playerGoals', playerGoals);
                goalsForNextLevel = playerLevel * 2;
               
                // Update UI
                document.getElementById('level-number').textContent = playerLevel;
                document.getElementById('goals-progress').textContent = playerGoals;
                document.getElementById('goals-needed').textContent = goalsForNextLevel;
                document.getElementById('level-progress').style.width = '0%';
               
                // Show level up animation
                const levelUpMsg = document.createElement('div');
                levelUpMsg.className = 'level-up';
                levelUpMsg.textContent = 'LEVEL UP!';
                document.getElementById('game-screen').appendChild(levelUpMsg);
                setTimeout(() => levelUpMsg.remove(), 2000);
               
                // Update Lincoln button availability
                updateLincolnButtonAvailability();
                updateWallyButtonAvailability();
            }
        }

        function initializeLevelSystem() {
            // Initialize level UI
            document.getElementById('level-number').textContent = playerLevel;
            document.getElementById('goals-progress').textContent = playerGoals;
            document.getElementById('goals-needed').textContent = goalsForNextLevel;
            const progressPercent = (playerGoals / goalsForNextLevel) * 100;
            document.getElementById('level-progress').style.width = `${progressPercent}%`;
            updateLincolnButtonAvailability();
            updateWallyButtonAvailability();
        }

        function updateLevelDisplay() {
            // Update the level display and save to localStorage
            localStorage.setItem('playerLevel', playerLevel);
            document.getElementById('level-number').textContent = playerLevel;
            goalsForNextLevel = playerLevel * 2;
            document.getElementById('goals-needed').textContent = goalsForNextLevel;
            const progressPercent = (playerGoals / goalsForNextLevel) * 100;
            document.getElementById('level-progress').style.width = `${progressPercent}%`;
            updateLincolnButtonAvailability();
            updateWallyButtonAvailability();
        }

        function updateLincolnButtonAvailability() {
            if (playerLevel >= 15) {
                styleLincolnBtn.style.opacity = '1';
                styleLincolnBtn.style.cursor = 'pointer';
                styleLincolnBtn.title = 'Lincoln - Requires the ball for Shrek Move';
                styleLincolnBtn.textContent = 'lincoln';
            } else {
                styleLincolnBtn.style.opacity = '0.5';
                styleLincolnBtn.style.cursor = 'not-allowed';
                styleLincolnBtn.title = 'Requires Level 15';
                styleLincolnBtn.textContent = `lincoln (lvl 15)`;
            }
        }

        function updateWallyButtonAvailability() {
            if (playerLevel >= 50) {
                styleWallyBtn.style.opacity = '1';
                styleWallyBtn.style.cursor = 'pointer';
                styleWallyBtn.title = 'Wally West - The Flash';
                styleWallyBtn.textContent = 'wally';
            } else {
                styleWallyBtn.style.opacity = '0.5';
                styleWallyBtn.style.cursor = 'not-allowed';
                styleWallyBtn.title = 'Requires Level 50';
                styleWallyBtn.textContent = `wally (lvl 50)`;
            }
        }

        function resetRound(){
            player.x=W*0.25; player.y=H*0.5; player.vx=0; player.vy=0; player.hasBall=false;
            ball.x=W*0.5; ball.y=H*0.5; ball.vx=0; ball.vy=0;

            // Reset Eddie awakening state on round reset
            if (currentStyle === 'eddie') {
                player.eddieAwakeningActive = false;
                // Keep awakening progress so it doesn't reset between rounds
                updateAwakeningBar();
                updateEddieAwakeningMoves();
            }

            // Reset SAJA-JIN abilities on round reset
            if (currentStyle === 'saja-jin') {
                player.sajaJinDemonicHeroismActive = false;
                player.sajaJinHypnoticShotActive = false;
                if (player.sajaJinDemonicHeroismOriginalMaxSpd) {
                    player.maxSpd = player.sajaJinDemonicHeroismOriginalMaxSpd;
                }
            }
            ball.isHoming = false; // NEW ASHER

            // Reset AI player
            if (aiEnabled) {
                aiPlayer.x = W*0.75;
                aiPlayer.y = H*0.5;
                aiPlayer.vx = 0;
                aiPlayer.vy = 0;
                aiPlayer.hasBall = false;
                aiPlayer.state = 'chase';
                aiPlayer.shootCharging = false;
            }



            player.spinning = false;
            player.charging = false;
            player.telekinising = false;
            player.dashing = false;
            player.xdrakeSupernovaDashing = false;
            player.xdrakeFossilFootworking = false;
            player.xdrakeAncientApexCharging = false;
            player.gojoRedCharging = false;
            player.gojoRedActive = false;
            player.gojoLapseBlueActive = false;
            player.gojoLapseBlueBall = null;
            player.gojoPurpleActive = false;
            player.gojoPurpleConverging = false;
            player.gojoPurpleConvergenceStartTime = 0;
            player.gojoPurpleLeftBall = null;
            player.gojoPurpleRightBall = null;
            player.gojoPurpleInitialDir = 0;
            player.gojoPurpleShotFired = false;
            gojoPurpleShockwaveEndTime = 0;

            player.eddieWeAreActive = false;
            player.maxSpd = player.eddieWeAreOriginalMaxSpd;
            player.eddieWeAreEndTime = 0;

            // Reset Cristiano state
            player.cristianoPortugueseSpiritActive = false;
            player.cristianoPortugueseSpiritEndTime = 0;
            player.eddieVenomStrikeActive = false;
            player.eddieSymbioteMontageActive = false;
            player.eddieSymbioteMontagePhase = '';
            player.eddieSymbioteMontageTeleportCount = 0;
            player.eddieSymbioteMontageAimStartTime = 0;
            player.eddieSymbioteMontageShotFired = false;

            player.zeusLightningCharging = false;
            player.zeusLightningChargeStartTime = 0;
            player.zeusLightningActive = false;
            player.zeusHeavenlyShieldActive = false;
            player.zeusHeavenlyShieldEndTime = 0;
            player.zeusHeavenlyShieldRadius = 0;
            player.zeusOlympusFuryActive = false;
            player.zeusOlympusFuryPhase = '';
            player.zeusOlympusFuryPullStartTime = 0;
            player.zeusOlympusFuryAimStartTime = 0;
            player.zeusOlympusFuryShotFired = false;
            player.zeusOlympusFuryOrigHasBall = false;
            player.asherAutoGoalActive = false; // NEW ASHER

            player.leonardoFocusShotActive = false;
            player.leonardoShieldActive = false;
            player.leonardoDashing = false;
            // NEW ANGUS RESET PROPERTIES
            player.angusCharging = false;
            player.angusChargeStartTime = 0;
            player.angusBurstUsesLeft = 3; // Reset to 3 uses
            player.angusTimeStopActive = false;
            player.angusTimeStopEndTime = 0;
            player.angusTeleportActive = false;




            vfx.trail = [];
            vfx.sparks = [];
            vfx.shockwaves = [];
            vfx.flashes = [];
            vfx.lines = [];
            vfx.robsanParticles = [];
            vfx.robsanAura = [];
            vfx.shadowTrails = [];
            vfx.robsanChargeAura = [];
            vfx.eclipseAura = [];
            vfx.eclipseLines = [];
            vfx.voidTrails = [];
            vfx.xdrakeSupernovaTrails = [];
            vfx.xdrakeFootworkDust = [];
            vfx.xdrakeApexAura = [];
            vfx.gojoRedTrail = [];
            vfx.gojoBlueOrbitParticles = [];
            vfx.gojoPurpleCombineVFX = [];
            vfx.gojoPurpleTrail = [];
            vfx.eddieWeAreAura = [];
            vfx.eddieWeAreParticles = [];
            vfx.eddieVenomTendrils = [];
            vfx.eddieVenomShotTrail = [];
            vfx.eddieSymbioteMontageAimAura = [];
            vfx.blackPuddles = [];

            vfx.zeusLightningParticles = [];
            vfx.zeusLightningTrail = [];
            vfx.zeusHeavenlyShieldWaves = [];
            vfx.zeusHeavenlyShieldAura = [];
            vfx.zeusOlympusFuryAura = [];
            vfx.zeusOlympusFuryBallTrail = [];
            vfx.zeusLightningChargeEffect = [];
            vfx.zeusOlympusFuryPullLines = [];
            vfx.zeusGroundScorches = [];

            // NEW ASHER VFX CLEARING
            vfx.asherStarTrail = [];
            vfx.asherTeleportBurst = [];
            vfx.asherArrivalGlimmer = [];

            vfx.hudsonEmperorDribbleTrail = [];
            vfx.hudsonEmperorDribbleParticles = [];
            vfx.hudsonEmperorDribbleAura = [];
            vfx.robsanGroundRupture = [];
            vfx.robsanEclipseWisps = [];
            vfx.robsanVoidPuffs = [];
            vfx.xdrakeSupernovaGroundCrack = [];
            vfx.xdrakeFootworkLeaves = [];
            vfx.xdrakeAncientApexGroundBurst = [];
            vfx.gojoRedExplosion = [];
            vfx.gojoLapseBluePullEffect = [];
            vfx.gojoPurpleArcs = [];
            vfx.eddieWeAreRipples = [];
            vfx.eddieVenomBallSwirl = [];
            vfx.eddieTeleportFlicker = [];

            vfx.hudsonSpeedLines = [];
            vfx.hudsonEnergyWaves = [];
            vfx.robsanShadowClones = [];
            vfx.robsanVoidRifts = [];
            vfx.xdrakeNatureSpirits = [];
            vfx.xdrakeTerraforms = [];
            vfx.gojoInfinityBarriers = [];
            vfx.gojoDomainExpansions = [];
            vfx.eddieSymbioteSpikes = [];
            vfx.eddieVenomDrops = [];
            vfx.zeusThunderClouds = [];
            vfx.zeusLightningBolts = [];
            vfx.playerMovementTrail = [];
            vfx.fieldCracks = [];
            vfx.energyResidue = [];
            vfx.shockwaveRings = [];
            // NEW LEONARDO VFX CLEARING
            vfx.leonardoFocusText = [];
            vfx.leonardoFocusParticles = [];
            vfx.leonardoShieldAura = [];
            vfx.leonardoShieldParticles = [];
            vfx.leonardoDashTrail = [];
            vfx.leonardoDashParticles = [];
            vfx.leonardoPatternField = [];
            // NEW ANGUS VFX CLEARING
            vfx.angusChargeParticles = [];
            vfx.angusBurstVFX = [];
            vfx.angusTimeStopField = [];
            vfx.angusTeleportTrail = [];
            // CRISTIANO VFX CLEARING
            vfx.cristianoPowerShotTrail = [];
            vfx.cristianoGoatTackleParticles = [];
            vfx.cristianoPortugueseSpiritAura = [];
            vfx.cristianoMovementTrail = [];

            // KORBIN VFX CLEARING
            vfx.korbinFireApocalypseFlames = [];
            vfx.korbinFireApocalypseEmbers = [];
            vfx.korbinFireApocalypseExplosion = [];
            vfx.korbinFireApocalypseTrail = [];
            vfx.korbinFireApocalypseShockwave = [];
            vfx.korbinBigShotWindParticles = [];
            vfx.korbinBigShotWindSwirls = [];
            vfx.korbinBigShotWindTrail = [];
            vfx.korbinBigBackPowerWindTrail = [];
            vfx.korbinBigBackPowerWindBurst = [];
            vfx.korbinBigBackPowerShockwave = [];

            // WALLY VFX CLEARING
            vfx.wallyRocketTrail = [];
            vfx.wallySpeedForceDome = [];
            vfx.wallySpeedForceAura = [];
            vfx.wallyLightningAura = [];
            vfx.wallyLightningBolts = [];
            vfx.wallyMovementTrail = [];

            // 67KID VFX CLEARING
            vfx.sixtySevenKidTextClones = [];
            vfx.sixtySevenKidMayhemAura = [];
            vfx.sixtySevenKidBlackoutOverlay = [];
        }

        function resetGame(){
            scoreL=0; scoreR=0;
            resetRound();
        }

        function loop(timestamp) {
            if (!isPlaying) return;
            const dt = Math.min(timestamp - last, 16.67); // Cap delta time for smoother performance
            last = timestamp;

            updatePlayer(dt);
            updateBall(dt);
            updateAI(dt);
            updateVFX(dt);
            updateEddieAwakeningTimer();
            updateAwakeningTimer();
            checkGoal();

            // Use double buffering technique for smoother rendering
            ctx.save();
            ctx.clearRect(0, 0, W, H);
            drawField();
            drawBall();
            drawPlayer();
            drawAI();
            drawVFX(dt);
            drawUI();
            ctx.restore();

            loopId = requestAnimationFrame(loop);
        }


              function drawVFX(dt){
            const now = performance.now();

            for(const p of vfx.sparks){
                // Update position for effects attached to player
                if (p.attachedToPlayer) {
                    if (p.isShield) {
                        p.x = player.x;
                        p.y = player.y;
                    } else if (p.isShieldSparkle) {
                        // Orbital movement around player
                        p.orbitalAngle += 0.02; // Rotation speed
                        p.x = player.x + Math.cos(p.orbitalAngle) * p.orbitalDistance;
                        p.y = player.y + Math.sin(p.orbitalAngle) * p.orbitalDistance;
                    } else if (p.isSpeedAura) {
                        p.x = player.x;
                        p.y = player.y;
                    } else if (p.isSpeedBoost) {
                        // Speed particles trail behind the player
                        const trailX = player.x - (player.vx || 0) * 3 + (Math.random() - 0.5) * 40;
                        const trailY = player.y - (player.vy || 0) * 3 + (Math.random() - 0.5) * 40;
                        p.x = trailX;
                        p.y = trailY;
                    }
                }

                const f = 1 - p.t/p.life; 
                const a = f*0.9;
                
                if (p.isShield) {
                    // Special rendering for shield effects
                    const pulse = Math.sin(p.t * 0.005) * 0.3 + 0.7;
                    const shieldAlpha = a * pulse * 0.6;
                    
                    ctx.save();
                    ctx.globalAlpha = shieldAlpha;
                    ctx.strokeStyle = `rgba(0, 255, 255, ${shieldAlpha})`;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Add inner glow
                    const g = ctx.createRadialGradient(p.x, p.y, p.r * 0.8, p.x, p.y, p.r);
                    g.addColorStop(0, `rgba(0, 255, 255, ${shieldAlpha * 0.1})`);
                    g.addColorStop(1, `rgba(0, 255, 255, ${shieldAlpha * 0.4})`);
                    ctx.fillStyle = g;
                    ctx.fill();
                    ctx.restore();
                } else if (p.isSpeedAura) {
                    // Golden speed aura effect
                    const pulse = Math.sin(p.t * 0.008) * 0.2 + 0.8;
                    const auraAlpha = a * pulse * 0.5;
                    
                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
                    g.addColorStop(0, `rgba(255, 215, 0, ${auraAlpha * 0.6})`);
                    g.addColorStop(0.7, `rgba(255, 165, 0, ${auraAlpha * 0.3})`);
                    g.addColorStop(1, `rgba(255, 100, 0, 0)`);
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Regular spark rendering
                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*4);
                    g.addColorStop(0,`${p.color}${a})`);
                    g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
                }
            }


            // Enhanced Robsan particles with pulsing shadow effect
            for(const p of vfx.robsanParticles){
                const f = 1 - p.t/p.life;
                const a = f * 0.8;
                const pulse = Math.sin(p.t * 0.01) * 0.3 + 0.7;
                const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3.5);
                g.addColorStop(0,`rgba(68, 10, 107, ${a * pulse})`);
                g.addColorStop(0.5,`rgba(99, 58, 161, ${a * 0.6})`);
                g.addColorStop(1,`rgba(30, 0, 50, 0)`);
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r * pulse,0,Math.PI*2); ctx.fill();
            }

            // Enhanced XDrake earth dust with nature essence
            for(const p of vfx.xdrakeFootworkDust){
                const f = 1 - p.t/p.life;
                const a = f * 0.85;
                const earthPulse = Math.sin(p.t * 0.008) * 0.3 + 0.7;
                const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3.5);
                g.addColorStop(0,`rgba(109, 75, 46, ${a * earthPulse})`);
                g.addColorStop(0.4,`rgba(34, 197, 94, ${a * 0.4})`);
                g.addColorStop(1,`rgba(101, 69, 34, 0)`);
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r * earthPulse,0,Math.PI*2); ctx.fill();
            }

            // Enhanced Gojo Blue orbit particles with infinity shimmer
            for(const p of vfx.gojoBlueOrbitParticles){
                const f = 1 - p.t/p.life;
                const a = f * 0.9;
                const infinityWave = Math.sin(p.t * 0.005) * 0.4 + 0.6;
                const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*4);
                g.addColorStop(0,`rgba(49, 130, 206, ${a * infinityWave})`);
                g.addColorStop(0.3,`rgba(255, 255, 255, ${a * 0.5})`);
                g.addColorStop(1,`rgba(44, 82, 130, 0)`);
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r * infinityWave,0,Math.PI*2); ctx.fill();
            }

            // NEW ANGUS VFX RENDERING
            // Enhanced Angus charging particles - white floating orbs with shimmer
            for (const p of vfx.angusChargeParticles) {
                const f = 1 - p.t/p.life;
                const a = f * 0.9;
                const shimmer = Math.sin(p.t * 0.02) * 0.2 + 0.8;
                const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 3.5);
                g.addColorStop(0, `rgba(255, 255, 255, ${a * shimmer})`);
                g.addColorStop(0.6, `rgba(243, 244, 246, ${a * 0.7})`);
                g.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * shimmer, 0, Math.PI * 2);
                ctx.fill();
            }

            // Burst VFX - massive white explosion
            for (const burst of vfx.angusBurstVFX) {
                const progress = burst.t / burst.life;
                const opacity = Math.sin(progress * Math.PI) * 0.6;
                const radius = burst.radius * (1 + progress * 2);

                ctx.save();
                ctx.translate(burst.x, burst.y);

                // Central white explosion
                const burstGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                burstGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                burstGradient.addColorStop(0.5, `rgba(243, 244, 246, ${opacity * 0.6})`);
                burstGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = burstGradient;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();

                // Radiating lines
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                ctx.lineWidth = 3;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const lineLength = radius * 0.7;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 20, Math.sin(angle) * 20);
                    ctx.lineTo(Math.cos(angle) * lineLength, Math.sin(angle) * lineLength);
                    ctx.stroke();
                }

                ctx.restore();
            }

            if (vfx.angusPuddles) {
for (let i = vfx.angusPuddles.length - 1; i >= 0; i--) {
const p = vfx.angusPuddles[i];
p.t += 30; // deltaTime from your game loop

ctx.save();
ctx.globalAlpha = p.alpha * (1 - p.t / p.life); // fade out gradually
ctx.fillStyle = 'white';
ctx.beginPath();
ctx.ellipse(p.x, p.y, p.radius, p.radius * 0.4, 0, 0, Math.PI * 2);
ctx.fill();
ctx.restore();

if (p.t >= p.life) {
vfx.angusPuddles.splice(i, 1);
}
}
}


            // Time Stop Field - gray time distortion effect
            for (const field of vfx.angusTimeStopField) {
                const progress = field.t / field.life;
                const opacity = Math.sin(progress * Math.PI) * 0.4;
                const radius = field.radius;

                ctx.save();
                ctx.translate(field.x, field.y);

                // Time distortion rings
                for (let i = 0; i < 4; i++) {
                    const ringRadius = radius * (0.3 + i * 0.2);
                    const ringOpacity = opacity * (1 - i * 0.2);

                    ctx.strokeStyle = `rgba(156, 163, 175, ${ringOpacity})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]);
                    ctx.lineDashOffset = -performance.now() * 0.01 * (i + 1);
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                ctx.restore();
            }

            // Teleport Trail - shadow path effect
            for (const trail of vfx.angusTeleportTrail) {
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * 0.7;

                ctx.save();
                ctx.strokeStyle = `rgba(75, 85, 99, ${opacity})`;
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';

                // Draw shadow trail from start to end
                const gradient = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                gradient.addColorStop(0, `rgba(156, 163, 175, ${opacity})`);
                gradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity * 0.8})`);
                gradient.addColorStop(1, `rgba(75, 85, 99, ${opacity})`);
                ctx.strokeStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(trail.startX, trail.startY);
                ctx.lineTo(trail.endX, trail.endY);
                ctx.stroke();

                ctx.restore();
            }

            // NEW LEONARDO VFX (UPGRADED)
            // Focus Shot Text - Double Door Swaying Open Effect
   // Focus Shot Text - Double Door Swaying Open Effect
for (const text of vfx.leonardoFocusText) {
    const progress = text.t / text.life;
    const easeOut = 1 - Math.pow(1 - progress, 3); // Easing function
    const opacity = Math.sin(progress * Math.PI);

    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--leonardo-accent');
    ctx.shadowBlur = 20;
    ctx.font = `bold 32px 'Segoe UI'`; // Adjusted font size for new text

    // "AUTISM" on left, rotating outwards
    ctx.save();
    ctx.translate(text.x - (70 * easeOut), text.y);
    ctx.rotate(-Math.PI / 12 * easeOut);
    ctx.fillStyle = 'black';
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.font = `bold 36px 'Segoe UI'`;
    ctx.strokeText('AUTISM', 0, 0);
    ctx.fillText('AUTISM', 0, 0);
    ctx.restore();

    // "ATTACK" on right, rotating outwards
    ctx.save();
    ctx.translate(text.x + (70 * easeOut), text.y);
    ctx.rotate(Math.PI / 12 * easeOut);
    ctx.fillStyle = 'black';
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.font = `bold 36px 'Segoe UI'`;
    ctx.strokeText('ATTACK', 0, 0);
    ctx.fillText('ATTACK', 0, 0);
    ctx.restore();

    // Add central energy burst effect
    ctx.save();
    ctx.translate(text.x, text.y);
    const burstRadius = 30 * (1 - progress);
    const burstGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, burstRadius);
    burstGradient.addColorStop(0, `rgba(165, 243, 252, ${opacity * 0.8})`);
    burstGradient.addColorStop(1, 'rgba(165, 243, 252, 0)');
    ctx.fillStyle = burstGradient;
    ctx.beginPath();
    ctx.arc(0, 0, burstRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.restore();
}


            // Enhanced Sensory Shield Aura with Multiple Geometric Patterns and Particles
            for (const aura of vfx.leonardoShieldAura) {
                const progress = aura.t / aura.life;
                const opacity = Math.sin(progress * Math.PI) * 0.4;
                const rotation = performance.now() * 0.001;
                const fastRotation = performance.now() * 0.003;

                ctx.save();
                ctx.translate(aura.x, aura.y);

                // Outer shield ring with energy flow
                ctx.strokeStyle = `rgba(6, 182, 212, ${opacity * 0.8})`;
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.lineDashOffset = -performance.now() * 0.05;
                ctx.beginPath();
                ctx.arc(0, 0, aura.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Multiple rotating hexagonal patterns
                for (let layer = 0; layer < 4; layer++) {
                    const radius = aura.radius * (0.3 + layer * 0.15);
                    const layerRotation = rotation * (layer % 2 === 0 ? 1 : -1) * (1 + layer * 0.3);
                    const layerOpacity = opacity * (1 - layer * 0.15);

                    ctx.strokeStyle = `rgba(165, 243, 252, ${layerOpacity})`;
                    ctx.lineWidth = 2 - layer * 0.3;
                    ctx.beginPath();
                    for (let j = 0; j < 6; j++) {
                        const angle = (j * Math.PI / 3) + layerRotation;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }

                // Add floating energy particles around shield
                for (let i = 0; i < 8; i++) {
                    const particleAngle = (i / 8) * Math.PI * 2 + fastRotation;
                    const particleRadius = aura.radius * 0.8 + Math.sin(fastRotation * 2 + i) * 10;
                    const px = Math.cos(particleAngle) * particleRadius;
                    const py = Math.sin(particleAngle) * particleRadius;

                    const particleGradient = ctx.createRadialGradient(px, py, 0, px, py, 8);
                    particleGradient.addColorStop(0, `rgba(165, 243, 252, ${opacity * 0.9})`);
                    particleGradient.addColorStop(1, 'rgba(165, 243, 252, 0)');
                    ctx.fillStyle = particleGradient;
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            // Pattern Weave Dash Trail - Weaving Lines
            if (vfx.leonardoDashTrail.length && player._leonardoDashTrail && player._leonardoDashTrail.length > 1) {
                const trail = player._leonardoDashTrail;
                for (let i = 0; i < trail.length - 1; i++) {
                    const p = trail[i];
                    const n = trail[i + 1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / (LEONARDO_DASH_DURATION + 150), 0, 1);

                    // Weaving line
                    const weaveOffset = Math.sin(i * 0.8 + performance.now() * 0.02) * 10;
                    const perpDir = Math.atan2(n.y - p.y, n.x - p.x) + Math.PI / 2;

                    const x1 = p.x + Math.cos(perpDir) * weaveOffset;
                    const y1 = p.y + Math.sin(perpDir) * weaveOffset;
                    const x2 = n.x + Math.cos(perpDir) * weaveOffset;
                    const y2 = n.y + Math.sin(perpDir) * weaveOffset;

                    const g = ctx.createLinearGradient(x1, y1, x2, y2);
                    g.addColorStop(0, getRGBA(vfx.leonardoDashTrail[0].colorStart, a * 0.9));
                    g.addColorStop(1, getRGBA(vfx.leonardoDashTrail[0].colorEnd, a * 0.6));

                    ctx.strokeStyle = g;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }

            // Enhanced Pattern Field with geometric patterns and energy waves
            for (const field of vfx.leonardoPatternField) {
                const progress = field.t / field.life;
                const opacity = Math.sin(progress * Math.PI) * 0.3;
                const rotation = performance.now() * 0.002;

                ctx.save();
                ctx.translate(field.x, field.y);

                // Main field circle with gradient
                const fieldGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, field.radius);
                fieldGradient.addColorStop(0, `rgba(6, 182, 212, ${opacity * 0.6})`);
                fieldGradient.addColorStop(0.7, `rgba(165, 243, 252, ${opacity * 0.3})`);
                fieldGradient.addColorStop(1, 'rgba(165, 243, 252, 0)');
                ctx.fillStyle = fieldGradient;
                ctx.beginPath();
                ctx.arc(0, 0, field.radius, 0, Math.PI * 2);
                ctx.fill();

                // Geometric pattern grid
                ctx.strokeStyle = `rgba(165, 243, 252, ${opacity * 0.8})`;
                ctx.lineWidth = 1;
                const gridSize = 15;
                const gridCount = Math.floor(field.radius * 2 / gridSize);

                for (let i = -gridCount; i <= gridCount; i++) {
                    for (let j = -gridCount; j <= gridCount; j++) {
                        const x = i * gridSize;
                        const y = j * gridSize;
                        const distance = Math.sqrt(x*x + y*y);

                        if (distance < field.radius) {
                            const nodeOpacity = opacity * (1 - distance / field.radius);
                            ctx.fillStyle = `rgba(165, 243, 252, ${nodeOpacity})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                // Rotating energy rings
                for (let ring = 1; ring <= 3; ring++) {
                    const ringRadius = field.radius * (ring / 4);
                    ctx.strokeStyle = `rgba(6, 182, 212, ${opacity * (1 - ring * 0.2)})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 10]);
                    ctx.lineDashOffset = -performance.now() * 0.02 * ring;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                ctx.restore();
            }

            // NEW LEONARDO PARTICLE RENDERING
            // Leonardo Focus Particles - Enhanced with analytical energy waves
            for(const p of vfx.leonardoFocusParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life; const a = f*0.9;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.98; p.vy*=0.98;
                
                // Outer analytical field
                const fieldRadius = p.r * (6 + Math.sin(p.t * 0.02) * 2);
                const fieldGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, fieldRadius);
                fieldGrad.addColorStop(0, `rgba(6, 182, 212, ${a * 0.3})`);
                fieldGrad.addColorStop(0.4, `${p.color}${a * 0.5})`);
                fieldGrad.addColorStop(0.8, `rgba(165, 243, 252, ${a * 0.2})`);
                fieldGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = fieldGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, fieldRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Core focus particle with geometric precision
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 2);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                coreGrad.addColorStop(0.3, `${p.color}${a})`);
                coreGrad.addColorStop(0.7, `rgba(6, 182, 212, ${a * 0.8})`);
                coreGrad.addColorStop(1, `${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Analytical ring patterns
                if(Math.random() < 0.4) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(165, 243, 252, ${a * 0.7})`;
                    ctx.lineWidth = 1;
                    for(let ring = 1; ring <= 3; ring++) {
                        const ringRadius = p.r * ring * 1.5;
                        ctx.setLineDash([2, 4]);
                        ctx.lineDashOffset = -p.t * 0.05 * ring;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, ringRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                    ctx.restore();
                }
            }
            vfx.leonardoFocusParticles = vfx.leonardoFocusParticles.filter(p=> p.t < p.life);

            // Leonardo Shield Particles - Enhanced with sensory defensive barriers
            for(const p of vfx.leonardoShieldParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life; const a = f*0.8;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.96; p.vy*=0.96;
                
                // Outer defensive aura
                const shieldPulse = Math.sin(p.t * 0.03) * 0.4 + 0.6;
                const shieldGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 4 * shieldPulse);
                shieldGrad.addColorStop(0, `rgba(6, 182, 212, ${a * 0.7})`);
                shieldGrad.addColorStop(0.4, `${p.color}${a * 0.9})`);
                shieldGrad.addColorStop(0.8, `rgba(165, 243, 252, ${a * 0.4})`);
                shieldGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = shieldGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 4 * shieldPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Core shield particle with hexagonal structure
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 2);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.9})`);
                coreGrad.addColorStop(0.3, `${p.color}${a})`);
                coreGrad.addColorStop(0.8, `rgba(6, 182, 212, ${a * 0.7})`);
                coreGrad.addColorStop(1, `${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Hexagonal shield patterns
                if(Math.random() < 0.3) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(165, 243, 252, ${a * 0.8})`;
                    ctx.lineWidth = 2;
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.t * 0.02);
                    
                    // Draw hexagon
                    ctx.beginPath();
                    for(let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const x = Math.cos(angle) * p.r * 3;
                        const y = Math.sin(angle) * p.r * 3;
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
            }
            vfx.leonardoShieldParticles = vfx.leonardoShieldParticles.filter(p=> p.t < p.life);

            // Leonardo Dash Particles - Enhanced with pattern weave energy trails
            for(const p of vfx.leonardoDashParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life; const a = f*0.7;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.94; p.vy*=0.94;
                
                // Outer weave energy field
                const weaveIntensity = Math.sin(p.t * 0.025) * 0.5 + 0.5;
                const weaveGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 5);
                weaveGrad.addColorStop(0, `rgba(165, 243, 252, ${a * weaveIntensity * 0.6})`);
                weaveGrad.addColorStop(0.4, `${p.color}${a * 0.8})`);
                weaveGrad.addColorStop(0.8, `rgba(6, 182, 212, ${a * 0.4})`);
                weaveGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = weaveGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Core dash particle with geometric streaks
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 2.5);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.9})`);
                coreGrad.addColorStop(0.3, `${p.color}${a})`);
                coreGrad.addColorStop(0.7, `rgba(165, 243, 252, ${a * 0.8})`);
                coreGrad.addColorStop(1, `${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Pattern weave streaks
                if(Math.random() < 0.5) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(165, 243, 252, ${a * 0.9})`;
                    ctx.lineWidth = 1.5;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = `rgba(6, 182, 212, ${a})`;
                    
                    for(let streak = 0; streak < 4; streak++) {
                        const angle = (streak / 4) * Math.PI * 2 + p.t * 0.01;
                        const length = p.r * (2 + Math.sin(p.t * 0.03 + streak) * 1);
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x + Math.cos(angle) * length, p.y + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
            vfx.leonardoDashParticles = vfx.leonardoDashParticles.filter(p=> p.t < p.life);

            // NEW ANGUS PARTICLE RENDERING
            // Angus Charge Particles - Enhanced with temporal energy buildup
            for(const p of vfx.angusChargeParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life;
                const a = f * 0.8;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.95; p.vy*=0.95;
                
                // Outer temporal field with pulsing energy
                const temporalPulse = Math.sin(p.t * 0.02) * 0.4 + 0.6;
                const temporalGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 5 * temporalPulse);
                temporalGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.4})`);
                temporalGrad.addColorStop(0.3, `${p.color}${a * 0.7})`);
                temporalGrad.addColorStop(0.7, `rgba(255, 255, 255, ${a * 0.3})`);
                temporalGrad.addColorStop(1, `rgba(255, 255, 255, 0)`);
                ctx.fillStyle = temporalGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 5 * temporalPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Core charge particle with electric intensity
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 3);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                coreGrad.addColorStop(0.4, `${p.color}${a})`);
                coreGrad.addColorStop(0.8, `rgba(255, 255, 255, ${a * 0.7})`);
                coreGrad.addColorStop(1, `rgba(255, 255, 255, 0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Electrical sparks
                if(Math.random() < 0.4) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 255, 255, ${a * 0.9})`;
                    ctx.lineWidth = 1 + Math.random();
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = `${p.color}${a})`;
                    
                    for(let spark = 0; spark < 3; spark++) {
                        const angle = Math.random() * Math.PI * 2;
                        const length = p.r * (1.5 + Math.random() * 2);
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        const endX = p.x + Math.cos(angle) * length;
                        const endY = p.y + Math.sin(angle) * length;
                        ctx.lineTo(endX + (Math.random() - 0.5) * 4, endY + (Math.random() - 0.5) * 4);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
            vfx.angusChargeParticles = vfx.angusChargeParticles.filter(p=> p.t < p.life);

            // Angus Burst VFX - massive white explosion (updated in particles above)
            for (const burst of vfx.angusBurstVFX) {
                burst.t += dt;
            }
            vfx.angusBurstVFX = vfx.angusBurstVFX.filter(b => b.t < b.life);

            // Angus Time Stop Field (updated in particles above)
            for (const field of vfx.angusTimeStopField) {
                field.t += dt;
            }
            vfx.angusTimeStopField = vfx.angusTimeStopField.filter(f => f.t < f.life);

            // Angus Teleport Trail (updated in particles above)
            for (const trail of vfx.angusTeleportTrail) {
                trail.t += dt;
            }
            vfx.angusTeleportTrail = vfx.angusTeleportTrail.filter(t => t.t < t.life);

            for(const p of vfx.eddieWeAreParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life; const a = f*0.8;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9;

            }
            vfx.eddieWeAreParticles = vfx.eddieWeAreParticles.filter(p=> p.t < p.life);

            // Zeus Lightning Particles
            for(const p of vfx.zeusLightningParticles){
                const f = 1 - p.t/p.life; const a = f*0.9;
                const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*4);
                g.addColorStop(0,`${p.color}${a})`);
                g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
            }

            // Zeus Lightning Charge Effect
            for(const p of vfx.zeusLightningChargeEffect){
                const f = 1 - p.t/p.life; const a = f*0.7;
                ctx.fillStyle = `${p.color}${a})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
            }


            // Zeus Heavenly Shield Waves (particles)
            for(const p of vfx.zeusHeavenlyShieldWaves){
                const f = 1 - p.t/p.life; const a = f*0.7;
                const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3);
                g.addColorStop(0,`${p.color}${a})`);
                g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
            }




            // Zeus Olympus Fury Pull Lines
            for(const line of vfx.zeusOlympusFuryPullLines){
                const progress = line.t / line.life;
                const opacity = (1 - progress) * 0.8;
                const currentX = lerp(line.startX, line.endX, progress);
                const currentY = lerp(line.startY, line.endY, progress);
                const length = lerp(0, Math.hypot(line.endX - line.startX, line.endY - line.startY), progress);
                const angle = Math.atan2(line.endY - line.startY, line.endX - line.startX);

                ctx.save();
                ctx.translate(currentX, currentY);
                ctx.rotate(angle);
                ctx.strokeStyle = `${line.color}${opacity})`;
                ctx.lineWidth = line.thickness * (1 - progress * 0.5);
                ctx.beginPath();
                ctx.moveTo(-length/2, 0);
                ctx.lineTo(length/2, 0);
                ctx.stroke();
                ctx.restore();
            }

            vfx.robsanChargeAura = vfx.robsanChargeAura.filter(a=> (a.t+=dt) < a.life);

            vfx.eclipseAura = vfx.eclipseAura.filter(a=> (a.t+=dt) < a.life);

            // Draw Eclipse Lines (Robsan's Eclipse Grasp VFX)
            for(const line of vfx.eclipseLines){
                const totalProgress = line.t / line.life;
                if (totalProgress > 1) continue;

                let lineStartX, lineStartY, lineEndX, lineEndY, opacity, lineWidth;
                const rootStyle = getComputedStyle(document.documentElement);
                const color1 = rootStyle.getPropertyValue('--eclipse-line-color').trim();
                const color2 = rootStyle.getPropertyValue('--eclipse-line-glow').trim();

                if (line.phase === 'extending') {
                    // Line extends from player to ball
                    const extendProgress = line.t / line.extendDuration;
                    lineStartX = line.startX;
                    lineStartY = line.startY;
                    lineEndX = lerp(line.startX, line.endX, Math.min(extendProgress, 1));
                    lineEndY = lerp(line.startY, line.endY, Math.min(extendProgress, 1));
                    opacity = Math.min(extendProgress * 2, 1); // Fade in quickly
                    lineWidth = 6 * Math.min(extendProgress * 1.5, 1);
                } else {
                    // Line retracts back to player
                    const retractProgress = (line.t - line.extendDuration) / line.retractDuration;
                    lineStartX = lerp(line.endX, line.startX, Math.min(retractProgress, 1));
                    lineStartY = lerp(line.endY, line.startY, Math.min(retractProgress, 1));
                    lineEndX = line.startX;
                    lineEndY = line.startY;
                    opacity = (1 - retractProgress) * 0.9; // Fade out as it retracts
                    lineWidth = 6 * (1 - retractProgress * 0.5);
                }

                const dx = lineEndX - lineStartX;
                const dy = lineEndY - lineStartY;
                const dist = Math.hypot(dx, dy);

                if (dist < 1) continue; // Skip if line is too short

                const angle = Math.atan2(dy, dx);

                ctx.save();
                ctx.translate(lineStartX, lineStartY);
                ctx.rotate(angle);

                const segments = Math.max(Math.floor(dist / 8), 1);
                ctx.beginPath();
                ctx.moveTo(0, 0);

                for (let i = 0; i <= segments; i++) {
                    const segmentProgress = i / segments;
                    const x = segmentProgress * dist;
                    const wiggleOffset = Math.sin(segmentProgress * Math.PI * line.wiggleFreq + performance.now() * 0.03) * line.wiggleAmp * opacity;
                    ctx.lineTo(x, wiggleOffset);
                }

                ctx.strokeStyle = getRGBA(color1, opacity);
                ctx.lineWidth = lineWidth;
                ctx.shadowBlur = 15 * opacity;
                ctx.shadowColor = getRGBA(color2, opacity * 0.8);
                ctx.stroke();

                ctx.restore();
            }

            vfx.xdrakeApexAura = vfx.xdrakeApexAura.filter(a=> (a.t+=dt) < a.life);

            vfx.gojoPurpleCombineVFX = vfx.gojoPurpleCombineVFX.filter(v=> (v.t+=dt) < v.life);


            for(const aura of vfx.eddieWeAreAura){
                const progress = aura.t / aura.life;
                const currentRadius = lerp(aura.radius * 0.5, aura.radius * 2, progress);
                const opacity = (1 - progress) * 0.7;

                const grd = ctx.createRadialGradient(aura.x, aura.y, aura.radius * 0.5, aura.x, aura.y, currentRadius);
                grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-we-are-aura').trim(), opacity * 0.8));
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(aura.x, aura.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Zeus Heavenly Shield Aura
            vfx.zeusHeavenlyShieldAura = vfx.zeusHeavenlyShieldAura.filter(a => (a.t+=dt) < a.life);

            // Zeus Olympus Fury Aura
            vfx.zeusOlympusFuryAura = vfx.zeusOlympusFuryAura.filter(a => (a.t+=dt) < a.life);

            for(const line of vfx.eddieVenomTendrils){
                const progress = line.t / line.life;
                if (progress > 1) continue;

                const startX = line.startX;
                const startY = line.startY;
                const endX = line.endX; // Use updated endX, endY
                const endY = line.endY; // Use updated endX, endY

                const dist = Math.hypot(endX - startX, endY - startY);
                const angle = Math.atan2(endY - startY, endX - startX);

                ctx.save();
                ctx.translate(startX, startY);
                ctx.rotate(angle);

                const segments = Math.floor(dist / 10) || 1; // Ensure at least one segment
                ctx.beginPath();
                ctx.moveTo(0, 0);

                for (let i = 0; i <= segments; i++) {
                    const segmentProgress = i / segments;
                    const x = segmentProgress * dist;
                    const wiggleOffset = Math.sin(segmentProgress * Math.PI * line.wiggleFreq + performance.now() * 0.02) * line.wiggleAmp * (1 - progress);
                    ctx.lineTo(x, wiggleOffset);
                }

                ctx.strokeStyle = getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-tendril-start').trim(), 0.9 * (1 - progress));
                ctx.lineWidth = 6 * (1 - progress); // Thicker line
                ctx.shadowBlur = 20 * (1 - progress); // More glow
                ctx.shadowColor = getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-glow').trim(), 0.8 * (1 - progress)); // Brighter glow color
                ctx.stroke();

                ctx.restore();
            }
            for(const puddle of vfx.blackPuddles){
                const f = 1 - puddle.t/puddle.life;
                const a = f * 0.6; // Fade out opacity
                const r = puddle.r * (1 + (puddle.t / puddle.life) * 0.5); // Grow slightly

                ctx.fillStyle = `${puddle.color}${a})`;
                ctx.beginPath();
                ctx.arc(puddle.x, puddle.y, r, 0, Math.PI * 2);
                ctx.fill();
            }


            // Draw Robsan Ground Rupture
            for(const rupture of vfx.robsanGroundRupture){
                const progress = rupture.t / rupture.life;
                const opacity = (1 - progress) * 0.8;
                const length = rupture.length * (1 + progress);
                const width = rupture.width * (1 - progress * 0.5);

                ctx.save();
                ctx.translate(rupture.x, rupture.y);
                ctx.rotate(rupture.dir);
                ctx.strokeStyle = `${rupture.color}${opacity})`;
                ctx.lineWidth = width;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(-length / 2, 0);
                ctx.lineTo(length / 2, 0);
                ctx.stroke();
                ctx.restore();
            }

            // Draw Robsan Eclipse Wisps
            for(const wisp of vfx.robsanEclipseWisps){
                const f = 1 - wisp.t/wisp.life; const a = f*0.6;
                ctx.fillStyle = `${wisp.color}${a})`;
                ctx.beginPath(); ctx.arc(wisp.x, wisp.y, wisp.r, 0, Math.PI*2); ctx.fill();
            }

            // Draw Robsan Void Puffs
            for(const puff of vfx.robsanVoidPuffs){
                const progress = puff.t / puff.life;
                const opacity = (1 - progress) * 0.7;
                const radius = puff.r * (1 + progress);

                ctx.fillStyle = `${puff.color}${opacity})`;
                ctx.beginPath();
                ctx.arc(puff.x, puff.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw XDrake Supernova Ground Crack
            for(const crack of vfx.xdrakeSupernovaGroundCrack){
                const progress = crack.t / crack.life;
                const opacity = (1 - progress) * 0.5;
                const size = crack.size * (1 + progress * 0.5);

                ctx.fillStyle = `${crack.color}${opacity})`;
                ctx.beginPath();
                ctx.arc(crack.x, crack.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw XDrake Footwork Leaves
            for(const leaf of vfx.xdrakeFootworkLeaves){
                const f = 1 - leaf.t/leaf.life; const a = f*0.8;
                ctx.fillStyle = `${leaf.color}${a})`;
                ctx.beginPath(); ctx.ellipse(leaf.x, leaf.y, leaf.r * 1.5, leaf.r * 0.8, leaf.vx > 0 ? 0.3 : -0.3, 0, Math.PI*2); ctx.fill();
            }

            // Draw XDrake Ancient Apex Ground Burst - Enhanced
            for(const burst of vfx.xdrakeAncientApexGroundBurst){
                const f = 1 - burst.t/burst.life; 
                const a = f * 0.9;
                const earthPulse = Math.sin(burst.t * 0.05) * 0.4 + 0.6;
                const currentRadius = burst.r * earthPulse;
                
                ctx.save();
                
                // Outer earth shockwave
                ctx.shadowBlur = 25;
                ctx.shadowColor = 'rgba(139, 69, 19, 0.8)'; // Brown earth color
                const outerGrad = ctx.createRadialGradient(burst.x, burst.y, 0, burst.x, burst.y, currentRadius * 2);
                outerGrad.addColorStop(0, `rgba(160, 82, 45, ${a * 0.8})`); // Saddle brown
                outerGrad.addColorStop(0.5, `${burst.color}${a * 0.6})`);
                outerGrad.addColorStop(1, 'rgba(139, 69, 19, 0)');
                ctx.fillStyle = outerGrad;
                ctx.beginPath();
                ctx.arc(burst.x, burst.y, currentRadius * 1.8, 0, Math.PI * 2);
                ctx.fill();
                
                // Main earth core
                ctx.shadowBlur = 15;
                const coreGrad = ctx.createRadialGradient(burst.x, burst.y, 0, burst.x, burst.y, currentRadius);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.6})`);
                coreGrad.addColorStop(0.4, `${burst.color}${a})`);
                coreGrad.addColorStop(1, `rgba(101, 67, 33, 0)`); // Dark brown fade
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(burst.x, burst.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Earth debris particles
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI * 2 * i / 4) + burst.t * 0.01;
                    const debrisRadius = currentRadius * 1.3;
                    const debrisX = burst.x + Math.cos(angle) * debrisRadius;
                    const debrisY = burst.y + Math.sin(angle) * debrisRadius;
                    const debrisSize = 2 * f;
                    
                    ctx.fillStyle = `rgba(139, 69, 19, ${a * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(debrisX, debrisY, debrisSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            // Draw Gojo Red Explosion - Enhanced
            for(const exp of vfx.gojoRedExplosion){
                const progress = exp.t / exp.life;
                const opacity = (1 - progress) * 0.9;
                const radius = exp.radius * (1 + progress * 2);
                const pulseIntensity = 1 + Math.sin(exp.t * 0.1) * 0.3;

                ctx.save();
                
                // Outer cursed energy shockwave
                ctx.shadowBlur = 35;
                ctx.shadowColor = 'rgba(229, 62, 62, 0.9)';
                const outerGrad = ctx.createRadialGradient(exp.x, exp.y, 0, exp.x, exp.y, radius * 2 * pulseIntensity);
                outerGrad.addColorStop(0, `rgba(255, 100, 100, ${opacity * 0.4})`);
                outerGrad.addColorStop(0.3, `${exp.color}${opacity * 0.7})`);
                outerGrad.addColorStop(0.7, `rgba(139, 0, 0, ${opacity * 0.4})`); // Dark red
                outerGrad.addColorStop(1, 'rgba(139, 0, 0, 0)');
                ctx.fillStyle = outerGrad;
                ctx.beginPath();
                ctx.arc(exp.x, exp.y, radius * 1.8, 0, Math.PI * 2);
                ctx.fill();
                
                // Main red explosion core
                ctx.shadowBlur = 25;
                const coreGrad = ctx.createRadialGradient(exp.x, exp.y, 0, exp.x, exp.y, radius);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.8})`);
                coreGrad.addColorStop(0.4, `${exp.color}${opacity})`);
                coreGrad.addColorStop(1, `${exp.color.split(',')[0]},${exp.color.split(',')[1]},${exp.color.split(',')[2]},0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(exp.x, exp.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Cursed energy lightning bolts
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                ctx.lineWidth = 3 * (1 - progress);
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i / 8) + exp.t * 0.02;
                    const boltLength = radius * (1.2 + Math.sin(exp.t * 0.07 + i) * 0.4);
                    const midX = exp.x + Math.cos(angle) * boltLength * 0.6;
                    const midY = exp.y + Math.sin(angle) * boltLength * 0.6;
                    const endX = exp.x + Math.cos(angle) * boltLength;
                    const endY = exp.y + Math.sin(angle) * boltLength;
                    
                    ctx.beginPath();
                    ctx.moveTo(exp.x, exp.y);
                    ctx.quadraticCurveTo(
                        midX + (Math.random() - 0.5) * 20, 
                        midY + (Math.random() - 0.5) * 20, 
                        endX, endY
                    );
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            // Draw Gojo Lapse Blue Pull Effect
            for(const p of vfx.gojoLapseBluePullEffect){
                const f = 1 - p.t/p.life; const a = f*0.7;
                ctx.fillStyle = `${p.color}${a})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
            }

            // Draw Gojo Purple Arcs
            for(const arc of vfx.gojoPurpleArcs){
                const progress = arc.t / arc.life;
                const opacity = (1 - progress) * 0.9;
                const currentRadius = arc.radius * (1 + progress * 2);

                ctx.strokeStyle = `${arc.color}${opacity})`;
                ctx.lineWidth = 3 * (1 - progress * 0.5);
                ctx.beginPath();
                ctx.arc(arc.x, arc.y, currentRadius, arc.initialAngle, arc.initialAngle + Math.PI / 4 * (1 - progress));
                ctx.stroke();
            }

            // Draw Eddie We Are Ripples
            for(const ripple of vfx.eddieWeAreRipples){
                const progress = ripple.t / ripple.life;
                const opacity = (1 - progress) * 0.5;
                const radius = lerp(ripple.initialRadius, ripple.maxRadius, progress);

                ctx.strokeStyle = `${ripple.color}${opacity})`;
                ctx.lineWidth = 2 * (1 - progress);
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw Eddie Venom Ball Swirl - Enhanced with multi-layer symbiote effects
            for(const p of vfx.eddieVenomBallSwirl){
                const f = 1 - p.t/p.life; const a = f*0.7;
                
                // Outer glow ring
                const outerGlow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 3);
                outerGlow.addColorStop(0, `${p.color}${a * 0.4})`);
                outerGlow.addColorStop(0.5, `${p.color}${a * 0.2})`);
                outerGlow.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Core venom blob with pulsing
                const pulse = Math.sin(p.t * 0.02) * 0.3 + 0.7;
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * pulse);
                coreGrad.addColorStop(0, `rgba(20, 20, 20, ${a})`);
                coreGrad.addColorStop(0.7, `${p.color}${a * 0.9})`);
                coreGrad.addColorStop(1, `rgba(0, 0, 0, ${a * 0.3})`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Symbiote tendrils
                if(Math.random() < 0.3) {
                    ctx.save();
                    ctx.strokeStyle = `${p.color}${a * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `${p.color}${a * 0.8})`;
                    for(let i = 0; i < 3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const length = p.r * (1.5 + Math.random() * 2);
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x + Math.cos(angle) * length, p.y + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            // Draw Eddie Teleport Flicker - Enhanced with dimensional rifts
            for(const flicker of vfx.eddieTeleportFlicker){
                const progress = flicker.t / flicker.life;
                const opacity = Math.sin(progress * Math.PI) * 0.8; // Pulsate opacity
                const radius = flicker.radius * (1 + progress * 0.2);

                // Outer dimensional rift
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                const riftGrad = ctx.createRadialGradient(flicker.x, flicker.y, 0, flicker.x, flicker.y, radius * 2);
                riftGrad.addColorStop(0, `rgba(139, 69, 19, ${opacity * 0.3})`); // Dark brown
                riftGrad.addColorStop(0.3, `rgba(20, 20, 20, ${opacity * 0.5})`); // Black venom
                riftGrad.addColorStop(0.7, `${flicker.color}${opacity * 0.4})`);
                riftGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = riftGrad;
                ctx.beginPath();
                ctx.arc(flicker.x, flicker.y, radius * 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // Multiple flickering layers
                for(let layer = 0; layer < 3; layer++) {
                    const layerOpacity = opacity * (0.8 - layer * 0.2);
                    const layerRadius = radius * (1 - layer * 0.2);
                    const flicker_intensity = Math.sin((progress + layer * 0.3) * Math.PI * 4) * 0.5 + 0.5;
                    
                    const grd = ctx.createRadialGradient(flicker.x, flicker.y, 0, flicker.x, flicker.y, layerRadius);
                    grd.addColorStop(0, `${flicker.color}${layerOpacity * flicker_intensity})`);
                    grd.addColorStop(0.5, `rgba(20, 20, 20, ${layerOpacity * 0.8 * flicker_intensity})`);
                    grd.addColorStop(1, `${flicker.color.split(',')[0]},${flicker.color.split(',')[1]},${flicker.color.split(',')[2]},0)`);
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(flicker.x, flicker.y, layerRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Symbiote lightning crackling
                if(Math.random() < 0.4) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
                    ctx.lineWidth = 1 + Math.random() * 2;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = `${flicker.color}${opacity})`;
                    for(let i = 0; i < 4; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const length = radius * (0.8 + Math.random() * 0.4);
                        ctx.beginPath();
                        ctx.moveTo(flicker.x, flicker.y);
                        const endX = flicker.x + Math.cos(angle) * length;
                        const endY = flicker.y + Math.sin(angle) * length;
                        ctx.lineTo(endX + (Math.random() - 0.5) * 10, endY + (Math.random() - 0.5) * 10);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            // Draw Enhanced VFX

            // Hudson Speed Lines - Enhanced
            for(const line of vfx.hudsonSpeedLines) {
                const progress = line.t / line.life;
                const opacity = (1 - progress) * 0.9;
                const currentLength = line.length * (1 + progress * 2);

                ctx.save();
                ctx.translate(line.x, line.y);
                ctx.rotate(line.dir);
                
                // Main speed line with glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = `${line.color}1)`;
                ctx.strokeStyle = `${line.color}${opacity})`;
                ctx.lineWidth = 4 * (1 - progress * 0.3);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(currentLength, 0);
                ctx.stroke();
                
                // Inner bright core
                ctx.shadowBlur = 8;
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                ctx.lineWidth = 2 * (1 - progress * 0.3);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(currentLength, 0);
                ctx.stroke();
                
                // Trailing sparkles
                for (let i = 0; i < 3; i++) {
                    const sparklePos = (currentLength * (0.3 + i * 0.2));
                    const sparkleSize = (2 + Math.sin(line.t * 0.01 + i) * 1) * (1 - progress);
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(sparklePos, Math.sin(line.t * 0.02 + i) * 2, sparkleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            // Hudson Energy Waves - Enhanced
            for(const wave of vfx.hudsonEnergyWaves) {
                const progress = wave.t / wave.life;
                const opacity = (1 - progress) * 0.8;
                const radius = lerp(wave.initialRadius, wave.maxRadius, progress);
                const pulseEffect = 1 + Math.sin(wave.t * 0.05) * 0.2;

                ctx.save();
                
                // Outer glow ring
                ctx.shadowBlur = 25;
                ctx.shadowColor = `${wave.color}0.8)`;
                ctx.strokeStyle = `${wave.color}${opacity * 0.6})`;
                ctx.lineWidth = 8 * (1 - progress * 0.5) * pulseEffect;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius * 1.2, 0, Math.PI * 2);
                ctx.stroke();
                
                // Main energy ring
                ctx.shadowBlur = 15;
                ctx.strokeStyle = `${wave.color}${opacity})`;
                ctx.lineWidth = 5 * (1 - progress * 0.3);
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner bright core
                ctx.shadowBlur = 8;
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();
                
                // Energy crackling effects
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 * i / 6) + wave.t * 0.01;
                    const crackleRadius = radius + Math.sin(wave.t * 0.03 + i) * 10;
                    const crackleX = wave.x + Math.cos(angle) * crackleRadius;
                    const crackleY = wave.y + Math.sin(angle) * crackleRadius;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(crackleX, crackleY, 2 * (1 - progress), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            // Hudson Emperor Dribble Trail
            for(const trail of vfx.hudsonEmperorDribbleTrail) {
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * 0.8;
                const size = trail.width * (1 - progress * 0.3);

                ctx.fillStyle = `${trail.color.replace(')', `, ${opacity})`)}`;
                ctx.beginPath();
                ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Hudson Emperor Dribble Particles
            for(const particle of vfx.hudsonEmperorDribbleParticles) {
                const progress = particle.t / particle.life;
                const opacity = (1 - progress) * 0.9;
                const size = particle.r * (1 + progress * 0.2);

                ctx.fillStyle = `${particle.color.replace('0.8', opacity.toString())}`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Hudson Emperor Dribble Aura
            for(const aura of vfx.hudsonEmperorDribbleAura) {
                const progress = aura.t / aura.life;
                const opacity = (1 - progress) * 0.4;
                const radius = aura.radius * (1 + progress * 0.5);

                const grd = ctx.createRadialGradient(aura.x, aura.y, 0, aura.x, aura.y, radius);
                grd.addColorStop(0, `rgba(200, 50, 150, ${opacity})`);
                grd.addColorStop(1, `rgba(150, 100, 200, 0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(aura.x, aura.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Robsan Shadow Clones
            for(const clone of vfx.robsanShadowClones) {
                const progress = clone.t / clone.life;
                const opacity = (1 - progress) * clone.opacity;

                ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                ctx.beginPath();
                ctx.arc(clone.x, clone.y, clone.r, 0, Math.PI * 2);
                ctx.fill();
            }

            // Robsan Void Rifts
            for(const rift of vfx.robsanVoidRifts) {
                const progress = rift.t / rift.life;
                const opacity = (1 - progress) * 0.8;
                const width = lerp(rift.width, rift.maxWidth, progress);

                ctx.fillStyle = `${rift.color}${opacity})`;
                ctx.fillRect(rift.x - width/2, rift.y - rift.height/2, width, rift.height);
            }

            // XDrake Nature Spirits
            for(const spirit of vfx.xdrakeNatureSpirits) {
                const f = 1 - spirit.t / spirit.life;
                const a = f * 0.8;
                ctx.fillStyle = `${spirit.color}${a})`;
                ctx.beginPath();
                ctx.arc(spirit.x, spirit.y, spirit.r, 0, Math.PI * 2);
                ctx.fill();
            }

            // XDrake Terraforms
            for(const terra of vfx.xdrakeTerraforms) {
                const progress = terra.t / terra.life;
                const opacity = (1 - progress) * 0.7;
                const height = terra.height * (1 + progress * 0.5);

                ctx.fillStyle = `${terra.color}${opacity})`;
                ctx.fillRect(terra.x - 5, terra.y - height, 10, height);
            }

            // Gojo Infinity Barriers
            for(const barrier of vfx.gojoInfinityBarriers) {
                const progress = barrier.t / barrier.life;
                const opacity = (1 - progress) * 0.6;

                ctx.save();
                ctx.translate(barrier.x, barrier.y);
                ctx.rotate(barrier.angle + progress * Math.PI);
                ctx.strokeStyle = `${barrier.color}${opacity})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-barrier.length/2, 0);
                ctx.lineTo(barrier.length/2, 0);
                ctx.stroke();
                ctx.restore();
            }

            // Gojo Domain Expansions
            for(const domain of vfx.gojoDomainExpansions) {
                const progress = domain.t / domain.life;
                const opacity = (1 - progress) * domain.intensity * 0.3;
                const radius = lerp(domain.initialRadius, domain.maxRadius, progress);

                const grd = ctx.createRadialGradient(domain.x, domain.y, 0, domain.x, domain.y, radius);
                grd.addColorStop(0, `${domain.color}${opacity})`);
                grd.addColorStop(1, `${domain.color.split(',')[0]},${domain.color.split(',')[1]},${domain.color.split(',')[2]},0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(domain.x, domain.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Eddie Symbiote Spikes
            for(const spike of vfx.eddieSymbioteSpikes) {
                const progress = spike.t / spike.life;
                const opacity = (1 - progress) * 0.8;
                const length = spike.length * (1 + progress);

                ctx.save();
                ctx.translate(spike.x, spike.y);
                ctx.rotate(spike.dir);
                ctx.strokeStyle = `${spike.color}${opacity})`;
                ctx.lineWidth = 4 * (1 - progress * 0.5);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(length, 0);
                ctx.stroke();
                ctx.restore();
            }

            // Eddie Venom Drops - Enhanced with dripping symbiote effects
            for(const drop of vfx.eddieVenomDrops) {
                const f = 1 - drop.t / drop.life;
                const a = f * 0.8;
                
                // Outer splash effect
                const splashRadius = drop.r * (2 + Math.sin(drop.t * 0.03) * 0.5);
                const splashGrad = ctx.createRadialGradient(drop.x, drop.y, 0, drop.x, drop.y, splashRadius);
                splashGrad.addColorStop(0, `rgba(0, 0, 0, ${a * 0.3})`);
                splashGrad.addColorStop(0.4, `${drop.color}${a * 0.5})`);
                splashGrad.addColorStop(0.8, `rgba(20, 20, 20, ${a * 0.2})`);
                splashGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = splashGrad;
                ctx.beginPath();
                ctx.arc(drop.x, drop.y, splashRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Core venom drop with gradient
                const coreGrad = ctx.createRadialGradient(drop.x, drop.y - drop.r * 0.3, 0, drop.x, drop.y, drop.r);
                coreGrad.addColorStop(0, `rgba(40, 40, 40, ${a})`);
                coreGrad.addColorStop(0.3, `${drop.color}${a})`);
                coreGrad.addColorStop(0.8, `rgba(20, 20, 20, ${a * 0.9})`);
                coreGrad.addColorStop(1, `rgba(0, 0, 0, ${a * 0.7})`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(drop.x, drop.y, drop.r, 0, Math.PI * 2);
                ctx.fill();
                
                // Highlight shine
                const shineGrad = ctx.createRadialGradient(drop.x - drop.r * 0.3, drop.y - drop.r * 0.3, 0, drop.x, drop.y, drop.r * 0.6);
                shineGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.4})`);
                shineGrad.addColorStop(0.5, `rgba(128, 128, 128, ${a * 0.2})`);
                shineGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = shineGrad;
                ctx.beginPath();
                ctx.arc(drop.x - drop.r * 0.2, drop.y - drop.r * 0.2, drop.r * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Dripping effect
                if(drop.vy > 0) { // Only for falling drops
                    ctx.save();
                    ctx.fillStyle = `${drop.color}${a * 0.6})`;
                    ctx.beginPath();
                    ctx.ellipse(drop.x, drop.y + drop.r * 0.8, drop.r * 0.3, drop.r * 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Zeus Thunder Clouds - Enhanced with divine storm effects
            for(const cloud of vfx.zeusThunderClouds) {
                const progress = cloud.t / cloud.life;
                const opacity = (1 - progress) * cloud.opacity;
                const storm_pulse = Math.sin(cloud.t * 0.015) * 0.4 + 0.6;
                
                // Outer storm aura
                const stormGrad = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.r * 2.5);
                stormGrad.addColorStop(0, `rgba(70, 70, 90, ${opacity * 0.3})`);
                stormGrad.addColorStop(0.4, `${cloud.color}${opacity * 0.6})`);
                stormGrad.addColorStop(0.7, `rgba(30, 30, 50, ${opacity * 0.4})`);
                stormGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = stormGrad;
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.r * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Main thunder cloud with billowing effect
                const cloudGrad = ctx.createRadialGradient(cloud.x - cloud.r * 0.3, cloud.y - cloud.r * 0.3, 0, cloud.x, cloud.y, cloud.r * storm_pulse);
                cloudGrad.addColorStop(0, `rgba(200, 200, 255, ${opacity * 0.8})`);
                cloudGrad.addColorStop(0.3, `${cloud.color}${opacity})`);
                cloudGrad.addColorStop(0.7, `rgba(40, 40, 60, ${opacity * 0.9})`);
                cloudGrad.addColorStop(1, `rgba(20, 20, 30, ${opacity * 0.7})`);
                ctx.fillStyle = cloudGrad;
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.r * storm_pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Lightning flashes within cloud
                if(Math.random() < 0.2) {
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `rgba(255, 255, 255, ${opacity})`;
                    for(let i = 0; i < 3; i++) {
                        const flashX = cloud.x + (Math.random() - 0.5) * cloud.r * 1.5;
                        const flashY = cloud.y + (Math.random() - 0.5) * cloud.r * 1.5;
                        ctx.beginPath();
                        ctx.arc(flashX, flashY, 2 + Math.random() * 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
            }

            // Zeus Lightning Bolts - Enhanced with divine electrical fury
            for(const bolt of vfx.zeusLightningBolts) {
                const progress = bolt.t / bolt.life;
                const opacity = (1 - progress) * 0.9;
                const electrical_pulse = Math.sin(bolt.t * 0.1) * 0.5 + 0.5;
                
                // Outer electrical field
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(135, 206, 250, ${opacity * 0.4})`; // Light blue glow
                ctx.lineWidth = bolt.thickness * 3 * electrical_pulse;
                ctx.shadowBlur = 25;
                ctx.shadowColor = `rgba(255, 255, 255, ${opacity * 0.6})`;
                
                for(const segment of bolt.segments) {
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y);
                    ctx.lineTo(segment.x2, segment.y2);
                    ctx.stroke();
                }
                ctx.restore();
                
                // Main lightning core with crackling
                ctx.save();
                ctx.strokeStyle = `${bolt.color}${opacity})`;
                ctx.lineWidth = bolt.thickness * (1 - progress * 0.5) * electrical_pulse;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(255, 255, 255, ${opacity})`;

                for(const segment of bolt.segments) {
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y);
                    ctx.lineTo(segment.x2, segment.y2);
                    ctx.stroke();
                    
                    // Add crackling branches
                    if(Math.random() < 0.3) {
                        const midX = (segment.x + segment.x2) / 2;
                        const midY = (segment.y + segment.y2) / 2;
                        const branchAngle = Math.random() * Math.PI * 2;
                        const branchLength = bolt.thickness * (2 + Math.random() * 3);
                        
                        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                        ctx.lineWidth = bolt.thickness * 0.3;
                        ctx.beginPath();
                        ctx.moveTo(midX, midY);
                        ctx.lineTo(midX + Math.cos(branchAngle) * branchLength, 
                                  midY + Math.sin(branchAngle) * branchLength);
                        ctx.stroke();
                    }
                }
                
                // Inner white hot core
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                ctx.lineWidth = bolt.thickness * 0.3;
                ctx.shadowBlur = 8;
                ctx.shadowColor = `rgba(200, 200, 255, ${opacity})`;
                
                for(const segment of bolt.segments) {
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y);
                    ctx.lineTo(segment.x2, segment.y2);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // SAJA-JIN Demonic Aura
// === SAJA-JIN ULTIMATE VFX PACK ===

for (const aura of vfx.sajaJinDemonicAura) {
const progress = aura.t / aura.life;
const opacity = (1 - progress) * 0.9;
const pulse = Math.sin(progress * Math.PI * 12) * 0.3; // Stronger pulse
const currentRadius = aura.radius * (1 + pulse);

const x = aura.followPlayer ? player.x : aura.x;
const y = aura.followPlayer ? player.y : aura.y;

const grd = ctx.createRadialGradient(x, y, 0, x, y, currentRadius);
grd.addColorStop(0, `rgba(255, 69, 0, ${opacity * 0.9})`);     // Fiery core (orange-red)
grd.addColorStop(0.4, `rgba(139, 0, 139, ${opacity * 0.6})`);  // Deep magenta
grd.addColorStop(0.8, `rgba(75, 0, 130, ${opacity * 0.3})`);   // Indigo fade
grd.addColorStop(1, 'rgba(0, 0, 0, 0)');                       // Fade out
ctx.globalCompositeOperation = 'lighter';
ctx.fillStyle = grd;
ctx.beginPath();
ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
ctx.fill();

// Extra sparks flying out
for (let i = 0; i < 3; i++) {
const angle = Math.random() * Math.PI * 2;
const dist = currentRadius * Math.random();
const px = x + Math.cos(angle) * dist;
const py = y + Math.sin(angle) * dist;
ctx.fillStyle = `rgba(255, 215, 0, ${opacity * 0.5})`; // Gold spark
ctx.beginPath();
ctx.arc(px, py, 2 + Math.random() * 2, 0, Math.PI * 2);
ctx.fill();
}
}

// SAJA-JIN Soul Trail — Now with shimmer
for (const trail of vfx.sajaJinSoulTrail) {
if (performance.now() <= trail.end) {
const progress = (now - (trail.end - 3000)) / 3000;
const opacity = Math.max(0, 1 - progress);

ctx.save();
ctx.globalCompositeOperation = 'screen';
ctx.strokeStyle = `rgba(${100 + Math.sin(progress * 5) * 50}, 149, 237, ${opacity * 0.9})`;
ctx.lineWidth = trail.w * (1.2 - progress * 0.3);
ctx.shadowBlur = 25;
ctx.shadowColor = `rgba(173, 216, 230, ${opacity * 0.8})`;

ctx.beginPath();
const trailLength = 120;
for (let i = 0; i < trailLength; i++) {
const t = i / trailLength;
const waveOffset = Math.sin(progress * Math.PI * 6 + t * Math.PI * 3) * 10;
const x = ball.x - ball.vx * t * 0.7 + waveOffset;
const y = ball.y - ball.vy * t * 0.7 + Math.cos(t * Math.PI * 4) * 6;
if (i === 0) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
}
ctx.stroke();
ctx.restore();
}
}

// SAJA-JIN Soul Particles — Add orbiting flickers
for (const particle of vfx.sajaJinSoulParticles) {
const progress = particle.t / particle.life;
const opacity = (1 - progress) * 0.8;

particle.x += particle.vx;
particle.y += particle.vy;
particle.vx *= 0.96;
particle.vy *= 0.96;

const flicker = Math.sin(progress * Math.PI * 10) * 0.2 + 1;
const grd = ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.size * flicker);
grd.addColorStop(0, `rgba(173, 216, 230, ${opacity})`);
grd.addColorStop(0.5, `rgba(138, 43, 226, ${opacity * 0.7})`);
grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
ctx.globalCompositeOperation = 'lighter';
ctx.fillStyle = grd;
ctx.beginPath();
ctx.arc(particle.x, particle.y, particle.size * flicker, 0, Math.PI * 2);
ctx.fill();
}

// SAJA-JIN Hypnotic Glow — Enhanced with multi-layered hypnotic patterns
for (const glow of vfx.sajaJinHypnoticGlow) {
    const progress = glow.t / glow.life;
    const opacity = (1 - progress) * 0.8;
    
    // Validation check for finite values
    if (!isFinite(glow.x) || !isFinite(glow.y) || !isFinite(glow.radius) || 
        !isFinite(progress) || !isFinite(opacity) || glow.radius <= 0) {
        continue;
    }
    
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    
    if (glow.type === 'pulse_ring') {
        // Expanding hypnotic rings
        const ringRadius = glow.radius * progress * 2;
        const ringOpacity = opacity * (1 - progress) * 0.6;
        
        // Validate ring values
        if (!isFinite(ringRadius) || !isFinite(ringOpacity) || ringRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        for (let ring = 0; ring < 3; ring++) {
            const currentRadius = ringRadius + (ring * 15);
            const ringGrd = ctx.createRadialGradient(glow.x, glow.y, currentRadius * 0.7, glow.x, glow.y, currentRadius);
            ringGrd.addColorStop(0, 'rgba(0, 0, 0, 0)');
            ringGrd.addColorStop(0.8, `rgba(168, 85, 247, ${ringOpacity * (1 - ring * 0.3)})`);
            ringGrd.addColorStop(0.95, `rgba(255, 100, 255, ${ringOpacity * (1 - ring * 0.2)})`);
            ringGrd.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = ringGrd;
            ctx.beginPath();
            ctx.arc(glow.x, glow.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    } else if (glow.type === 'moving_aura') {
        // Pulsating aura around moving ball
        const pulseRadius = glow.radius * (1 + Math.sin(progress * Math.PI * 12) * 0.4);
        
        // Validate pulse radius
        if (!isFinite(pulseRadius) || pulseRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        // Multiple concentric glows for depth
        for (let layer = 0; layer < 3; layer++) {
            const layerRadius = pulseRadius * (1 + layer * 0.3);
            const layerOpacity = opacity * (1 - layer * 0.25);
            
            // Validate layer values
            if (!isFinite(layerRadius) || !isFinite(layerOpacity) || layerRadius <= 0) {
                continue;
            }
            
            const grd = ctx.createRadialGradient(glow.x, glow.y, 0, glow.x, glow.y, layerRadius);
            grd.addColorStop(0, `rgba(255, 120, 255, ${layerOpacity * 0.8})`);
            grd.addColorStop(0.4, `rgba(168, 85, 247, ${layerOpacity * 0.6})`);
            grd.addColorStop(0.7, `rgba(138, 43, 226, ${layerOpacity * 0.4})`);
            grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(glow.x, glow.y, layerRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    } else {
        // Original pulsing glow with enhanced effect
        const pulseRadius = glow.radius * (1 + Math.sin(progress * Math.PI * 16) * 0.5);
        
        // Validate pulse radius
        if (!isFinite(pulseRadius) || pulseRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        const grd = ctx.createRadialGradient(glow.x, glow.y, 0, glow.x, glow.y, pulseRadius);
        grd.addColorStop(0, `rgba(255, 120, 255, ${opacity * 0.9})`);
        grd.addColorStop(0.3, `rgba(168, 85, 247, ${opacity * 0.7})`);
        grd.addColorStop(0.6, `rgba(138, 43, 226, ${opacity * 0.5})`);
        grd.addColorStop(0.8, `rgba(75, 0, 130, ${opacity * 0.3})`);
        grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(glow.x, glow.y, pulseRadius, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
}

// SAJA-JIN Hypnotic Spin Trail — Enhanced layered spinning effect
for (const trail of vfx.sajaJinHypnoticSpinTrail) {
    const progress = trail.t / trail.life;
    const opacity = (1 - progress) * (trail.intensity || 0.9);
   
    // Validation check for finite values
    if (!isFinite(trail.x) || !isFinite(trail.y) || !isFinite(progress) || !isFinite(opacity) ||
        !isFinite(trail.layer) || !isFinite(trail.angle)) {
        continue;
    }
   
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    
    if (trail.layer >= 0) {
        // Multi-layer spinning trails for hypnotic depth
        const baseRadius = 20 + (trail.layer * 5);
        const currentRadius = baseRadius * (1 - progress * 0.2);
        
        // Validate radius
        if (!isFinite(baseRadius) || !isFinite(currentRadius) || currentRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        // Create gradient based on layer
        const spinGlow = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, currentRadius);
        const hue = trail.layer * 30; // Different hues for layers
        spinGlow.addColorStop(0, `hsla(${280 + hue}, 100%, 70%, ${opacity})`);
        spinGlow.addColorStop(0.4, `hsla(${260 + hue}, 80%, 60%, ${opacity * 0.7})`);
        spinGlow.addColorStop(0.8, `hsla(${240 + hue}, 60%, 40%, ${opacity * 0.4})`);
        spinGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = spinGlow;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, currentRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Connecting energy lines between layers
        if (trail.layer > 0) {
            ctx.strokeStyle = `hsla(${270 + hue}, 100%, 70%, ${opacity * 0.5})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            const lineLength = currentRadius * 0.8;
            const angle = trail.angle + (progress * Math.PI * 4);
            ctx.moveTo(trail.x - Math.cos(angle) * lineLength, trail.y - Math.sin(angle) * lineLength);
            ctx.lineTo(trail.x + Math.cos(angle) * lineLength, trail.y + Math.sin(angle) * lineLength);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    } else if (trail.type === 'goal_spiral') {
        // Spiral trail during goal phase
        const spiralRadius = 15 * (1 - progress * 0.4);
        const spiralGlow = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, spiralRadius);
        spiralGlow.addColorStop(0, `rgba(255, 150, 255, ${opacity})`);
        spiralGlow.addColorStop(0.5, `rgba(200, 100, 255, ${opacity * 0.7})`);
        spiralGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = spiralGlow;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, spiralRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Spiral connecting lines
        ctx.strokeStyle = `rgba(255, 120, 255, ${opacity * 0.6})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        const spiralAngle = trail.angle + (progress * Math.PI * 6);
        const spiralLength = spiralRadius * 1.5;
        ctx.moveTo(trail.x, trail.y);
        ctx.lineTo(
            trail.x + Math.cos(spiralAngle) * spiralLength,
            trail.y + Math.sin(spiralAngle) * spiralLength
        );
        ctx.stroke();
    } else {
        // Main ball trail (enhanced version)
        const mainRadius = 30 * (1 - progress * 0.3);
        const mainGlow = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, mainRadius);
        mainGlow.addColorStop(0, `rgba(255, 120, 255, ${opacity * 1.2})`);
        mainGlow.addColorStop(0.3, `rgba(200, 80, 255, ${opacity * 0.9})`);
        mainGlow.addColorStop(0.6, `rgba(150, 50, 200, ${opacity * 0.6})`);
        mainGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = mainGlow;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, mainRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Cross-pattern energy lines
        ctx.strokeStyle = `rgba(255, 150, 255, ${opacity * 0.8})`;
        ctx.lineWidth = 4;
        const angle = trail.angle;
        const lineLength = mainRadius * 0.8;
        
        // Main line
        ctx.beginPath();
        ctx.moveTo(trail.x - Math.cos(angle) * lineLength, trail.y - Math.sin(angle) * lineLength);
        ctx.lineTo(trail.x + Math.cos(angle) * lineLength, trail.y + Math.sin(angle) * lineLength);
        ctx.stroke();
        
        // Perpendicular line
        ctx.beginPath();
        ctx.moveTo(trail.x - Math.cos(angle + Math.PI/2) * lineLength * 0.7, trail.y - Math.sin(angle + Math.PI/2) * lineLength * 0.7);
        ctx.lineTo(trail.x + Math.cos(angle + Math.PI/2) * lineLength * 0.7, trail.y + Math.sin(angle + Math.PI/2) * lineLength * 0.7);
        ctx.stroke();
    }
    
    ctx.restore();
}

// SAJA-JIN Hypnotic Trail — Enhanced motion trail during goal phase
for (const trail of vfx.sajaJinHypnoticTrail) {
    const progress = trail.t / trail.life;
    const opacity = (1 - progress) * 0.8;
    
    // Validation check for finite values
    if (!isFinite(trail.x) || !isFinite(trail.y) || !isFinite(progress) || !isFinite(opacity)) {
        continue;
    }
    
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    
    if (trail.type === 'goal_spiral') {
        // Spiral trail particles during goal movement
        const trailRadius = 12 * (1 - progress * 0.3);
        
        // Ensure radius is valid
        if (!isFinite(trailRadius) || trailRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        const spiralGlow = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, trailRadius);
        spiralGlow.addColorStop(0, `rgba(255, 180, 255, ${opacity * 1.1})`);
        spiralGlow.addColorStop(0.5, `rgba(200, 120, 255, ${opacity * 0.8})`);
        spiralGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = spiralGlow;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, trailRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Connect spiral points with curved lines
        if (trail.angle !== undefined && isFinite(trail.angle)) {
            ctx.strokeStyle = `rgba(255, 150, 255, ${opacity * 0.7})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            const lineLength = trailRadius * 1.8;
            
            if (isFinite(lineLength) && lineLength > 0) {
                const startAngle = trail.angle - 0.5;
                const endAngle = trail.angle + 0.5;
                
                ctx.arc(trail.x, trail.y, lineLength, startAngle, endAngle);
                ctx.stroke();
            }
        }
    }
    
    ctx.restore();
}

// SAJA-JIN Hypnotic Caption — Threatening text display
for (const caption of vfx.sajaJinHypnoticCaption) {
    const progress = caption.t / caption.life;
    const opacity = Math.sin(progress * Math.PI) * 0.9; // Fade in and out
   
    ctx.save();
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
   
    // Add dramatic shadow and glow
    ctx.shadowBlur = 15;
    ctx.shadowColor = 'rgba(255, 0, 255, 0.8)';
    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
    ctx.strokeStyle = `rgba(255, 0, 255, ${opacity * 0.8})`;
    ctx.lineWidth = 2;
   
    // Pulsing text effect
    const scale = 1 + Math.sin(progress * Math.PI * 8) * 0.1;
    ctx.save();
    ctx.translate(caption.x, caption.y);
    ctx.scale(scale, scale);
    ctx.strokeText(caption.text, 0, 0);
    ctx.fillText(caption.text, 0, 0);
    ctx.restore();
   
    ctx.restore();
}

// SAJA-JIN Hypnotic Burst — Enhanced massive burst with hypnotic patterns
for (const burst of vfx.sajaJinHypnoticBurst) {
    const progress = burst.t / burst.life;
    const opacity = (1 - progress) * 0.9;
    const currentRadius = burst.radius * progress;
   
    // Validation check for finite values
    if (!isFinite(burst.x) || !isFinite(burst.y) || !isFinite(burst.radius) || 
        !isFinite(progress) || !isFinite(opacity) || !isFinite(currentRadius) || 
        burst.radius <= 0 || currentRadius <= 0) {
        continue;
    }
   
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
   
    if (burst.type === 'main_burst') {
        // Multi-layered main burst with pulsating effect
        const pulseEffect = 1 + Math.sin(progress * Math.PI * 8) * 0.2;
        const effectiveRadius = currentRadius * pulseEffect;
        
        // Validate effective radius
        if (!isFinite(pulseEffect) || !isFinite(effectiveRadius) || effectiveRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        // Outer shockwave
        const outerGrad = ctx.createRadialGradient(burst.x, burst.y, effectiveRadius * 0.7, burst.x, burst.y, effectiveRadius);
        outerGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
        outerGrad.addColorStop(0.8, `rgba(255, 150, 255, ${opacity * 0.6})`);
        outerGrad.addColorStop(0.95, `rgba(255, 200, 255, ${opacity * 0.8})`);
        outerGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = outerGrad;
        ctx.beginPath();
        ctx.arc(burst.x, burst.y, effectiveRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner core burst
        const coreRadius = effectiveRadius * 0.4;
        const coreGrad = ctx.createRadialGradient(burst.x, burst.y, 0, burst.x, burst.y, coreRadius);
        coreGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
        coreGrad.addColorStop(0.3, `rgba(255, 180, 255, ${opacity * 0.9})`);
        coreGrad.addColorStop(0.6, `rgba(200, 100, 255, ${opacity * 0.7})`);
        coreGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = coreGrad;
        ctx.beginPath();
        ctx.arc(burst.x, burst.y, coreRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Hypnotic spiral pattern
        ctx.strokeStyle = `rgba(255, 200, 255, ${opacity * 0.8})`;
        ctx.lineWidth = 5;
        for (let spiral = 0; spiral < 3; spiral++) {
            ctx.beginPath();
            for (let i = 0; i <= 50; i++) {
                const angle = (i / 50) * Math.PI * 6 + (progress * Math.PI * 4) + (spiral * Math.PI * 0.67);
                const radius = (i / 50) * effectiveRadius * 0.8;
                const x = burst.x + Math.cos(angle) * radius;
                const y = burst.y + Math.sin(angle) * radius;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }
        
    } else if (burst.type === 'ring_burst') {
        // Ring burst effect with delay
        const delayProgress = Math.max(0, (burst.t - (burst.delay || 0)) / burst.life);
        if (delayProgress > 0) {
            const ringOpacity = opacity * (1 - delayProgress) * 0.7;
            const ringRadius = burst.radius * delayProgress * 1.2;
            
            // Ring effect
            const ringGrad = ctx.createRadialGradient(burst.x, burst.y, ringRadius * 0.8, burst.x, burst.y, ringRadius);
            ringGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
            ringGrad.addColorStop(0.7, `rgba(168, 85, 247, ${ringOpacity})`);
            ringGrad.addColorStop(0.9, `rgba(255, 150, 255, ${ringOpacity * 1.2})`);
            ringGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = ringGrad;
            ctx.beginPath();
            ctx.arc(burst.x, burst.y, ringRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    } else {
        // Standard burst with enhanced visuals
        const burstGrad = ctx.createRadialGradient(burst.x, burst.y, 0, burst.x, burst.y, currentRadius);
        burstGrad.addColorStop(0, `rgba(255, 200, 255, ${opacity})`);
        burstGrad.addColorStop(0.3, `rgba(200, 100, 255, ${opacity * 0.8})`);
        burstGrad.addColorStop(0.6, `rgba(150, 50, 200, ${opacity * 0.5})`);
        burstGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = burstGrad;
        ctx.beginPath();
        ctx.arc(burst.x, burst.y, currentRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Enhanced spiral energy lines
        ctx.strokeStyle = `rgba(255, 150, 255, ${opacity * 0.8})`;
        ctx.lineWidth = 3;
        for (let i = 0; i < 16; i++) {
            const angle = (Math.PI * 2 * i / 16) + (progress * Math.PI * 6);
            const innerRadius = currentRadius * 0.1;
            const outerRadius = currentRadius * 0.95;
            
            // Create curved lines instead of straight
            ctx.beginPath();
            ctx.moveTo(
                burst.x + Math.cos(angle) * innerRadius,
                burst.y + Math.sin(angle) * innerRadius
            );
            
            // Curve the line
            const midAngle = angle + 0.3;
            const midRadius = currentRadius * 0.5;
            const midX = burst.x + Math.cos(midAngle) * midRadius;
            const midY = burst.y + Math.sin(midAngle) * midRadius;
            
            ctx.quadraticCurveTo(
                midX, midY,
                burst.x + Math.cos(angle + 0.2) * outerRadius,
                burst.y + Math.sin(angle + 0.2) * outerRadius
            );
            ctx.stroke();
        }
    }
   
    ctx.restore();
}

// SAJA-JIN Ghost Trail Rendering
if (ball._sajaJinGhostTrail && ball._sajaJinGhostTrail.length > 1) {
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    for (let i = 0; i < ball._sajaJinGhostTrail.length - 1; i++) {
        const p = ball._sajaJinGhostTrail[i], n = ball._sajaJinGhostTrail[i+1];
        const age = (performance.now() - p.time);
        const a = clamp(1 - age / 2000, 0, 1) * 0.7; // 2 second fade
        const w = lerp(15, 3, i / ball._sajaJinGhostTrail.length); // Trail width

        // Create ghostly gradient trail
        const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
        g.addColorStop(0, `rgba(59, 130, 246, ${a * 0.8})`); // Soul blue
        g.addColorStop(0.5, `rgba(147, 51, 234, ${a * 0.6})`); // Purple
        g.addColorStop(1, `rgba(30, 27, 75, ${a * 0.3})`); // Dark fade
       
        ctx.strokeStyle = g;
        ctx.lineWidth = w;
        ctx.lineCap = 'round';
        ctx.shadowBlur = 8;
        ctx.shadowColor = 'rgba(59, 130, 246, 0.5)';
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(n.x, n.y);
        ctx.stroke();
    }
    ctx.restore();
}

// SAJA-JIN Ghost Trail Wisps
for (const wisp of vfx.sajaJinGhostTrail) {
    const progress = wisp.t / wisp.life;
    const opacity = (1 - progress) * 0.8;
    const flicker = Math.sin(wisp.phase + progress * Math.PI * 12) * 0.3 + 0.7;
   
    wisp.x += wisp.vx;
    wisp.y += wisp.vy;
    wisp.vx *= 0.98;
    wisp.vy *= 0.98;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const grd = ctx.createRadialGradient(wisp.x, wisp.y, 0, wisp.x, wisp.y, wisp.r * flicker);
    grd.addColorStop(0, `rgba(59, 130, 246, ${opacity * flicker})`);
    grd.addColorStop(0.5, `rgba(147, 51, 234, ${opacity * 0.6 * flicker})`);
    grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(wisp.x, wisp.y, wisp.r * flicker, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
}

// SAJA-JIN Hypnotic Trail — Now with trailing flicker
for (const trail of vfx.sajaJinHypnoticTrail) {
const progress = trail.t / trail.life;
const opacity = (1 - progress) * 0.9;

trail.x += trail.vx;
trail.y += trail.vy;
trail.vx *= 0.93;
trail.vy *= 0.93;

const sizePulse = trail.size * (1 + Math.sin(progress * Math.PI * 6) * 0.3);
ctx.globalCompositeOperation = 'lighter';
ctx.fillStyle = `rgba(255, 20, 147, ${opacity})`;
ctx.shadowBlur = 12;
ctx.shadowColor = `rgba(255, 20, 147, ${opacity * 0.6})`;
ctx.beginPath();
ctx.arc(trail.x, trail.y, sizePulse, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
}

            // ========== ABBY VFX RENDERING ==========
            
            // ABBY Colossal Calves Trail - Enhanced with thunderous muscle power
            for(const trail of vfx.abbyColossalCalvesTrail){
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * 0.8;
                const pulse = Math.sin(progress * Math.PI * 8) * 0.3 + 0.7;
                const musclePower = Math.sin(trail.t * 0.02) * 0.4 + 0.6;
                
                trail.x += trail.vx;
                trail.y += trail.vy;
                trail.vx *= 0.95;
                trail.vy *= 0.95;
                
                ctx.save();
                
                // Outer muscle power aura
                ctx.globalCompositeOperation = 'screen';
                const powerGrd = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, trail.size * 4 * musclePower);
                powerGrd.addColorStop(0, `rgba(255, 20, 147, ${opacity * 0.4})`);
                powerGrd.addColorStop(0.3, `rgba(255, 105, 180, ${opacity * 0.6})`);
                powerGrd.addColorStop(0.7, `rgba(255, 192, 203, ${opacity * 0.3})`);
                powerGrd.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = powerGrd;
                ctx.beginPath();
                ctx.arc(trail.x, trail.y, trail.size * 4 * musclePower, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalCompositeOperation = 'lighter';
                
                // Core colossal energy with pulsing intensity
                const coreGrd = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, trail.size * pulse);
                coreGrd.addColorStop(0, `rgba(255, 255, 255, ${opacity * pulse * 0.8})`); // White hot center
                coreGrd.addColorStop(0.3, `rgba(255, 20, 147, ${opacity * pulse})`); // Deep Pink
                coreGrd.addColorStop(0.6, `rgba(255, 105, 180, ${opacity * 0.8})`); // Hot Pink
                coreGrd.addColorStop(1, `rgba(255, 192, 203, 0)`); // Light Pink fade
                ctx.fillStyle = coreGrd;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(255, 20, 147, ${opacity * 0.7})`;
                ctx.beginPath();
                ctx.arc(trail.x, trail.y, trail.size * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Muscle fiber streaks
                if(Math.random() < 0.4) {
                    ctx.strokeStyle = `rgba(255, 105, 180, ${opacity * 0.8})`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = `rgba(255, 20, 147, ${opacity})`;
                    
                    for(let fiber = 0; fiber < 4; fiber++) {
                        const angle = (fiber / 4) * Math.PI * 2 + trail.t * 0.01;
                        const length = trail.size * (1.5 + Math.sin(trail.t * 0.03 + fiber) * 0.5);
                        ctx.beginPath();
                        ctx.moveTo(trail.x, trail.y);
                        ctx.lineTo(trail.x + Math.cos(angle) * length, trail.y + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            // ABBY Power Pin Sparks - Enhanced with devastating wrestling force
            for(const spark of vfx.abbyPowerPinSparks){
                const progress = spark.t / spark.life;
                const opacity = (1 - progress) * 0.9;
                const flicker = Math.sin(progress * Math.PI * 15) * 0.4 + 0.6;
                const wrestlingForce = Math.sin(spark.t * 0.025) * 0.3 + 0.7;
                
                spark.x += spark.vx;
                spark.y += spark.vy;
                spark.vx *= 0.92;
                spark.vy *= 0.92;
                
                ctx.save();
                
                // Outer impact shockwave
                ctx.globalCompositeOperation = 'screen';
                const impactGrd = ctx.createRadialGradient(spark.x, spark.y, 0, spark.x, spark.y, spark.size * 3 * wrestlingForce);
                impactGrd.addColorStop(0, `rgba(255, 69, 0, ${opacity * 0.4})`);
                impactGrd.addColorStop(0.4, `rgba(255, 20, 147, ${opacity * 0.6})`);
                impactGrd.addColorStop(0.8, `rgba(255, 105, 180, ${opacity * 0.3})`);
                impactGrd.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = impactGrd;
                ctx.beginPath();
                ctx.arc(spark.x, spark.y, spark.size * 3 * wrestlingForce, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalCompositeOperation = 'lighter';
                
                // Core pin spark with devastating intensity
                const coreGrd = ctx.createRadialGradient(spark.x, spark.y, 0, spark.x, spark.y, spark.size * flicker);
                coreGrd.addColorStop(0, `rgba(255, 255, 255, ${opacity * flicker})`); // White hot center
                coreGrd.addColorStop(0.3, `rgba(255, 69, 0, ${opacity * flicker})`); // Orange-red core
                coreGrd.addColorStop(0.7, `rgba(255, 20, 147, ${opacity * 0.8})`); // Pink force
                coreGrd.addColorStop(1, 'rgba(255, 255, 255, 0)'); // White fade
                ctx.fillStyle = coreGrd;
                ctx.shadowBlur = 12;
                ctx.shadowColor = `rgba(255, 69, 0, ${opacity * 0.8})`;
                ctx.beginPath();
                ctx.arc(spark.x, spark.y, spark.size * flicker, 0, Math.PI * 2);
                ctx.fill();
                
                // Wrestling ring sparks
                if(Math.random() < 0.5) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                    ctx.lineWidth = 1 + Math.random();
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = `rgba(255, 20, 147, ${opacity})`;
                    
                    for(let ring = 0; ring < 3; ring++) {
                        const angle = Math.random() * Math.PI * 2;
                        const length = spark.size * (1 + Math.random() * 1.5);
                        ctx.beginPath();
                        ctx.moveTo(spark.x, spark.y);
                        const endX = spark.x + Math.cos(angle) * length;
                        const endY = spark.y + Math.sin(angle) * length;
                        ctx.lineTo(endX + (Math.random() - 0.5) * 3, endY + (Math.random() - 0.5) * 3);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            // ABBY Demon Drive Aura
            for(const aura of vfx.abbyDemonDriveAura){
                const progress = aura.t / aura.life;
                const opacity = (1 - progress) * 0.7;
                const pulse = Math.sin(progress * Math.PI * 10) * 0.4 + 0.6;
                const currentRadius = aura.radius * (1 + pulse * 0.3);
                
                const x = aura.followPlayer ? player.x : aura.x;
                const y = aura.followPlayer ? player.y : aura.y;
                
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                // Dark magenta demonic aura
                const grd = ctx.createRadialGradient(x, y, 0, x, y, currentRadius);
                grd.addColorStop(0, `rgba(139, 0, 139, ${opacity * pulse})`); // Dark magenta core
                grd.addColorStop(0.4, `rgba(255, 0, 255, ${opacity * 0.7})`); // Bright magenta
                grd.addColorStop(0.7, `rgba(75, 0, 130, ${opacity * 0.5})`); // Indigo
                grd.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade to black
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Add demonic energy wisps
                for(let i = 0; i < 5; i++){
                    const angle = (progress * Math.PI * 4) + (i * Math.PI * 2 / 5);
                    const wispX = x + Math.cos(angle) * currentRadius * 0.7;
                    const wispY = y + Math.sin(angle) * currentRadius * 0.7;
                    const wispGrd = ctx.createRadialGradient(wispX, wispY, 0, wispX, wispY, 6);
                    wispGrd.addColorStop(0, `rgba(25, 0, 25, ${opacity * 0.8})`); // Dark demon wisp
                    wispGrd.addColorStop(1, 'rgba(75, 0, 130, 0)'); // Purple fade
                    ctx.fillStyle = wispGrd;
                    ctx.beginPath();
                    ctx.arc(wispX, wispY, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            // Energy Residue
            for(const residue of vfx.energyResidue) {
                const f = 1 - residue.t / residue.life;
                const a = f * 0.6;
                ctx.fillStyle = `${residue.color}${a})`;
                ctx.beginPath();
                ctx.arc(residue.x, residue.y, residue.r * f, 0, Math.PI * 2);
                ctx.fill();
            }


            vfx.shockwaves = vfx.shockwaves.filter(s=> (s.t+=dt) < s.life);
            for(const s of vfx.shockwaves){
                const t = s.t/s.life; const r = s.r + t*80;
                const a = (1-t)*0.8;

                const sColor1 = getRGBA(s.color1, a);
                const sColor2 = getRGBA(s.color2, a * 0.8);

                ctx.strokeStyle=sColor1;
                ctx.lineWidth=3; ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.stroke();
                ctx.strokeStyle=sColor2;
                ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(s.x,s.y,r*1.12,0,Math.PI*2); ctx.stroke();
            }
            for(const l of vfx.lines){
                const t=l.t/l.life; const a=(1-t)*0.6;
                const x2 = l.x + Math.cos(l.a)*l.len;
                const y2 = l.y + Math.sin(l.a)*l.len;
                ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=2;
                ctx.beginPath(); ctx.moveTo(l.x,l.y); ctx.lineTo(x2,y2); ctx.stroke();
            }

            for(const a of vfx.robsanAura){
                const progress = a.t / a.life;
                const currentRadius = lerp(a.radius * 0.5, a.radius * 2, progress);
                const opacity = (1 - progress) * 0.7;

                const grd = ctx.createRadialGradient(a.x, a.y, a.radius * 0.5, a.x, a.y, currentRadius);
                grd.addColorStop(0, `rgba(49, 46, 129, ${opacity * 0.8})`);
                grd.addColorStop(0.7, `rgba(76, 29, 149, ${opacity * 0.4})`);
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(a.x, a.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw Robsan Void Dash Trail
            if (vfx.voidTrails.length && player._voidDashTrail && player._voidDashTrail.length > 1) {
                for(let i=0;i<player._voidDashTrail.length-1;i++){
                    const p=player._voidDashTrail[i], n=player._voidDashTrail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/(VOID_DASH_DURATION + 100), 0, 1)*0.9;
                    const w = lerp(vfx.voidTrails[0].w,2,i/player._voidDashTrail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,getRGBA(vfx.voidTrails[0].trailColorStart,a));
                    g.addColorStop(1,getRGBA(vfx.voidTrails[0].trailColorEnd,a*0.6));
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }
            }

            // Draw XDrake Supernova Trail
            if (vfx.xdrakeSupernovaTrails.length && player._xdrakeSupernovaTrail && player._xdrakeSupernovaTrail.length > 1) {
                for(let i=0;i<player._xdrakeSupernovaTrail.length-1;i++){
                    const p=player._xdrakeSupernovaTrail[i], n=player._xdrakeSupernovaTrail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/(XDRAKE_SUPERNOVA_DASH_DURATION + 100), 0, 1)*0.9;
                    const w = lerp(vfx.xdrakeSupernovaTrails[0].w,2,i/player._xdrakeSupernovaTrail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorStart,a));
                    g.addColorStop(1,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorEnd,a*0.6));
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }
            }


            // This block was previously removed as requested. It remains removed.
            // if(vfx.flashes.length){
            //     const f = vfx.flashes[0];
            //     const a = (1 - f.t/f.life) * 0.4;
            //     ctx.fillStyle=`rgba(255,255,255,${a})`;
            //     ctx.fillRect(0,0,W,H);
            // }

// Asher Star Trail
            if (vfx.asherStarTrail.length && ball._asherStarTrail && ball._asherStarTrail.length > 1) {
                for (let i = 0; i < ball._asherStarTrail.length - 1; i++) {
                    const p = ball._asherStarTrail[i], n = ball._asherStarTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / ASHER_HOMING_SHOT_DURATION, 0, 1) * 0.9;
                    const w = lerp(vfx.asherStarTrail[0].w, 2, i / ball._asherStarTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.asherStarTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.asherStarTrail[0].colorEnd, a * 0.7));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                    // Add sparkling star particles along the trail
                    if (Math.random() < 0.3) {
                        vfx.sparks.push({
                            x: p.x, y: p.y,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            life: 200 + Math.random() * 200,
                            t: 0, r: 1 + Math.random() * 2,
                            color: 'rgba(233, 213, 255,'
                        });
                    }
                }
            }

            // NEW DIDDY OIL TRAIL RENDERING
            if (ball._diddyOilTrail && ball._diddyOilTrail.length > 1) {
                for (let i = 0; i < ball._diddyOilTrail.length - 1; i++) {
                    const p = ball._diddyOilTrail[i], n = ball._diddyOilTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 3000, 0, 1) * 0.8; // 3 second fade
                    const w = lerp(12, 2, i / ball._diddyOilTrail.length); // Smaller trail width

                    if (oilImageLoaded) {
                        // Use oil.png images along the trail path
                        const segments = Math.max(1, Math.floor(w / 6)); // More images for thicker trails
                        for(let s = 0; s < segments; s++) {
                            const t = s / Math.max(1, segments - 1);
                            const x = lerp(p.x, n.x, t);
                            const y = lerp(p.y, n.y, t);
                            const scale = (w / 40) * (0.6 + Math.random() * 0.3); // Smaller oil images

                            ctx.save();
                            ctx.globalAlpha = a * (0.7 + Math.random() * 0.3);
                            ctx.translate(x, y);
                            ctx.rotate(Math.random() * Math.PI * 2);
                            ctx.scale(scale, scale);
                            ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                            ctx.restore();
                        }
                    } else {
                        // Fallback oil trail gradient
                        const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                        g.addColorStop(0, `rgba(184, 134, 11, ${a})`); // Golden oil
                        g.addColorStop(0.5, `rgba(139, 69, 19, ${a * 0.8})`); // Brown oil
                        g.addColorStop(1, `rgba(101, 67, 33, ${a * 0.5})`); // Dark brown

                        ctx.strokeStyle = g;
                        ctx.lineWidth = w;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(n.x, n.y);
                        ctx.stroke();

                        // Add oil glisten effect
                        if (Math.random() < 0.2) {
                            ctx.fillStyle = `rgba(255, 215, 0, ${a * 0.6})`;
                            ctx.beginPath();
                            ctx.arc(p.x + (Math.random() - 0.5) * w, p.y + (Math.random() - 0.5) * w, 1 + Math.random(), 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            // Asher Teleport Burst (Departure) - Enhanced
            for(const p of vfx.asherTeleportBurst){
                const f = 1 - p.t/p.life;
                const a = f * 0.9;
                const r = p.r * (1 + (1-f)*3); // More dramatic expansion
                const pulseEffect = 1 + Math.sin(p.t * 0.1) * 0.3;
                
                ctx.save();
                
                // Outer cosmic ring
                ctx.shadowBlur = 30;
                ctx.shadowColor = p.color + '0.8)';
                const outerGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 1.5 * pulseEffect);
                outerGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.3})`);
                outerGrad.addColorStop(0.3, `${p.color}${a * 0.6})`);
                outerGrad.addColorStop(0.7, `rgba(138, 43, 226, ${a * 0.4})`); // Purple cosmic energy
                outerGrad.addColorStop(1, 'rgba(138, 43, 226, 0)');
                ctx.fillStyle = outerGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r * 1.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Main teleport core
                ctx.shadowBlur = 20;
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                coreGrad.addColorStop(0.4, `${p.color}${a * 0.8})`);
                coreGrad.addColorStop(1, `${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.fill();
                
                // Starburst effects
                ctx.strokeStyle = `rgba(255, 255, 255, ${a * 0.8})`;
                ctx.lineWidth = 3 * f;
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i / 8) + p.t * 0.02;
                    const burstLength = r * 1.5 * (0.5 + Math.sin(p.t * 0.05 + i) * 0.5);
                    ctx.beginPath();
                    ctx.moveTo(p.x + Math.cos(angle) * r * 0.3, p.y + Math.sin(angle) * r * 0.3);
                    ctx.lineTo(p.x + Math.cos(angle) * burstLength, p.y + Math.sin(angle) * burstLength);
                    ctx.stroke();
                }
                
                ctx.restore();
            }


            // NEW LEONARDO VFX
            // Focus Shot Text
            // Asher Arrival Glimmer - Enhanced
            for(const p of vfx.asherArrivalGlimmer){
                const f = 1 - p.t/p.life;
                const a = Math.sin(f * Math.PI) * 0.9; // Enhanced pulsing opacity
                const r = p.r * (1 + Math.sin(f * Math.PI * 3) * 0.7); // More dynamic pulsing
                const sparkleIntensity = Math.sin(p.t * 0.2) * 0.5 + 0.5;
                
                ctx.save();
                
                // Multi-layer sparkle effect
                ctx.shadowBlur = 25;
                ctx.shadowColor = p.color + '0.9)';
                
                // Outer starlight halo
                const haloGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 2);
                haloGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.4})`);
                haloGrad.addColorStop(0.3, `${p.color}${a * 0.6})`);
                haloGrad.addColorStop(0.7, `rgba(255, 215, 0, ${a * 0.3})`); // Golden starlight
                haloGrad.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = haloGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r * 1.8, 0, Math.PI * 2);
                ctx.fill();
                
                // Main glimmer core
                ctx.shadowBlur = 15;
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                coreGrad.addColorStop(0.5, `${p.color}${a})`);
                coreGrad.addColorStop(1, `${p.color}0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.fill();
                
                // Twinkling cross pattern
                ctx.strokeStyle = `rgba(255, 255, 255, ${a * sparkleIntensity})`;
                ctx.lineWidth = 2 * f;
                const crossSize = r * 2;
                ctx.beginPath();
                ctx.moveTo(p.x - crossSize, p.y);
                ctx.lineTo(p.x + crossSize, p.y);
                ctx.moveTo(p.x, p.y - crossSize);
                ctx.lineTo(p.x, p.y + crossSize);
                ctx.stroke();
                
                // Diagonal sparkle lines
                const diagonalSize = crossSize * 0.7;
                ctx.lineWidth = 1 * f;
                ctx.beginPath();
                ctx.moveTo(p.x - diagonalSize, p.y - diagonalSize);
                ctx.lineTo(p.x + diagonalSize, p.y + diagonalSize);
                ctx.moveTo(p.x + diagonalSize, p.y - diagonalSize);
                ctx.lineTo(p.x - diagonalSize, p.y + diagonalSize);
                ctx.stroke();
                
                ctx.restore();
            }

            // NEW DIDDY VFX
            // Baby Oil Guy Oil Particles - Enhanced with viscous slippery effects
            for(const p of vfx.diddyOilParticles){
                p.t += dt;
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98; // Slight friction
                p.vy *= 0.98;

                const f = 1 - p.t / p.life;
                const a = f * p.opacity;
                const r = p.r * (1 + (1-f) * 0.3); // Slight expansion
                const viscosity = Math.sin(p.t * 0.015) * 0.3 + 0.7;

                if (oilImageLoaded) {
                    // Enhanced oil image with multiple layers
                    ctx.save();
                    
                    // Background glow layer
                    ctx.globalAlpha = a * 0.6;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `rgba(255, 215, 0, ${a * 0.8})`;
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.t * 0.01 * viscosity);
                    ctx.scale((r / 20) * viscosity, (r / 20) * viscosity);
                    ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                    
                    // Main oil layer with iridescent shimmer
                    ctx.globalAlpha = a;
                    ctx.shadowBlur = 0;
                    ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                    
                    ctx.restore();
                    
                    // Oil shine highlight
                    const shineGrad = ctx.createRadialGradient(p.x - r * 0.3, p.y - r * 0.3, 0, p.x, p.y, r * 0.8);
                    shineGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.6})`);
                    shineGrad.addColorStop(0.5, `rgba(255, 215, 0, ${a * 0.3})`);
                    shineGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = shineGrad;
                    ctx.beginPath();
                    ctx.arc(p.x - r * 0.2, p.y - r * 0.2, r * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else {
                    // Enhanced fallback gradient effect with iridescent layers
                    const baseGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 2);
                    baseGrad.addColorStop(0, `rgba(255, 215, 0, ${a})`); // Golden center
                    baseGrad.addColorStop(0.3, `rgba(184, 134, 11, ${a * 0.9})`); 
                    baseGrad.addColorStop(0.7, `rgba(139, 69, 19, ${a * 0.7})`);
                    baseGrad.addColorStop(1, `rgba(120, 53, 15, ${a * 0.3})`); // Brown edge
                    ctx.fillStyle = baseGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Oil shine overlay
                    const shineGrad = ctx.createRadialGradient(p.x - r * 0.3, p.y - r * 0.3, 0, p.x, p.y, r);
                    shineGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.7})`);
                    shineGrad.addColorStop(0.6, `rgba(255, 215, 0, ${a * 0.4})`);
                    shineGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = shineGrad;
                    ctx.beginPath();
                    ctx.arc(p.x - r * 0.2, p.y - r * 0.2, r * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            vfx.diddyOilParticles = vfx.diddyOilParticles.filter(p => p.t < p.life);

            // Baby Oil Guy Ascension VFX
            for(const p of vfx.diddyAscensionVFX){
                p.t += dt;
                p.y -= p.speed; // Rising effect

                const f = 1 - p.t / p.life;
                const a = Math.sin(f * Math.PI) * 0.9; // Pulsing
                const r = p.r * (1 + Math.sin(p.t * 0.01) * 0.2); // Gentle size pulse

                if (oilImageLoaded) {
                    // Use oil.png with golden glow for ascension
                    ctx.save();

                    // Add golden glow behind the oil
                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 3);
                    g.addColorStop(0, `rgba(255, 223, 0, ${a * 0.6})`);
                    g.addColorStop(0.4, `rgba(255, 193, 7, ${a * 0.4})`);
                    g.addColorStop(1, `rgba(255, 193, 7, 0)`);
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r * 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw ascending oil image with golden tint
                    ctx.globalAlpha = a * 0.9;
                    ctx.globalCompositeOperation = 'screen'; // Makes it glow
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.t * 0.02); // Mystical rotation
                    ctx.scale(r / 20, r / 20);
                    ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                    ctx.restore();
                } else {
                    // Fallback glowing golden ascension effect
                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 2);
                    g.addColorStop(0, `rgba(255, 223, 0, ${a})`);
                    g.addColorStop(0.4, `rgba(255, 193, 7, ${a * 0.7})`);
                    g.addColorStop(1, `rgba(255, 193, 7, 0)`);

                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Add sparkle effect for both modes
                if (Math.random() < 0.4) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${a * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(p.x + (Math.random() - 0.5) * r, p.y + (Math.random() - 0.5) * r, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            vfx.diddyAscensionVFX = vfx.diddyAscensionVFX.filter(p => p.t < p.life);

            // Baby Oil Guy Oil Slicks
            for(const slick of vfx.diddyOilSlicks){
                slick.t += dt;

                const f = 1 - slick.t / slick.life;
                const a = f * slick.opacity;
                const r = slick.radius * (0.8 + f * 0.2); // Slight shrinking over time

                if (oilImageLoaded) {
                    // Create realistic oil puddle using multiple oil images
                    const oilPatches = 8; // Number of oil patches to create the puddle
                    for(let i = 0; i < oilPatches; i++){
                        const angle = (Math.PI * 2 * i) / oilPatches;
                        const distance = r * (0.3 + Math.random() * 0.4);
                        const x = slick.x + Math.cos(angle) * distance;
                        const y = slick.y + Math.sin(angle) * distance;
                        const scale = (0.8 + Math.random() * 0.4) * (r / 60);

                        ctx.save();
                        ctx.globalAlpha = a * (0.6 + Math.random() * 0.4);
                        ctx.translate(x, y);
                        ctx.rotate(angle + slick.t * 0.001);
                        ctx.scale(scale, scale);
                        ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                        ctx.restore();
                    }

                    // Central oil patch
                    ctx.save();
                    ctx.globalAlpha = a * 0.8;
                    ctx.translate(slick.x, slick.y);
                    ctx.rotate(slick.t * 0.002);
                    ctx.scale(r / 40, r / 40);
                    ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                    ctx.restore();
                } else {
                    // Fallback animated oil slick with ripple effect
                    const ripples = 3;
                    for(let i = 0; i < ripples; i++){
                        const rippleF = (slick.t * 0.003 + i * 0.33) % 1;
                        const rippleR = r * (0.3 + rippleF * 0.7);
                        const rippleA = a * (1 - rippleF) * 0.5;

                        const g = ctx.createRadialGradient(slick.x, slick.y, 0, slick.x, slick.y, rippleR);
                        g.addColorStop(0, `rgba(139, 69, 19, ${rippleA})`); // Brown center
                        g.addColorStop(0.6, `rgba(160, 82, 45, ${rippleA * 0.7})`); // Saddle brown
                        g.addColorStop(1, `rgba(160, 82, 45, 0)`); // Transparent edge

                        ctx.fillStyle = g;
                        ctx.beginPath();
                        ctx.arc(slick.x, slick.y, rippleR, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            vfx.diddyOilSlicks = vfx.diddyOilSlicks.filter(slick => slick.t < slick.life);

            // Baby Oil Guy Slick Trail
            for(const trail of vfx.diddySlickTrail){
                trail.t += dt;
                trail.x += trail.vx;
                trail.y += trail.vy;
                trail.vy += 0.1; // Gravity effect

                const f = 1 - trail.t / trail.life;
                const a = f * 0.8;
                const r = trail.r * (1 + (1-f) * 0.5);

                if (oilImageLoaded) {
                    // Use oil.png for realistic droplets
                    ctx.save();
                    ctx.globalAlpha = a;
                    ctx.translate(trail.x, trail.y);
                    ctx.rotate(trail.t * 0.005); // Gentle rotation
                    ctx.scale(r / 35, r / 35); // Even smaller scale for droplets
                    ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                    ctx.restore();
                } else {
                    // Fallback gradient droplet effect
                    const g = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, r);
                    g.addColorStop(0, `rgba(184, 134, 11, ${a})`);
                    g.addColorStop(0.7, `rgba(139, 69, 19, ${a * 0.6})`);
                    g.addColorStop(1, `rgba(101, 67, 33, ${a * 0.2})`);

                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            vfx.diddySlickTrail = vfx.diddySlickTrail.filter(trail => trail.t < trail.life);

            // ========== LINCOLN GYATT SHOWDOWN VFX ==========

            // Lincoln Gyatt Aura - Swirling energy around player
            for (const aura of vfx.lincolnGyattAura) {
                const progress = aura.t / aura.life;
                const opacity = 1 - progress;
                
                if (isFinite(aura.x) && isFinite(aura.y) && isFinite(aura.radius) && aura.radius > 0) {
                    ctx.save();
                    
                    // Create gradient for gyatt energy
                    const gradient = ctx.createRadialGradient(
                        aura.x, aura.y, 0,
                        aura.x, aura.y, aura.radius
                    );
                    gradient.addColorStop(0, `rgba(255, 100, 255, ${opacity * 0.8})`);
                    gradient.addColorStop(0.5, `rgba(100, 255, 255, ${opacity * 0.6})`);
                    gradient.addColorStop(1, `rgba(255, 255, 100, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(aura.x, aura.y, aura.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add rotating sparkles
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (aura.t * 0.05 + i * Math.PI / 4) % (Math.PI * 2);
                        const sparkleX = aura.x + Math.cos(angle) * aura.radius * 0.8;
                        const sparkleY = aura.y + Math.sin(angle) * aura.radius * 0.8;
                        
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, 3, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            }

            // Lincoln Gyatt Trail - Movement trail with gyatt energy
            for (const trail of vfx.lincolnGyattTrail) {
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * 0.7;
                
                if (isFinite(trail.x) && isFinite(trail.y) && isFinite(trail.size) && trail.size > 0) {
                    ctx.save();
                    
                    // Pulsing gyatt trail effect
                    const pulseSize = trail.size * (1 + Math.sin(trail.t * 0.2) * 0.3);
                    
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(255, 100, 255, 0.8)';
                    
                    // Main trail glow
                    const trailGradient = ctx.createRadialGradient(
                        trail.x, trail.y, 0,
                        trail.x, trail.y, pulseSize
                    );
                    trailGradient.addColorStop(0, `rgba(255, 200, 255, ${opacity})`);
                    trailGradient.addColorStop(0.7, `rgba(100, 255, 255, ${opacity * 0.5})`);
                    trailGradient.addColorStop(1, `rgba(255, 255, 100, 0)`);
                    
                    ctx.fillStyle = trailGradient;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            // Lincoln Gyatt Particles - Explosive gyatt energy particles
            for (const particle of vfx.lincolnGyattParticles) {
                const progress = particle.t / particle.life;
                const opacity = 1 - progress;
                
                if (isFinite(particle.x) && isFinite(particle.y) && isFinite(particle.size) && particle.size > 0) {
                    ctx.save();
                    
                    // Spinning particle effect
                    const spin = particle.t * 0.1;
                    const currentSize = particle.size * (1 - progress * 0.5);
                    
                    ctx.translate(particle.x, particle.y);
                    ctx.rotate(spin);
                    
                    // Multi-colored gyatt particle
                    ctx.shadowBlur = 10;
                    
                    // Convert hue to RGB color
                    const hue = particle.hue || 280;
                    const saturation = 100;
                    const lightness = 60;
                    const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    
                    ctx.shadowColor = color;
                    ctx.fillStyle = color.replace('hsl', 'hsla').replace(')', `, ${opacity})`);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                    ctx.lineWidth = 1;
                    
                    // Draw star-shaped particle
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2) / 5;
                        const outerRadius = currentSize;
                        const innerRadius = currentSize * 0.4;
                        
                        if (i === 0) {
                            ctx.moveTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                        } else {
                            ctx.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                        }
                        
                        const innerAngle = angle + Math.PI / 5;
                        ctx.lineTo(Math.cos(innerAngle) * innerRadius, Math.sin(innerAngle) * innerRadius);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }

            // ========== KORBIN FIERY APOCALYPSE VFX RENDERING ==========

            // Korbin Fiery Apocalypse Flames - Massive fire effects with looping
            for (const flame of vfx.korbinFireApocalypseFlames) {
                const progress = flame.t / flame.life;
                const opacity = (1 - progress) * flame.intensity;
                
                if (isFinite(flame.x) && isFinite(flame.y) && isFinite(flame.size) && flame.size > 0) {
                    ctx.save();
                    
                    // Enhanced flickering flame effect with loop
                    const flicker = Math.sin(flame.t * 0.08) * 0.3 + 0.7;
                    const loopEffect = flame.loop ? Math.sin(flame.t * 0.02) * flame.loop : 0;
                    const currentSize = Math.max(0.1, flame.size * flicker * (1 + progress * 0.5 + loopEffect)); // Ensure positive size
                    
                    ctx.translate(flame.x, flame.y);
                    ctx.rotate(flame.t * 0.03 + loopEffect);
                    
                    // Multi-layered flame gradient with loop brightness
                    const loopBrightness = Math.max(0.3, 1 + (flame.loop ? Math.cos(flame.t * 0.05) * 0.2 : 0));
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
                    gradient.addColorStop(0, `hsla(${flame.hue}, 100%, ${Math.max(20, 70 * loopBrightness)}%, ${opacity})`);
                    gradient.addColorStop(0.3, `hsla(${flame.hue + 20}, 100%, ${Math.max(15, 60 * loopBrightness)}%, ${opacity * 0.8})`);
                    gradient.addColorStop(0.6, `hsla(${flame.hue + 40}, 90%, ${Math.max(10, 50 * loopBrightness)}%, ${opacity * 0.5})`);
                    gradient.addColorStop(1, `hsla(${flame.hue + 60}, 80%, 30%, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-currentSize/2, -currentSize/2, currentSize, currentSize);
                    
                    ctx.restore();
                }
            }

            // Korbin Fiery Apocalypse Embers - Flying fire sparks with looping
            for (const ember of vfx.korbinFireApocalypseEmbers) {
                const progress = ember.t / ember.life;
                const opacity = (1 - progress) * ember.intensity;
                
                if (isFinite(ember.x) && isFinite(ember.y) && isFinite(ember.size) && ember.size > 0) {
                    ctx.save();
                    
                    const twinkle = Math.sin(ember.t * 0.12) * 0.5 + 0.5;
                    const loopEffect = ember.loop ? Math.sin(ember.t * 0.04) * ember.loop : 0;
                    const currentSize = Math.max(0.1, ember.size * (twinkle + loopEffect)); // Ensure positive size
                    
                    // Enhanced glowing ember with loop brightness
                    const loopBrightness = Math.max(0.3, 1 + (ember.loop ? Math.cos(ember.t * 0.06) * 0.3 : 0));
                    ctx.shadowBlur = Math.max(0, currentSize * (2 + Math.abs(loopEffect || 0)));
                    ctx.shadowColor = `hsl(${ember.hue}, 100%, ${Math.max(10, 60 * loopBrightness)}%)`;
                    ctx.fillStyle = `hsla(${ember.hue}, 100%, ${Math.max(20, 70 * loopBrightness)}%, ${opacity})`;
                    
                    ctx.beginPath();
                    ctx.arc(ember.x, ember.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            // Korbin Fiery Apocalypse Explosion - Initial blast particles with looping
            for (const explosion of vfx.korbinFireApocalypseExplosion) {
                const progress = explosion.t / explosion.life;
                const opacity = (1 - progress) * explosion.intensity;
                
                if (isFinite(explosion.x) && isFinite(explosion.y) && isFinite(explosion.size) && explosion.size > 0) {
                    ctx.save();
                    
                    const pulse = Math.sin(progress * Math.PI * 4) * 0.5 + 0.5;
                    const loopEffect = explosion.loop ? Math.sin(explosion.t * 0.03) * explosion.loop : 0;
                    const currentSize = Math.max(0.1, explosion.size * (1 + pulse * 2 + loopEffect)); // Ensure positive size
                    
                    // Enhanced explosive burst gradient with loop brightness
                    const loopBrightness = Math.max(0.3, 1 + (explosion.loop ? Math.cos(explosion.t * 0.05) * 0.25 : 0));
                    const gradient = ctx.createRadialGradient(explosion.x, explosion.y, 0, explosion.x, explosion.y, currentSize);
                    gradient.addColorStop(0, `hsla(${explosion.hue}, 100%, ${Math.max(20, 80 * loopBrightness)}%, ${opacity})`);
                    gradient.addColorStop(0.5, `hsla(${explosion.hue + 30}, 100%, ${Math.max(15, 60 * loopBrightness)}%, ${opacity * 0.7})`);
                    gradient.addColorStop(1, `hsla(${explosion.hue + 60}, 80%, 40%, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            // Korbin Fiery Apocalypse Trail - Ball fire trail with looping
            for (const trail of vfx.korbinFireApocalypseTrail) {
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * trail.intensity;
                
                if (isFinite(trail.x) && isFinite(trail.y) && isFinite(trail.size) && trail.size > 0) {
                    ctx.save();
                    
                    const flow = Math.sin(trail.t * 0.1) * 0.4 + 0.6;
                    const loopEffect = trail.loop ? Math.sin(trail.t * 0.02) * trail.loop : 0;
                    const currentSize = Math.max(0.1, trail.size * (flow + loopEffect)); // Ensure positive size
                    
                    // Enhanced trailing fire effect with loop
                    const loopBrightness = Math.max(0.3, 1 + (trail.loop ? Math.cos(trail.t * 0.04) * 0.2 : 0));
                    ctx.shadowBlur = Math.max(0, currentSize * (1 + Math.abs(loopEffect || 0)));
                    ctx.shadowColor = `hsl(${trail.hue}, 100%, ${Math.max(10, 50 * loopBrightness)}%)`;
                    
                    const gradient = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, currentSize);
                    gradient.addColorStop(0, `hsla(${trail.hue}, 100%, ${Math.max(20, 70 * loopBrightness)}%, ${opacity})`);
                    gradient.addColorStop(0.4, `hsla(${trail.hue + 25}, 100%, ${Math.max(15, 60 * loopBrightness)}%, ${opacity * 0.6})`);
                    gradient.addColorStop(1, `hsla(${trail.hue + 50}, 90%, 40%, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            // Korbin Fiery Apocalypse Shockwave - Expanding fire rings with looping
            for (const shock of vfx.korbinFireApocalypseShockwave) {
                if (shock.delay && shock.delay > 0) continue;
                
                const progress = shock.t / shock.life;
                const opacity = (1 - progress) * shock.intensity;
                
                if (isFinite(shock.x) && isFinite(shock.y) && isFinite(shock.size) && shock.size > 0) {
                    ctx.save();
                    
                    const loopEffect = shock.loop ? Math.sin(shock.t * 0.02) * shock.loop * 20 : 0;
                    const expandSize = Math.max(0.1, shock.size * (1 + progress * 12 + Math.abs(loopEffect) * 0.3)); // Ensure positive size
                    
                    // Enhanced shockwave ring with loop effects
                    const loopBrightness = Math.max(0.3, 1 + (shock.loop ? Math.cos(shock.t * 0.05) * 0.3 : 0));
                    ctx.strokeStyle = `hsla(${shock.hue}, 100%, ${Math.max(10, 60 * loopBrightness)}%, ${opacity})`;
                    ctx.lineWidth = Math.max(0.5, (4 * (1 - progress)) * (1 + Math.abs(loopEffect || 0) * 0.1));
                    ctx.shadowBlur = Math.max(0, 20 * (1 + Math.abs(loopEffect || 0) * 0.5));
                    ctx.shadowColor = `hsl(${shock.hue}, 100%, ${Math.max(10, 50 * loopBrightness)}%)`;
                    
                    ctx.beginPath();
                    ctx.arc(shock.x, shock.y, expandSize, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }

            // Korbin Big Shot Wind Particles - Swirling wind effects around shot
            for (const particle of vfx.korbinBigShotWindParticles) {
                const progress = particle.t / particle.life;
                const opacity = (1 - progress) * particle.opacity;
                
                if (opacity > 0.01) {
                    ctx.save();
                    
                    const swirlOffset = Math.sin(particle.t * 0.01 + particle.swirl) * 5;
                    const size = particle.size * (1 + Math.sin(particle.t * 0.008) * 0.3);
                    
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = `rgba(200, 230, 255, ${opacity})`;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `rgba(150, 200, 255, ${opacity * 0.8})`;
                    
                    ctx.beginPath();
                    ctx.arc(particle.x + swirlOffset, particle.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            // Korbin Big Shot Wind Swirls - Larger spinning wind effects
            for (const swirl of vfx.korbinBigShotWindSwirls) {
                const progress = swirl.t / swirl.life;
                const opacity = (1 - progress) * swirl.opacity;
                
                if (opacity > 0.01) {
                    ctx.save();
                    
                    ctx.globalAlpha = opacity;
                    ctx.translate(swirl.x, swirl.y);
                    ctx.rotate(swirl.rotation);
                    
                    const size = swirl.size * (1.2 - progress * 0.3);
                    
                    // Draw spiral wind pattern
                    ctx.strokeStyle = `rgba(180, 220, 255, ${opacity})`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `rgba(180, 220, 255, ${opacity * 0.6})`;
                    
                    ctx.beginPath();
                    for (let i = 0; i < 3; i++) {
                        const spiralRadius = size * (0.3 + i * 0.3);
                        const startAngle = (i * Math.PI * 2) / 3;
                        ctx.moveTo(Math.cos(startAngle) * spiralRadius * 0.2, Math.sin(startAngle) * spiralRadius * 0.2);
                        ctx.lineTo(Math.cos(startAngle + Math.PI) * spiralRadius, Math.sin(startAngle + Math.PI) * spiralRadius);
                    }
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }

            // Korbin Big Shot Wind Trail - Wind streaks following the ball
            for (const trail of vfx.korbinBigShotWindTrail) {
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * trail.opacity;
                
                if (opacity > 0.01) {
                    ctx.save();
                    
                    const size = trail.size * (1 - progress * 0.5);
                    const windStretch = 1 + trail.windForce * 2;
                    
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = `rgba(220, 240, 255, ${opacity})`;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `rgba(180, 220, 255, ${opacity * 0.7})`;
                    
                    // Draw stretched wind particle
                    ctx.beginPath();
                    ctx.ellipse(trail.x, trail.y, size * windStretch, size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            // ========== EPIC NEW VFX SYSTEMS ==========

            // EPIC EXPLOSIONS - Massive screen-shaking detonations
            for(const explosion of vfx.epicExplosions){
                explosion.t += dt;
                const progress = explosion.t / explosion.life;
                const easeOut = 1 - Math.pow(1 - progress, 3);
                const radius = explosion.startRadius + (explosion.endRadius - explosion.startRadius) * easeOut;
                const opacity = Math.sin(progress * Math.PI) * explosion.maxOpacity;

                ctx.save();

                // Outer shockwave ring
                const shockwaveGrad = ctx.createRadialGradient(explosion.x, explosion.y, radius * 0.8, explosion.x, explosion.y, radius * 1.5);
                shockwaveGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.9})`);
                shockwaveGrad.addColorStop(0.3, `rgba(255, 100, 50, ${opacity * 0.7})`);
                shockwaveGrad.addColorStop(0.7, `rgba(255, 200, 0, ${opacity * 0.5})`);
                shockwaveGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = shockwaveGrad;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, radius * 1.2, 0, Math.PI * 2);
                ctx.fill();

                // Core explosion
                const coreGrad = ctx.createRadialGradient(explosion.x, explosion.y, 0, explosion.x, explosion.y, radius * 0.6);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                coreGrad.addColorStop(0.2, `rgba(255, 150, 100, ${opacity * 0.9})`);
                coreGrad.addColorStop(0.5, `rgba(255, 80, 80, ${opacity * 0.7})`);
                coreGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, radius * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Energy spikes radiating outward
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                ctx.lineWidth = 4;
                for(let i = 0; i < 24; i++){
                    const angle = (i / 24) * Math.PI * 2;
                    const spikeLength = radius * (0.8 + Math.sin(performance.now() * 0.02 + i) * 0.3);
                    ctx.beginPath();
                    ctx.moveTo(explosion.x + Math.cos(angle) * radius * 0.2, explosion.y + Math.sin(angle) * radius * 0.2);
                    ctx.lineTo(explosion.x + Math.cos(angle) * spikeLength, explosion.y + Math.sin(angle) * spikeLength);
                    ctx.stroke();
                }

                ctx.restore();
            }
            vfx.epicExplosions = vfx.epicExplosions.filter(e => e.t < e.life);

            // MASSIVE SHOCKWAVES - Ground-breaking waves that distort everything
            for(const wave of vfx.massiveShockwaves){
                wave.t += dt;
                const progress = wave.t / wave.life;
                const radius = wave.startRadius + (wave.endRadius - wave.startRadius) * progress;
                const opacity = Math.sin(progress * Math.PI) * wave.maxOpacity;

                ctx.save();

                // Primary wave
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                ctx.lineWidth = 8;
                ctx.shadowBlur = 20;
                ctx.shadowColor = `rgba(255, 255, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Secondary wave
                ctx.strokeStyle = `rgba(100, 200, 255, ${opacity * 0.6})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius * 1.1, 0, Math.PI * 2);
                ctx.stroke();

                // Tertiary wave
                ctx.strokeStyle = `rgba(255, 100, 255, ${opacity * 0.4})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius * 1.2, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
            vfx.massiveShockwaves = vfx.massiveShockwaves.filter(w => w.t < w.life);

            // ENERGY NOVAS - Brilliant stellar explosions
            for(const nova of vfx.energyNovas){
                nova.t += dt;
                const progress = nova.t / nova.life;
                const easeOut = 1 - Math.pow(1 - progress, 2);
                const radius = nova.startRadius + (nova.endRadius - nova.startRadius) * easeOut;
                const opacity = Math.sin(progress * Math.PI) * nova.maxOpacity;

                ctx.save();

                // Nova core with pulsing brightness
                const pulse = Math.sin(performance.now() * 0.02) * 0.3 + 0.7;
                const novaGrad = ctx.createRadialGradient(nova.x, nova.y, 0, nova.x, nova.y, radius);
                novaGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity * pulse})`);
                novaGrad.addColorStop(0.1, `rgba(255, 200, 150, ${opacity * 0.8})`);
                novaGrad.addColorStop(0.3, `rgba(150, 100, 255, ${opacity * 0.6})`);
                novaGrad.addColorStop(0.6, `rgba(100, 150, 255, ${opacity * 0.4})`);
                novaGrad.addColorStop(1, 'rgba(50, 50, 255, 0)');
                ctx.fillStyle = novaGrad;
                ctx.beginPath();
                ctx.arc(nova.x, nova.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Stellar rays
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
                ctx.lineWidth = 3;
                for(let i = 0; i < 16; i++){
                    const angle = (i / 16) * Math.PI * 2 + performance.now() * 0.001;
                    const rayLength = radius * (1.2 + Math.sin(performance.now() * 0.01 + i) * 0.4);
                    ctx.beginPath();
                    ctx.moveTo(nova.x, nova.y);
                    ctx.lineTo(nova.x + Math.cos(angle) * rayLength, nova.y + Math.sin(angle) * rayLength);
                    ctx.stroke();
                }

                ctx.restore();
            }
            vfx.energyNovas = vfx.energyNovas.filter(n => n.t < n.life);

            // SAJA-JIN VFX Cleanup
            for(const aura of vfx.sajaJinDemonicAura) { aura.t += dt; }
            vfx.sajaJinDemonicAura = vfx.sajaJinDemonicAura.filter(aura => aura.t < aura.life);

            for(const trail of vfx.sajaJinSoulTrail) { trail.t = performance.now(); }
            vfx.sajaJinSoulTrail = vfx.sajaJinSoulTrail.filter(trail => performance.now() <= trail.end);

            for(const particle of vfx.sajaJinSoulParticles) { particle.t += dt; }
            vfx.sajaJinSoulParticles = vfx.sajaJinSoulParticles.filter(particle => particle.t < particle.life);

            for(const glow of vfx.sajaJinHypnoticGlow) { glow.t += dt; }
            vfx.sajaJinHypnoticGlow = vfx.sajaJinHypnoticGlow.filter(glow => glow.t < glow.life);

            for(const trail of vfx.sajaJinHypnoticTrail) { trail.t += dt; }
            vfx.sajaJinHypnoticTrail = vfx.sajaJinHypnoticTrail.filter(trail => trail.t < trail.life);
           
            for(const trail of vfx.sajaJinHypnoticSpinTrail) { trail.t += dt; }
            vfx.sajaJinHypnoticSpinTrail = vfx.sajaJinHypnoticSpinTrail.filter(trail => trail.t < trail.life);
           
            for(const caption of vfx.sajaJinHypnoticCaption) { caption.t += dt; }
            vfx.sajaJinHypnoticCaption = vfx.sajaJinHypnoticCaption.filter(caption => caption.t < caption.life);
           
            for(const burst of vfx.sajaJinHypnoticBurst) { burst.t += dt; }
            vfx.sajaJinHypnoticBurst = vfx.sajaJinHypnoticBurst.filter(burst => burst.t < burst.life);

            for(const wisp of vfx.sajaJinGhostTrail) { wisp.t += dt; }
            vfx.sajaJinGhostTrail = vfx.sajaJinGhostTrail.filter(wisp => wisp.t < wisp.life);

            // ABBY VFX Cleanup (placeholders - harmless if arrays stay empty)
            for(const trail of vfx.abbyColossalCalvesTrail){ trail.t = (trail.t||0) + dt; }
            vfx.abbyColossalCalvesTrail = vfx.abbyColossalCalvesTrail.filter(trail => !trail.life || trail.t < trail.life);
            for(const spark of vfx.abbyPowerPinSparks){ spark.t = (spark.t||0) + dt; }
            vfx.abbyPowerPinSparks = vfx.abbyPowerPinSparks.filter(spark => !spark.life || spark.t < spark.life);
            for(const aura of vfx.abbyDemonDriveAura){ aura.t = (aura.t||0) + dt; }
            vfx.abbyDemonDriveAura = vfx.abbyDemonDriveAura.filter(aura => !aura.life || aura.t < aura.life);

            // LINCOLN GYATT SHOWDOWN VFX Cleanup
            for(const aura of vfx.lincolnGyattAura) { aura.t += dt; }
            vfx.lincolnGyattAura = vfx.lincolnGyattAura.filter(aura => aura.t < aura.life);
            
            for(const trail of vfx.lincolnGyattTrail) { trail.t += dt; }
            vfx.lincolnGyattTrail = vfx.lincolnGyattTrail.filter(trail => trail.t < trail.life);
            
            for(const particle of vfx.lincolnGyattParticles) { particle.t += dt; }
            vfx.lincolnGyattParticles = vfx.lincolnGyattParticles.filter(particle => particle.t < particle.life);

            // KORBIN FIERY APOCALYPSE VFX UPDATES
            for(const flame of vfx.korbinFireApocalypseFlames) {
                flame.t += dt;
                flame.x += flame.vx * (dt / 16);
                flame.y += flame.vy * (dt / 16);
                flame.vx *= 0.99; // Slight dampening
                flame.vy *= 0.99;
            }
            vfx.korbinFireApocalypseFlames = vfx.korbinFireApocalypseFlames.filter(f => f.t < f.life);

            for(const ember of vfx.korbinFireApocalypseEmbers) {
                ember.t += dt;
                ember.x += ember.vx * (dt / 16);
                ember.y += ember.vy * (dt / 16);
                ember.vy += (ember.gravity || 0) * (dt / 16); // Gravity effect
                ember.vx *= 0.995; // Air resistance
            }
            vfx.korbinFireApocalypseEmbers = vfx.korbinFireApocalypseEmbers.filter(e => e.t < e.life);

            for(const explosion of vfx.korbinFireApocalypseExplosion) {
                explosion.t += dt;
                explosion.x += explosion.vx * (dt / 16);
                explosion.y += explosion.vy * (dt / 16);
                explosion.vx *= 0.98;
                explosion.vy *= 0.98;
            }
            vfx.korbinFireApocalypseExplosion = vfx.korbinFireApocalypseExplosion.filter(e => e.t < e.life);

            for(const trail of vfx.korbinFireApocalypseTrail) {
                trail.t += dt;
                trail.x += trail.vx * (dt / 16);
                trail.y += trail.vy * (dt / 16);
                trail.vx *= 0.97;
                trail.vy *= 0.97;
            }
            vfx.korbinFireApocalypseTrail = vfx.korbinFireApocalypseTrail.filter(t => t.t < t.life);

            for(const shock of vfx.korbinFireApocalypseShockwave) {
                if (shock.delay && shock.delay > 0) {
                    shock.delay -= dt;
                    continue;
                }
                shock.t += dt;
                shock.x += shock.vx * (dt / 16);
                shock.y += shock.vy * (dt / 16);
                shock.vx *= 0.99;
                shock.vy *= 0.99;
            }
            vfx.korbinFireApocalypseShockwave = vfx.korbinFireApocalypseShockwave.filter(s => s.t < s.life);

            // ========== KORBIN BIG BACK POWER VFX RENDERING ==========
            
            // Wind Trail Effects
            for (const trail of vfx.korbinBigBackPowerWindTrail) {
                trail.t += dt;
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * trail.intensity;
                const size = trail.size * (1 + progress * 0.5);
                
                if (isFinite(trail.x) && isFinite(trail.y) && trail.size > 0) {
                    ctx.save();
                    
                    trail.x += trail.vx * (dt / 16);
                    trail.y += trail.vy * (dt / 16);
                    
                    // Wind swirl effect
                    const swirl = Math.sin(trail.t * 0.05) * trail.spin;
                    ctx.translate(trail.x, trail.y);
                    ctx.rotate(swirl);
                    
                    // Wind gradient (light blue/white)
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                    gradient.addColorStop(0, `rgba(220, 240, 255, ${opacity})`);
                    gradient.addColorStop(0.5, `rgba(180, 220, 255, ${opacity * 0.6})`);
                    gradient.addColorStop(1, `rgba(150, 200, 255, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-size/2, -size/2, size, size);
                    
                    ctx.restore();
                }
            }
            vfx.korbinBigBackPowerWindTrail = vfx.korbinBigBackPowerWindTrail.filter(t => t.t < t.life);
            
            // Wind Burst Effects
            for (const burst of vfx.korbinBigBackPowerWindBurst) {
                burst.t += dt;
                const progress = burst.t / burst.life;
                const opacity = (1 - progress) * burst.intensity;
                const size = burst.size * (1 + progress * 2);
                
                if (isFinite(burst.x) && isFinite(burst.y) && burst.size > 0) {
                    ctx.save();
                    
                    burst.x += burst.vx * (dt / 16);
                    burst.y += burst.vy * (dt / 16);
                    burst.vx *= 0.98;
                    burst.vy *= 0.98;
                    
                    // Spiral motion
                    burst.spiral += 0.1;
                    const spiralX = Math.cos(burst.spiral) * 5;
                    const spiralY = Math.sin(burst.spiral) * 5;
                    
                    ctx.translate(burst.x + spiralX, burst.y + spiralY);
                    ctx.rotate(burst.spiral);
                    
                    // Wind burst gradient
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                    gradient.addColorStop(0, `rgba(240, 250, 255, ${opacity})`);
                    gradient.addColorStop(0.3, `rgba(200, 230, 255, ${opacity * 0.7})`);
                    gradient.addColorStop(1, `rgba(160, 210, 255, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-size/2, -size/2, size, size);
                    
                    ctx.restore();
                }
            }
            vfx.korbinBigBackPowerWindBurst = vfx.korbinBigBackPowerWindBurst.filter(b => b.t < b.life);
            
            // Wind Shockwave Effects
            for (const shock of vfx.korbinBigBackPowerShockwave) {
                if (shock.delay > 0) {
                    shock.delay -= dt;
                    continue;
                }
                
                shock.t += dt;
                const progress = shock.t / shock.life;
                const opacity = (1 - progress) * shock.intensity;
                const expandSize = shock.size * (1 + progress * 8);
                
                if (isFinite(shock.x) && isFinite(shock.y) && expandSize > 0) {
                    ctx.save();
                    
                    shock.x += shock.vx * (dt / 16);
                    shock.y += shock.vy * (dt / 16);
                    shock.vx *= 0.95;
                    shock.vy *= 0.95;
                    
                    // Dynamic loop effect
                    const loopEffect = shock.loop ? Math.cos(shock.t * 0.08) * shock.loop : 0;
                    const loopBrightness = Math.max(0.5, 1 + loopEffect);
                    
                    ctx.strokeStyle = `rgba(200, 240, 255, ${opacity * loopBrightness})`;
                    ctx.lineWidth = Math.max(1, 4 - progress * 2);
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `rgba(180, 220, 255, ${opacity * 0.8})`;
                    
                    ctx.beginPath();
                    ctx.arc(shock.x, shock.y, expandSize, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
            vfx.korbinBigBackPowerShockwave = vfx.korbinBigBackPowerShockwave.filter(s => s.t < s.life);

            // ========== KORBIN BIG SHOT WIND VFX UPDATES ==========
            
            // Wind Particles
            for (const particle of vfx.korbinBigShotWindParticles) {
                particle.t += dt;
                particle.x += particle.vx * (dt / 16);
                particle.y += particle.vy * (dt / 16);
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                
                // Add swirling motion
                const swirlForce = Math.sin(particle.t * 0.01) * 0.3;
                particle.vx += swirlForce;
                particle.vy += Math.cos(particle.t * 0.01) * 0.3;
            }
            vfx.korbinBigShotWindParticles = vfx.korbinBigShotWindParticles.filter(p => p.t < p.life);
            
            // Wind Swirls
            for (const swirl of vfx.korbinBigShotWindSwirls) {
                swirl.t += dt;
                swirl.x += swirl.vx * (dt / 16);
                swirl.y += swirl.vy * (dt / 16);
                swirl.vx *= 0.96;
                swirl.vy *= 0.96;
                swirl.rotation += swirl.rotSpeed * (dt / 16);
                
                // Slight outward expansion
                const expansionForce = 0.2;
                const centerDist = Math.hypot(swirl.vx, swirl.vy);
                if (centerDist > 0) {
                    swirl.vx += (swirl.vx / centerDist) * expansionForce;
                    swirl.vy += (swirl.vy / centerDist) * expansionForce;
                }
            }
            vfx.korbinBigShotWindSwirls = vfx.korbinBigShotWindSwirls.filter(s => s.t < s.life);
            
            // Wind Trail
            for (const trail of vfx.korbinBigShotWindTrail) {
                trail.t += dt;
                trail.x += trail.vx * (dt / 16);
                trail.y += trail.vy * (dt / 16);
                trail.vx *= 0.95;
                trail.vy *= 0.95;
                
                // Reduce wind force over time
                trail.windForce *= 0.99;
            }
            vfx.korbinBigShotWindTrail = vfx.korbinBigShotWindTrail.filter(t => t.t < t.life);

            // WALLY VFX RENDERING
            // Rocket Boost Trail
            for (const t of vfx.wallyRocketTrail) {
                t.t += dt;
                const progress = t.t / t.life;
                const opacity = (1 - progress) * t.intensity;
                const size = t.size * (1 - progress * 0.5);
                
                const grd = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, size * 3);
                grd.addColorStop(0, `hsla(${t.hue}, 90%, 60%, ${opacity})`);
                grd.addColorStop(1, `hsla(${t.hue}, 90%, 60%, 0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                t.x += t.vx;
                t.y += t.vy;
                t.vx *= 0.95;
                t.vy *= 0.95;
            }
            vfx.wallyRocketTrail = vfx.wallyRocketTrail.filter(t => t.t < t.life);

            // Speed Force Dome
            for (const d of vfx.wallySpeedForceDome) {
                d.t += dt;
                const progress = d.t / d.life;
                const opacity = Math.sin(progress * Math.PI) * d.intensity;
                
                ctx.strokeStyle = `hsla(${d.hue}, 80%, 70%, ${opacity})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x, player.y, d.radius, d.angle, d.angle + Math.PI / 20);
                ctx.stroke();
            }
            vfx.wallySpeedForceDome = vfx.wallySpeedForceDome.filter(d => d.t < d.life);

            // Lightning Aura
            for (const a of vfx.wallyLightningAura) {
                a.t += dt;
                const progress = a.t / a.life;
                const opacity = (1 - progress) * a.intensity;
                const size = a.size * (1 + progress * 0.3);
                
                if (a.spark) {
                    // Draw spark effect
                    ctx.strokeStyle = `hsla(${a.hue}, 100%, 90%, ${opacity})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(a.x - size, a.y);
                    ctx.lineTo(a.x + size, a.y);
                    ctx.moveTo(a.x, a.y - size);
                    ctx.lineTo(a.x, a.y + size);
                    ctx.stroke();
                } else {
                    const grd = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, size * 2);
                    grd.addColorStop(0, `hsla(${a.hue}, 100%, 80%, ${opacity})`);
                    grd.addColorStop(1, `hsla(${a.hue}, 100%, 80%, 0)`);
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(a.x, a.y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                a.x += a.vx;
                a.y += a.vy;
            }
            vfx.wallyLightningAura = vfx.wallyLightningAura.filter(a => a.t < a.life);

            // Lightning Bolts
            for (const b of vfx.wallyLightningBolts) {
                b.t += dt;
                const progress = b.t / b.life;
                const opacity = (1 - progress) * b.intensity;
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.lineWidth = b.width;
                ctx.beginPath();
                
                // Draw jagged lightning bolt
                const dx = b.targetX - b.x;
                const dy = b.targetY - b.y;
                const segments = b.segments;
                
                ctx.moveTo(b.x, b.y);
                for (let i = 1; i <= segments; i++) {
                    const segmentProgress = i / segments;
                    const baseX = b.x + dx * segmentProgress;
                    const baseY = b.y + dy * segmentProgress;
                    const jitter = 10;
                    const offsetX = (Math.random() - 0.5) * jitter;
                    const offsetY = (Math.random() - 0.5) * jitter;
                    ctx.lineTo(baseX + offsetX, baseY + offsetY);
                }
                ctx.stroke();
            }
            vfx.wallyLightningBolts = vfx.wallyLightningBolts.filter(b => b.t < b.life);

            // 67 KID VFX RENDERING
            // 67 Text Clones - Enhanced with rotation and color effects
            for (const text of vfx.sixtySevenKidTextClones) {
                text.t += dt;
                const progress = text.t / text.life;
                const opacity = (1 - progress) * 0.9;
                const rotation = text.rotation + (text.rotationSpeed * dt);
                text.rotation = rotation;
                
                // Validation to prevent rendering errors
                if (!isFinite(text.x) || !isFinite(text.y) || !isFinite(rotation) || 
                    !isFinite(text.size) || !isFinite(opacity) || text.size <= 0) {
                    continue;
                }
                
                ctx.save();
                ctx.translate(text.x, text.y);
                ctx.rotate(rotation);
                ctx.scale(text.size, text.size);
                
                // Create glowing text effect
                ctx.globalCompositeOperation = 'lighter';
                ctx.shadowBlur = 20;
                ctx.shadowColor = `rgba(0, 188, 212, ${opacity * 0.8})`;
                ctx.fillStyle = `rgba(0, 188, 212, ${opacity})`;
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('67', 0, 0);
                
                // Inner glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = `rgba(255, 255, 255, ${opacity})`;
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.6})`;
                ctx.fillText('67', 0, 0);
                
                ctx.restore();
            }
            vfx.sixtySevenKidTextClones = vfx.sixtySevenKidTextClones.filter(t => t.t < t.life);
            
            // 67 Mayhem Aura
            for (const aura of vfx.sixtySevenKidMayhemAura) {
                aura.t += dt;
                const progress = aura.t / aura.life;
                const opacity = (1 - progress) * 0.7;
                const currentRadius = aura.radius * (1 + progress * 0.5);
                
                // Validation to prevent createRadialGradient errors
                if (!isFinite(aura.x) || !isFinite(aura.y) || !isFinite(currentRadius) || 
                    !isFinite(opacity) || currentRadius <= 0) {
                    continue;
                }
                
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const auraGrad = ctx.createRadialGradient(aura.x, aura.y, 0, aura.x, aura.y, currentRadius);
                auraGrad.addColorStop(0, `rgba(0, 188, 212, ${opacity * 0.8})`);
                auraGrad.addColorStop(0.5, `rgba(33, 150, 243, ${opacity * 0.6})`);
                auraGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(aura.x, aura.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            vfx.sixtySevenKidMayhemAura = vfx.sixtySevenKidMayhemAura.filter(a => a.t < a.life);
            
            // Blackout Overlay
            for (const overlay of vfx.sixtySevenKidBlackoutOverlay) {
                overlay.t += dt;
                const progress = overlay.t / overlay.life;
                const opacity = overlay.opacity * Math.sin(progress * Math.PI);
                
                // Validation to prevent rendering errors
                if (!isFinite(opacity) || opacity < 0) {
                    continue;
                }
                
                ctx.save();
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillStyle = `rgba(0, 0, 0, ${Math.min(1, Math.max(0, opacity))})`;
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }
            vfx.sixtySevenKidBlackoutOverlay = vfx.sixtySevenKidBlackoutOverlay.filter(o => o.t < o.life);

            // PARTICLE STORMS - Dense clouds of energy particles
            for(const storm of vfx.particleStorms){
                storm.t += dt;
                const progress = storm.t / storm.life;
                const opacity = Math.sin(progress * Math.PI) * storm.intensity;

                for(let i = 0; i < storm.particles.length; i++){
                    const p = storm.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.99;
                    p.vy *= 0.99;

                    const particleGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 3);
                    particleGrad.addColorStop(0, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${opacity})`);
                    particleGrad.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, 0)`);
                    ctx.fillStyle = particleGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            vfx.particleStorms = vfx.particleStorms.filter(s => s.t < s.life);

            // CRISTIANO VFX RENDERING - ENHANCED POWER SHOT
            // Devastating Power Shot Trail - GOAT-level enhanced effects with Portuguese power
            for(const trail of vfx.cristianoPowerShotTrail){
                trail.t += dt;
                const f = 1 - trail.t / trail.life;
                const intensity = trail.intensity || 1;
                const a = f * 0.95 * intensity;
                const goatPower = Math.sin(trail.t * 0.02) * 0.3 + 0.7;

                ctx.save();
                
                // Legendary aura - Massive outer field
                ctx.globalCompositeOperation = 'screen';
                const legendGrad = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                legendGrad.addColorStop(0, `rgba(255, 215, 0, ${a * 0.4})`);
                legendGrad.addColorStop(0.5, `rgba(255, 50, 50, ${a * 0.6})`);
                legendGrad.addColorStop(1, `rgba(22, 163, 74, ${a * 0.4})`);
                ctx.strokeStyle = legendGrad;
                ctx.lineWidth = 35 * intensity * goatPower;
                ctx.shadowBlur = 40;
                ctx.shadowColor = `rgba(255, 215, 0, ${a})`;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(trail.startX, trail.startY);
                ctx.lineTo(trail.endX, trail.endY);
                ctx.stroke();
                
                ctx.globalCompositeOperation = 'source-over';

                // Outer glow layer - Portuguese flag energy
                ctx.shadowBlur = 25;
                ctx.shadowColor = `rgba(255, 215, 0, ${a * 0.8})`;
                const outerGlow = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                outerGlow.addColorStop(0, `rgba(255, 50, 50, ${a})`); // Intense red
                outerGlow.addColorStop(0.2, `rgba(255, 215, 0, ${a * 0.95})`); // Gold
                outerGlow.addColorStop(0.4, `rgba(255, 255, 255, ${a * 0.9})`); // Bright white
                outerGlow.addColorStop(0.6, `rgba(255, 215, 0, ${a * 0.8})`); // Gold again
                outerGlow.addColorStop(0.8, `rgba(22, 163, 74, ${a * 0.7})`); // Portuguese green
                outerGlow.addColorStop(1, `rgba(255, 50, 50, ${a * 0.6})`); // Red end

                ctx.strokeStyle = outerGlow;
                ctx.lineWidth = 22 * intensity * goatPower;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(trail.startX, trail.startY);
                ctx.lineTo(trail.endX, trail.endY);
                ctx.stroke();

                // Inner core - Pure GOAT power with pulsing
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(255, 255, 255, ${a})`;
                const innerCore = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                innerCore.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                innerCore.addColorStop(0.3, `rgba(255, 215, 0, ${a * 0.95})`);
                innerCore.addColorStop(0.7, `rgba(255, 255, 255, ${a * 0.9})`);
                innerCore.addColorStop(1, `rgba(255, 215, 0, ${a * 0.8})`);

                ctx.strokeStyle = innerCore;
                ctx.lineWidth = 12 * intensity * goatPower;
                ctx.beginPath();
                ctx.moveTo(trail.startX, trail.startY);
                ctx.lineTo(trail.endX, trail.endY);
                ctx.stroke();
                
                // Ultra-bright core streak
                ctx.strokeStyle = `rgba(255, 255, 255, ${a * 0.9})`;
                ctx.lineWidth = 4 * intensity;
                ctx.shadowBlur = 8;
                ctx.shadowColor = `rgba(255, 255, 255, ${a})`;
                ctx.beginPath();
                ctx.moveTo(trail.startX, trail.startY);
                ctx.lineTo(trail.endX, trail.endY);
                ctx.stroke();

                ctx.restore();
            }
            vfx.cristianoPowerShotTrail = vfx.cristianoPowerShotTrail.filter(trail => trail.t < trail.life);

            // GOAT Tackle Particles - LEGENDARY golden explosion effects with Portuguese pride
            for(const p of vfx.cristianoGoatTackleParticles){
                p.t += dt;
                const f = 1 - p.t / p.life;
                const a = f * 0.9;
                p.x += p.vx * (dt/16);
                p.y += p.vy * (dt/16);
                p.vx *= 0.96;
                p.vy *= 0.96;

                ctx.save();

                if (p.isExplosion) {
                    // LEGENDARY explosion particles - divine golden bursts
                    const goatGlow = Math.sin(p.t * 0.03) * 0.4 + 0.6;
                    ctx.shadowBlur = 25 * goatGlow;
                    ctx.shadowColor = `rgba(255, 215, 0, ${a})`;
                    const size = Math.max(0.1, p.size * f * goatGlow);
                    
                    // Outer divine aura
                    const divineGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 3);
                    divineGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                    divineGrad.addColorStop(0.2, `rgba(255, 215, 0, ${a * 0.9})`);
                    divineGrad.addColorStop(0.5, `rgba(255, 140, 0, ${a * 0.7})`);
                    divineGrad.addColorStop(0.8, `rgba(220, 38, 38, ${a * 0.5})`);
                    divineGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = divineGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Core explosion
                    const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 1.5);
                    coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                    coreGrad.addColorStop(0.3, `rgba(255, 215, 0, ${a * 0.9})`);
                    coreGrad.addColorStop(0.7, `rgba(255, 140, 0, ${a * 0.7})`);
                    coreGrad.addColorStop(1, `rgba(220, 38, 38, ${a * 0.4})`);
                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (p.isPowerShotExplosion) {
                    // Enhanced power shot explosion particles with Portuguese fury
                    const furyPulse = Math.sin(p.t * 0.04) * 0.5 + 0.5;
                    ctx.shadowBlur = 20 * furyPulse;
                    ctx.shadowColor = `rgba(255, 50, 50, ${a})`;
                    const size = Math.max(0.1, p.size * f);
                    
                    // Portuguese flag explosion layers
                    const flagGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2);
                    flagGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                    flagGrad.addColorStop(0.3, `rgba(255, 50, 50, ${a * 0.9})`);
                    flagGrad.addColorStop(0.6, `rgba(255, 215, 0, ${a * 0.7})`);
                    flagGrad.addColorStop(0.9, `rgba(22, 163, 74, ${a * 0.5})`);
                    flagGrad.addColorStop(1, `rgba(255, 100, 0, ${a * 0.3})`);
                    ctx.fillStyle = flagGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size * furyPulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (p.isEnergyBurst) {
                    // Portuguese Spirit energy burst particles with national pride
                    const size = Math.max(0.1, p.size * f);
                    const prideSparkle = Math.sin(p.t * 0.02) * 0.4 + 0.6;
                    ctx.shadowBlur = 15 * prideSparkle;
                    ctx.shadowColor = `rgba(22, 163, 74, ${a * prideSparkle})`;
                    
                    // Multi-layer Portuguese spirit
                    const spiritGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2.5);
                    spiritGrad.addColorStop(0, `rgba(255, 255, 255, ${a * prideSparkle})`);
                    spiritGrad.addColorStop(0.3, `rgba(22, 163, 74, ${a * 0.9})`);
                    spiritGrad.addColorStop(0.6, `rgba(255, 215, 0, ${a * 0.7})`);
                    spiritGrad.addColorStop(0.9, `rgba(220, 38, 38, ${a * 0.5})`);
                    spiritGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = spiritGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size * prideSparkle, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else {
                    // Enhanced regular tackle particles with GOAT brilliance
                    const brilliance = Math.sin(p.t * 0.01) * 0.3 + 0.7;
                    const goatShine = Math.sin(p.t * 0.02) * 0.4 + 0.6;
                    ctx.shadowBlur = 15 * brilliance;
                    ctx.shadowColor = `rgba(255, 215, 0, ${a * 0.8})`;
                    
                    // Outer golden aura
                    const goldenGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
                    goldenGrad.addColorStop(0, `rgba(255, 215, 0, ${a * brilliance})`);
                    goldenGrad.addColorStop(0.4, `rgba(255, 255, 255, ${a * 0.7 * goatShine})`);
                    goldenGrad.addColorStop(0.8, `rgba(255, 165, 0, ${a * 0.4})`);
                    goldenGrad.addColorStop(1, `rgba(255, 165, 0, 0)`);
                    ctx.fillStyle = goldenGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Core golden particle
                    const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * brilliance);
                    coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                    coreGrad.addColorStop(0.5, `rgba(255, 215, 0, ${a * 0.9})`);
                    coreGrad.addColorStop(1, `rgba(255, 165, 0, ${a * 0.6})`);
                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * brilliance, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
            vfx.cristianoGoatTackleParticles = vfx.cristianoGoatTackleParticles.filter(p => p.t < p.life);

            // Portuguese Spirit Aura - Portuguese flag colors swirling
            for(const aura of vfx.cristianoPortugueseSpiritAura){
                aura.t += dt;
                const f = 1 - aura.t / aura.life;
                const a = f * 0.4;
                const pulse = Math.sin(aura.t * 0.005) * 0.3 + 0.7;

                ctx.save();
                ctx.translate(aura.x, aura.y);

                // Portuguese flag inspired rotating aura
                const rotation = aura.t * 0.002;
                for(let ring = 0; ring < 3; ring++){
                    const radius = aura.radius * (0.5 + ring * 0.25) * pulse;
                    const ringOpacity = a * (1 - ring * 0.3);

                    // Red section
                    const redGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    redGradient.addColorStop(0, `rgba(220, 20, 60, ${ringOpacity})`);
                    redGradient.addColorStop(1, `rgba(220, 20, 60, 0)`);
                    ctx.fillStyle = redGradient;

                    ctx.beginPath();
                    ctx.arc(0, 0, radius, rotation, rotation + Math.PI);
                    ctx.fill();

                    // Green section
                    const greenGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    greenGradient.addColorStop(0, `rgba(34, 139, 34, ${ringOpacity})`);
                    greenGradient.addColorStop(1, `rgba(34, 139, 34, 0)`);
                    ctx.fillStyle = greenGradient;

                    ctx.beginPath();
                    ctx.arc(0, 0, radius, rotation + Math.PI, rotation + Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
            vfx.cristianoPortugueseSpiritAura = vfx.cristianoPortugueseSpiritAura.filter(aura => aura.t < aura.life);

            // Movement Trail - Dynamic red/green speed lines
            for(const trail of vfx.cristianoMovementTrail){
                trail.t += dt;
                const f = 1 - trail.t / trail.life;
                const a = f * 0.7;

                // Validate coordinates before creating gradient
                if (isFinite(trail.x) && isFinite(trail.y) && isFinite(trail.vx) && isFinite(trail.vy)) {
                    // Update position for energy burst particles
                    if (trail.isEnergyBurst || trail.isPowerShotExplosion) {
                        trail.x += trail.vx * (dt/16);
                        trail.y += trail.vy * (dt/16);
                        trail.vx *= 0.98;
                        trail.vy *= 0.98;

                        // Draw as particles instead of trails for energy bursts
                        const size = Math.max(0.1, trail.size * f);
                        const g = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, Math.max(0.1, size));
                        if (trail.isEnergyBurst) {
                            g.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                            g.addColorStop(0.5, `rgba(22, 163, 74, ${a * 0.8})`);
                            g.addColorStop(1, `rgba(220, 38, 38, ${a * 0.4})`);
                        } else {
                            g.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                            g.addColorStop(0.5, `rgba(255, 50, 50, ${a * 0.8})`);
                            g.addColorStop(1, `rgba(255, 215, 0, ${a * 0.6})`);
                        }
                        ctx.fillStyle = g;
                        ctx.beginPath();
                        ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (trail.startX && trail.startY && trail.endX && trail.endY &&
                             isFinite(trail.startX) && isFinite(trail.startY) && isFinite(trail.endX) && isFinite(trail.endY)) {
                        // Draw as trail lines for regular movement trails
                        const g = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                        g.addColorStop(0, `rgba(220, 20, 60, ${a})`); // Red
                        g.addColorStop(0.5, `rgba(255, 255, 255, ${a * 0.5})`); // White
                        g.addColorStop(1, `rgba(34, 139, 34, ${a})`); // Green

                        ctx.strokeStyle = g;
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(trail.startX, trail.startY);
                        ctx.lineTo(trail.endX, trail.endY);
                        ctx.stroke();
                    }
                }
            }
            vfx.cristianoMovementTrail = vfx.cristianoMovementTrail.filter(trail => trail.t < trail.life);

            // LINCOLN ENHANCED SHREK VFX RENDERING
            // Lincoln Shrek Trail Particles - Enhanced swamp energy
            for(const p of vfx.lincolnShrekTrail){
                const f = 1 - p.t / p.life;
                const a = f * 0.9;
                const pulse = Math.sin(p.t * 0.01) * 0.3 + 0.7;
               
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
               
                const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
                g.addColorStop(0, `rgba(144, 238, 144, ${a * pulse})`);
                g.addColorStop(0.5, `rgba(50, 205, 50, ${a * 0.8})`);
                g.addColorStop(1, `rgba(34, 139, 34, 0)`);
               
                ctx.fillStyle = g;
                ctx.shadowBlur = 10;
                ctx.shadowColor = `rgba(50, 205, 50, ${a * 0.6})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * pulse, 0, Math.PI * 2);
                ctx.fill();
               
                ctx.restore();
            }

            // Lincoln Shrek Main Particles - Enhanced effects with glow
            for(const p of vfx.lincolnShrekParticles){
                const f = 1 - p.t / p.life;
                const a = f * 0.9;
                const glowPulse = Math.sin(p.t * 0.015) * 0.4 + 0.6;
               
                ctx.save();
               
                if(p.glow) {
                    ctx.globalCompositeOperation = 'screen';
                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3.5);
                    g.addColorStop(0, `rgba(255, 255, 255, ${a * glowPulse})`);
                    g.addColorStop(0.4, p.color.replace(')', `, ${a * 0.8})`));
                    g.addColorStop(1, p.color.replace(')', ', 0)'));
                   
                    ctx.fillStyle = g;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = p.color.replace(')', `, ${a})`);
                } else {
                    ctx.globalCompositeOperation = 'lighter';
                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2.5);
                    g.addColorStop(0, p.color.replace(')', `, ${a * glowPulse})`));
                    g.addColorStop(1, p.color.replace(')', ', 0)'));
                    ctx.fillStyle = g;
                }
               
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * glowPulse, 0, Math.PI * 2);
                ctx.fill();
               
                ctx.restore();
            }

        }



        // NEW BABY OIL GUY ABILITY FUNCTIONS
        function tryDiddyBabyOilAscension() {
            const now = performance.now();
            if (currentStyle !== 'diddy') return;

            // Check if player has ball - can only use when NOT having ball
            if (player.hasBall) {
                showNotification('cant use baby oil ascension while holding ball', 'error');
                return;
            }

            // Check cooldown
            if (now < diddyBabyOilReadyAt) {
                const cooldownLeft = Math.ceil((diddyBabyOilReadyAt - now) / 1000);
                showNotification(`Baby Oil Ascension on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (player.diddyBabyOilActive) return;

            // Start the baby oil sequence
            player.diddyBabyOilActive = true;
            player.diddyBabyOilPhase = 'subtitle1';
            player.diddyBabyOilStartTime = now;

            // Show first subtitle with typewriter effect
            showBabyOilGuySubtitle('Yo theres the ball! baby oil help me!', () => {
                player.diddyBabyOilPhase = 'running';

                // Auto teleport to ball after subtitle
                const distance = Math.sqrt((ball.x - player.x) ** 2 + (ball.y - player.y) ** 2);
                const teleportSteps = 15;
                const stepX = (ball.x - player.x) / teleportSteps;
                const stepY = (ball.y - player.y) / teleportSteps;

                let step = 0;
                const teleportInterval = setInterval(() => {
                    if (step < teleportSteps) {
                        player.x += stepX;
                        player.y += stepY;

                        // Add oil particle trail during teleport
                        vfx.diddyOilParticles.push({
                            x: player.x + (Math.random() - 0.5) * 20,
                            y: player.y + (Math.random() - 0.5) * 20,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                            life: 800,
                            t: 0,
                            r: 2 + Math.random() * 3,
                            opacity: 0.8
                        });
                        step++;
                    } else {
                        clearInterval(teleportInterval);

                        // Grab the ball and start ascension
                        player.hasBall = true;
                        ball.vx = 0;
                        ball.vy = 0;

                        player.diddyBabyOilPhase = 'ascension';

                        // Create dramatic ascension effects
                        for(let i = 0; i < 20; i++){
                            vfx.diddyAscensionVFX.push({
                                x: ball.x + (Math.random() - 0.5) * 50,
                                y: ball.y + (Math.random() - 0.5) * 50,
                                speed: 1 + Math.random() * 2,
                                life: 1500 + Math.random() * 500,
                                t: 0,
                                r: 8 + Math.random() * 6
                            });
                        }

                        // Ball ascends with golden glow
                        setTimeout(() => {
                            player.diddyBabyOilPhase = 'subtitle2';
                            showBabyOilGuySubtitle('Thanks baby oil :D)', () => {
                                player.diddyBabyOilActive = false;
                                player.diddyBabyOilPhase = '';
                            });
                        }, 1000);
                    }
                }, 50); // 50ms per step for smooth teleport
            });

            diddyBabyOilReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryDiddySlickShot() {
            const now = performance.now();
            if (currentStyle !== 'diddy') return;

            if (now < diddySlickShotReadyAt) {
                const cooldownLeft = Math.ceil((diddySlickShotReadyAt - now) / 1000);
                showNotification(`Slick Shot on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('Need ball for Slick Shot!', 'error');
                return;
            }

            // Fire slippery shot
            const shootDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.vx = Math.cos(shootDir) * DIDDY_SLICK_SHOT_POWER + player.vx * 0.2;
            ball.vy = Math.sin(shootDir) * DIDDY_SLICK_SHOT_POWER + player.vy * 0.2;

            // Add oil trail to ball
            ball.hasOilTrail = true;
            ball.oilTrailEndTime = now + 1000;

            player.hasBall = false;
            diddySlickShotReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryDiddyOilSlickTrap() {
            const now = performance.now();
            if (currentStyle !== 'diddy') return;

            if (now < diddyOilSlickReadyAt) {
                const cooldownLeft = Math.ceil((diddyOilSlickReadyAt - now) / 1000);
                showNotification(`Baby Oil Blindness on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            // Create oil slick at mouse position with burst effect
            vfx.diddyOilSlicks.push({
                x: mouse.x,
                y: mouse.y,
                radius: 80,
                t: 0,
                life: DIDDY_OIL_SLICK_DURATION,
                opacity: 0.7
            });

            // Create oil burst particles
            for(let i = 0; i < 25; i++){
                const angle = (Math.PI * 2 * i) / 25;
                vfx.diddyOilParticles.push({
                    x: mouse.x,
                    y: mouse.y,
                    vx: Math.cos(angle) * (2 + Math.random() * 3),
                    vy: Math.sin(angle) * (2 + Math.random() * 3),
                    life: 1200 + Math.random() * 600,
                    t: 0,
                    r: 2 + Math.random() * 3,
                    opacity: 0.8
                });
            }

            player.diddyOilSlickActive = true;
            player.diddyOilSlickEndTime = now + DIDDY_OIL_SLICK_DURATION;

            diddyOilSlickReadyAt = now + ABILITY_COOLDOWN;
        }

        // CRISTIANO ABILITY FUNCTIONS
        function tryCristianoPowerShot() {
            const now = performance.now();
            if (currentStyle !== 'cristiano') return;

            if (now < cristianoPowerShotReadyAt) {
                const cooldownLeft = Math.ceil((cristianoPowerShotReadyAt - now) / 1000);
                showNotification(`Power Shot on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('Need ball to use Power Shot!', 'error');
                return;
            }

            // Extremely powerful unblockable shot
            const shotPower = CRISTIANO_POWER_SHOT_POWER + (player.cristianoPortugueseSpiritActive ? CRISTIANO_PORTUGUESE_SPIRIT_SHOT_POWER_BONUS : 0);
            const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);

            ball.vx = Math.cos(angle) * shotPower;
            ball.vy = Math.sin(angle) * shotPower;
            ball.maxSpeed = 100000; // Remove speed cap for power shot
            ball.isUnblockable = true; // Special property for unblockable shots
            ball.isCristianoPowerShot = true; // Enhanced shot marker

            player.hasBall = false;

            // Enhanced power shot trail VFX - multiple trails
            for (let i = 0; i < 3; i++) {
                vfx.cristianoPowerShotTrail.push({
                    startX: player.x + (Math.random() - 0.5) * 10,
                    startY: player.y + (Math.random() - 0.5) * 10,
                    endX: player.x + Math.cos(angle) * (250 + i * 50),
                    endY: player.y + Math.sin(angle) * (250 + i * 50),
                    life: 1200 + i * 200,
                    t: 0,
                    intensity: 1 - i * 0.2
                });
            }

            // Create charging explosion effect at player position
            for (let i = 0; i < 20; i++) {
                const explosionAngle = (Math.PI * 2 * i) / 20;
                vfx.cristianoMovementTrail.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(explosionAngle) * 12,
                    vy: Math.sin(explosionAngle) * 12,
                    life: 600,
                    t: 0,
                    size: Math.random() * 6 + 4,
                    isPowerShotExplosion: true
                });
            }

            // Screen shake effect for power
            if (typeof screenShake !== 'undefined') {
                screenShake(15, 300);
            }

        shockwave(player.x, player.y, 40, 'cristiano');

            // Reset ball speed after power shot
            setTimeout(() => {
                ball.maxSpeed = 18;
            }, 800);

            showNotification('CRISTIANO POWER SHOT! DEVASTATING FORCE!', 'success');
            cristianoPowerShotReadyAt = now + ABILITY_COOLDOWN;
        }


        function tryCristianoGoatTackle() {
            const now = performance.now();
            if (currentStyle !== 'cristiano') return;

            if (now < cristianoGoatTackleReadyAt) {
                const cooldownLeft = Math.ceil((cristianoGoatTackleReadyAt - now) / 1000);
                showNotification(`GOAT's Tackle on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            const distanceToBall = Math.hypot(ball.x - player.x, ball.y - player.y);
            const distanceToAI = aiEnabled ? Math.hypot(aiPlayer.x - player.x, aiPlayer.y - player.y) : Infinity;

            // Check if we can tackle the ball or steal from AI
            const canTackleBall = distanceToBall <= CRISTIANO_GOAT_TACKLE_RANGE && !player.hasBall && !aiPlayer.hasBall;
            const canStealFromAI = aiEnabled && aiPlayer.hasBall && distanceToAI <= CRISTIANO_GOAT_TACKLE_RANGE;

            if (!canTackleBall && !canStealFromAI) {
                if (player.hasBall) {
                    showNotification("Already have the ball!", 'error');
                } else if (aiPlayer.hasBall) {
                    showNotification(`Too far from AI! Must be within ${Math.floor(CRISTIANO_GOAT_TACKLE_RANGE)}px`, 'error');
                } else {
                    showNotification(`Too far from ball! Must be within ${Math.floor(CRISTIANO_GOAT_TACKLE_RANGE)}px`, 'error');
                }
                return;
            }

            const oldX = player.x;
            const oldY = player.y;

            if (canStealFromAI) {
                // Steal from AI - teleport to AI and take ball
                const angle = Math.atan2(aiPlayer.y - player.y, aiPlayer.x - player.x);
                player.x = aiPlayer.x - Math.cos(angle) * (player.r + aiPlayer.r + 10);
                player.y = aiPlayer.y - Math.sin(angle) * (player.r + aiPlayer.r + 10);

                // Stun AI player
                aiPlayer.hasBall = false;
                aiPlayer.isStunned = true;
                aiPlayer.stunEndTime = now + 2000; // 2 second stun

                // Take possession
                player.hasBall = true;
                ball.x = player.x + player.r + ball.r + 2;
                ball.y = player.y;
                ball.vx = 0;
                ball.vy = 0;

                showNotification("GOAT's Tackle! Ball stolen from AI!", 'success');
            } else if (canTackleBall) {
                // Regular ball tackle - teleport to ball
                const angle = Math.atan2(ball.y - player.y, ball.x - player.x);
                player.x = ball.x - Math.cos(angle) * (player.r + ball.r + 8);
                player.y = ball.y - Math.sin(angle) * (player.r + ball.r + 8);

                // Take possession
                player.hasBall = true;
                ball.vx = 0;
                ball.vy = 0;

                showNotification("GOAT's Tackle! Ball secured!", 'success');
            }

            // Enhanced tackle burst effect
            for (let i = 0; i < 25; i++) {
                vfx.cristianoGoatTackleParticles.push({
                    x: oldX,
                    y: oldY,
                    vx: (Math.random() - 0.5) * 18,
                    vy: (Math.random() - 0.5) * 18,
                    life: 1200,
                    t: 0,
                    size: Math.random() * 8 + 4
                });
            }

            // Create golden explosion effect at tackle location
            for (let i = 0; i < 15; i++) {
                const angle = (Math.PI * 2 * i) / 15;
                vfx.cristianoGoatTackleParticles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * 10,
                    vy: Math.sin(angle) * 10,
                    life: 800,
                    t: 0,
                    size: Math.random() * 6 + 6,
                    isExplosion: true
                });
            }

            cristianoGoatTackleReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryCristianoPortugueseSpirit() {
            const now = performance.now();
            if (currentStyle !== 'cristiano') return;

            if (now < cristianoPortugueseSpiritReadyAt) {
                const cooldownLeft = Math.ceil((cristianoPortugueseSpiritReadyAt - now) / 1000);
                showNotification(`Portuguese Spirit on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            // Activate Portuguese Spirit boost with enhanced effects
            player.cristianoPortugueseSpiritActive = true;
            player.cristianoPortugueseSpiritEndTime = now + CRISTIANO_PORTUGUESE_SPIRIT_DURATION;
            player.maxSpd *= CRISTIANO_PORTUGUESE_SPIRIT_SPEED_MULTIPLIER;

            // Add multiple layered Portuguese Spirit aura VFX
            vfx.cristianoPortugueseSpiritAura.push({
                x: player.x,
                y: player.y,
                radius: player.r * 4,
                life: CRISTIANO_PORTUGUESE_SPIRIT_DURATION,
                t: 0,
                layer: 'outer'
            });

            vfx.cristianoPortugueseSpiritAura.push({
                x: player.x,
                y: player.y,
                radius: player.r * 2.5,
                life: CRISTIANO_PORTUGUESE_SPIRIT_DURATION,
                t: 0,
                layer: 'inner'
            });

            // Create energy burst effect
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                vfx.cristianoMovementTrail.push({
                    x: player.x + Math.cos(angle) * player.r,
                    y: player.y + Math.sin(angle) * player.r,
                    vx: Math.cos(angle) * 8,
                    vy: Math.sin(angle) * 8,
                    life: 1000,
                    t: 0,
                    size: Math.random() * 4 + 3,
                    isEnergyBurst: true
                });
            }

            showNotification('Portuguese Spirit ACTIVATED! Unstoppable power unleashed!', 'success');
            cristianoPortugueseSpiritReadyAt = now + 15000; // 15 second cooldown
        }

        // Baby Oil Guy subtitle system with typewriter effect
        function showBabyOilGuySubtitle(text, callback) {
            const subtitleEl = document.getElementById('baby-oil-guy-subtitles');
            const textEl = document.getElementById('subtitle-text');

            subtitleEl.style.display = 'block';
            textEl.textContent = '';

            let charIndex = 0;
            const typeInterval = setInterval(() => {
                if (charIndex < text.length) {
                    textEl.textContent += text[charIndex];
                    charIndex++;
                } else {
                    clearInterval(typeInterval);
                    setTimeout(() => {
                        subtitleEl.style.display = 'none';
                        if (callback) callback();
                    }, 1000);
                }
            }, 50); // 50ms per character for typewriter effect
        }

        // SAJA-JIN ABILITIES
        function trySajaJinDemonicHeroism() {
            const now = performance.now();
            if (currentStyle !== 'saja-jin') return;

            if (now < sajaJinDemonicHeroismReadyAt) {
                const cooldownLeft = Math.ceil((sajaJinDemonicHeroismReadyAt - now) / 1000);
                showNotification(`Demonic Heroism on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            // Activate Demonic Heroism (40% speed boost)
            player.sajaJinDemonicHeroismActive = true;
            player.sajaJinDemonicHeroismEndTime = now + SAJA_JIN_DEMONIC_HEROISM_DURATION;
            player.sajaJinDemonicHeroismOriginalMaxSpd = player.maxSpd;
            player.maxSpd *= SAJA_JIN_DEMONIC_HEROISM_SPEED_BOOST;

            // Create demonic aura effect that follows player
            vfx.sajaJinDemonicAura.push({
                followPlayer: true,
                radius: player.r * 3,
                life: SAJA_JIN_DEMONIC_HEROISM_DURATION,
                t: 0
            });

            // Create energy burst effect
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                vfx.sajaJinSoulParticles.push({
                    x: player.x + Math.cos(angle) * player.r,
                    y: player.y + Math.sin(angle) * player.r,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    life: 1200,
                    t: 0,
                    size: Math.random() * 4 + 2
                });
            }

            showNotification('Demonic Heroism activated! 40% speed boost!', 'success');
            sajaJinDemonicHeroismReadyAt = now + ABILITY_COOLDOWN;
        }

        function trySajaJinSoulSuckingShot() {
            const now = performance.now();
            if (currentStyle !== 'saja-jin') return;

            if (now < sajaJinSoulSuckingShotReadyAt) {
                const cooldownLeft = Math.ceil((sajaJinSoulSuckingShotReadyAt - now) / 1000);
                showNotification(`Soul-Sucking Shot on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('Need ball for Soul-Sucking Shot!', 'warning');
                return;
            }

            // Fire soul-sucking shot
            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.vx = Math.cos(dir) * SAJA_JIN_SOUL_SUCKING_SHOT_POWER;
            ball.vy = Math.sin(dir) * SAJA_JIN_SOUL_SUCKING_SHOT_POWER;
            player.hasBall = false;

            // Create blue soul trail
            vfx.sajaJinSoulTrail.push({
                end: now + SAJA_JIN_SOUL_SUCKING_TRAIL_DURATION,
                w: 25,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--saja-jin-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--saja-jin-trail-end')
            });

            // Activate ghost trail effect
            ball.hasGhostTrail = true;
            ball.ghostTrailEndTime = now + SAJA_JIN_SOUL_SUCKING_TRAIL_DURATION + 300;

            // Create soul particles along the shot path
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    vfx.sajaJinSoulParticles.push({
                        x: ball.x + (Math.random() - 0.5) * 30,
                        y: ball.y + (Math.random() - 0.5) * 30,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 600,
                        t: 0,
                        size: Math.random() * 6 + 3
                    });
                }, i * 50);
            }

            showNotification('Soul-Sucking Shot fired!', 'success');
            sajaJinSoulSuckingShotReadyAt = now + ABILITY_COOLDOWN;
        }

        function trySajaJinHypnoticShot() {
            const now = performance.now();
            if (currentStyle !== 'saja-jin') return;

            if (playerLevel < 10) {
                showNotification('Need to be Level 10 to use Hypnotic Shot!', 'warning');
                return;
            }

            if (now < sajaJinHypnoticShotReadyAt) {
                const cooldownLeft = Math.ceil((sajaJinHypnoticShotReadyAt - now) / 1000);
                showNotification(`Hypnotic Shot on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('Need ball for Hypnotic Shot!', 'warning');
                return;
            }


            // Initialize new hypnotic shot system
            player.sajaJinHypnoticShotActive = true;
            player.sajaJinHypnoticShotPhase = 'spinning';
            player.sajaJinHypnoticShotStartTime = now;
            player.sajaJinHypnoticShotSpinAngle = 0;
            
            // Validate player position before storing center coordinates
            if (isFinite(player.x) && isFinite(player.y)) {
                player.sajaJinHypnoticShotPlayerCenterX = player.x;
                player.sajaJinHypnoticShotPlayerCenterY = player.y;
            } else {
                // Fallback to safe default if player position is invalid
                player.sajaJinHypnoticShotPlayerCenterX = W / 4;  // Safe field position
                player.sajaJinHypnoticShotPlayerCenterY = H / 2;
            }

            // Start spinning around player
            ball.vx = 0;
            ball.vy = 0;
            player.hasBall = false;

            // Create intense multi-layered spinning VFX initiation
            for (let i = 0; i < 40; i++) {
                const angle = (Math.PI * 2 * i) / 40;
                const radius = SAJA_JIN_HYPNOTIC_SHOT_SPIN_RADIUS + (i % 3) * 15;
                
                vfx.sajaJinHypnoticGlow.push({
                    x: player.x + Math.cos(angle) * radius,
                    y: player.y + Math.sin(angle) * radius,
                    radius: ball.r * (2 + Math.random()),
                    life: SAJA_JIN_HYPNOTIC_SHOT_SPIN_DURATION * (0.8 + Math.random() * 0.4),
                    t: 0,
                    angle: angle,
                    type: 'init_glow'
                });
            }
            
            // Add central pulsing aura around player
            vfx.sajaJinHypnoticGlow.push({
                x: player.x,
                y: player.y,
                radius: SAJA_JIN_HYPNOTIC_SHOT_SPIN_RADIUS * 0.8,
                life: SAJA_JIN_HYPNOTIC_SHOT_SPIN_DURATION,
                t: 0,
                type: 'player_aura'
            });
            
            // Add hypnotic energy trails that spiral outward
            for (let spiral = 0; spiral < SAJA_JIN_HYPNOTIC_SHOT_SPIRAL_LAYERS; spiral++) {
                for (let i = 0; i < 20; i++) {
                    const spiralAngle = (Math.PI * 2 * i / 20) + (spiral * Math.PI * 0.4);
                    const spiralRadius = SAJA_JIN_HYPNOTIC_SHOT_SPIN_RADIUS * (0.5 + spiral * 0.25);
                    
                    vfx.sajaJinHypnoticSpinTrail.push({
                        x: player.x + Math.cos(spiralAngle) * spiralRadius,
                        y: player.y + Math.sin(spiralAngle) * spiralRadius,
                        life: 1000 + spiral * 200,
                        t: 0,
                        angle: spiralAngle,
                        layer: spiral,
                        intensity: 1 - (spiral * 0.2)
                    });
                }
            }

            showNotification('HYPNOTIC SHOT: Ball entranced by Saja Jin\'s mesmerizing power!', 'success');
            sajaJinHypnoticShotReadyAt = now + ABILITY_COOLDOWN;
        }

        // LINCOLN SHREK MOVE FUNCTION - ENHANCED & SMOOTH
        function tryLincolnShrekMove() {
            const now = performance.now();
            if (currentStyle !== 'lincoln') return;

            // Check if player has ball - Lincoln's move requires the ball
            if (!player.hasBall) {
                showNotification('Lincoln needs the ball for his Shrek move!', 'warning');
                return;
            }

            // Check cooldown
            if (now < lincolnShrekMoveReadyAt) {
                const cooldownLeft = Math.ceil((lincolnShrekMoveReadyAt - now) / 1000);
                showNotification(`Shrek Move on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (player.lincolnShrekMoveActive) return;

            // Start the Shrek sequence
            player.lincolnShrekMoveActive = true;
            player.lincolnShrekMovePhase = 'shrek1_appear';
            player.lincolnShrekMoveStartTime = now;

            // Create and show fullscreen Shrek image with smooth entrance
            const shrekImg = document.createElement('img');
            shrekImg.src = 'shrek.png';
            shrekImg.style.position = 'fixed';
            shrekImg.style.top = '0';
            shrekImg.style.left = '0';
            shrekImg.style.width = '100vw';
            shrekImg.style.height = '100vh';
            shrekImg.style.objectFit = 'cover';
            shrekImg.style.zIndex = '10000';
            shrekImg.style.pointerEvents = 'none';
            shrekImg.style.opacity = '0';
            shrekImg.style.transition = 'opacity 0.5s ease-in-out';
            document.body.appendChild(shrekImg);
           
            // Smooth fade in
            setTimeout(() => shrekImg.style.opacity = '1', 50);

            // Show Shrek's message with enhanced timing
            setTimeout(() => {
                Trycaption('its time to swamp you lincoln...','fade');
            }, 600);
           
            // Enhanced VFX during Shrek appearance with waves
            const createSwampWave = (delay = 0) => {
                setTimeout(() => {
                    for (let i = 0; i < 40; i++) {
                        const angle = (Math.PI * 2 * i) / 40;
                        const radius = 100 + Math.random() * 150;
                        vfx.lincolnShrekTrail.push({
                            x: W/2 + Math.cos(angle) * radius,
                            y: H/2 + Math.sin(angle) * radius,
                            vx: Math.cos(angle) * (6 + Math.random() * 6),
                            vy: Math.sin(angle) * (6 + Math.random() * 6),
                            life: 3000,
                            t: 0,
                            size: Math.random() * 12 + 6,
                            color: `hsl(${Math.random() * 30 + 80}, 85%, ${55 + Math.random() * 25}%)`
                        });
                    }
                }, delay);
            };
           
            // Create multiple waves of swamp particles
            createSwampWave(0);
            createSwampWave(300);
            createSwampWave(600);
           
            // Add smooth screen glow effect
            canvas.style.transition = 'filter 0.8s ease-in-out';
            canvas.style.filter = 'brightness(1.3) contrast(1.2) hue-rotate(20deg)';

            // After 2.5 seconds, smooth transition to Shrek2
            setTimeout(() => {
                // Smooth fade out first Shrek
                shrekImg.style.opacity = '0';
                setTimeout(() => {
                    if (document.body.contains(shrekImg)) {
                        document.body.removeChild(shrekImg);
                    }
                }, 500);
               
                player.lincolnShrekMovePhase = 'shrek2_kick';

                // Create smaller Shrek2 image with smooth entrance
                const shrek2Img = document.createElement('img');
                shrek2Img.src = 'shrek2.png';
                shrek2Img.style.position = 'fixed';
                shrek2Img.style.top = '50%';
                shrek2Img.style.left = '50%';
                shrek2Img.style.transform = 'translate(-50%, -50%) scale(0.8)';
                shrek2Img.style.width = '300px';
                shrek2Img.style.height = '300px';
                shrek2Img.style.objectFit = 'contain';
                shrek2Img.style.zIndex = '10000';
                shrek2Img.style.pointerEvents = 'none';
                shrek2Img.style.opacity = '0';
                shrek2Img.style.transition = 'all 0.4s ease-out';
                document.body.appendChild(shrek2Img);
               
                // Smooth entrance for Shrek2
                setTimeout(() => {
                    shrek2Img.style.opacity = '1';
                    shrek2Img.style.transform = 'translate(-50%, -50%) scale(1)';
                }, 50);

                // Enhanced ball kick sequence
                setTimeout(() => {
                    const goalX = W - margin; // Right goal
                    const goalY = H / 2;
                    const dir = Math.atan2(goalY - ball.y, goalX - ball.x);
                   
                    ball.vx = Math.cos(dir) * LINCOLN_SHREK2_KICK_POWER;
                    ball.vy = Math.sin(dir) * LINCOLN_SHREK2_KICK_POWER;
                    player.hasBall = false;

                    // Create enhanced green Shrek trail
                    vfx.trail.push({
                        end: now + 4000,
                        w: 60,
                        colorStart: getComputedStyle(document.documentElement).getPropertyValue('--lincoln-trail-start'),
                        colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--lincoln-trail-end')
                    });
                   
                    // Multi-layered kick explosion
                    for (let layer = 0; layer < 3; layer++) {
                        setTimeout(() => {
                            for (let i = 0; i < 25; i++) {
                                vfx.lincolnShrekParticles.push({
                                    x: ball.x + (Math.random() - 0.5) * (60 + layer * 20),
                                    y: ball.y + (Math.random() - 0.5) * (60 + layer * 20),
                                    vx: (Math.random() - 0.5) * (12 + layer * 3),
                                    vy: (Math.random() - 0.5) * (12 + layer * 3),
                                    life: 2500 + layer * 500,
                                    t: 0,
                                    size: Math.random() * (15 + layer * 3) + 8,
                                    color: `hsl(${Math.random() * 40 + 90}, 100%, ${65 + Math.random() * 20}%)`,
                                    glow: true
                                });
                            }
                        }, layer * 100);
                    }
                   
                    // Enhanced epic trail ring effect with smoother animations
                    for (let ring = 0; ring < 3; ring++) {
                        for (let i = 0; i < 30; i++) {
                            const angle = (Math.PI * 2 * i) / 30;
                            const radius = (ring + 1) * 50;
                            vfx.lincolnShrekTrail.push({
                                x: ball.x + Math.cos(angle) * radius,
                                y: ball.y + Math.sin(angle) * radius,
                                vx: Math.cos(angle) * (8 + ring * 2),
                                vy: Math.sin(angle) * (8 + ring * 2),
                                life: 2500 - ring * 300,
                                t: 0,
                                size: Math.random() * 10 + 8,
                                color: ring === 0 ? '#4ADF4A' : ring === 1 ? '#32CD32' : '#228B22'
                            });
                        }
                    }
                   
                    // Enhanced screen effects with smoother transitions
                    canvas.style.animation = 'shake 0.6s ease-in-out';
                    canvas.style.filter = 'brightness(1.6) saturate(1.4) contrast(1.1)';
                   
                    showNotification('🥅 LEGENDARY SHREK KICK! 🥅', 'success');
                }, 400);

                // Smooth Shrek2 exit
                setTimeout(() => {
                    shrek2Img.style.opacity = '0';
                    shrek2Img.style.transform = 'translate(-50%, -50%) scale(1.2)';
                    setTimeout(() => {
                        if (document.body.contains(shrek2Img)) {
                            document.body.removeChild(shrek2Img);
                        }
                        player.lincolnShrekMoveActive = false;
                        player.lincolnShrekMovePhase = '';
                       
                        // Smooth screen filter reset
                        canvas.style.animation = '';
                        canvas.style.filter = '';
                    }, 500);
                }, 1200);

            }, LINCOLN_SHREK1_DURATION + 500);

            lincolnShrekMoveReadyAt = now + ABILITY_COOLDOWN;
        }

        // LINCOLN KISS MOVE FUNCTION - CLEANED UP
        function tryLincolnKissMove() {
            const now = performance.now();
            if (currentStyle !== 'lincoln') return;

            // Check cooldown
            if (now < lincolnKissMoveReadyAt) {
                const cooldownLeft = Math.ceil((lincolnKissMoveReadyAt - now) / 1000);
                showNotification(`Kiss Move on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (player.lincolnKissMoveActive) return;

            // Store initial position and completely freeze player in place
            const originalX = player.x;
            const originalY = player.y;
            player._frozenForKissMove = true;
            player._originalX = originalX;
            player._originalY = originalY;

            // Stop the ball's movement immediately
            ball.vx = 0;
            ball.vy = 0;

            // Start the Kiss sequence
            player.lincolnKissMoveActive = true;
            player.lincolnKissMovePhase = 'gyat_appear';
            player.lincolnKissMoveStartTime = now;

            // Create gyat.png image in the middle of the field
            const centerX = W/2;
            const centerY = H/2;
            const gyatImg = document.createElement('img');
            gyatImg.src = 'gyat.png';
            gyatImg.style.position = 'fixed';
            gyatImg.style.left = (centerX * (window.innerWidth / W)) + 'px';
            gyatImg.style.top = (centerY * (window.innerHeight / H)) + 'px';
            gyatImg.style.transform = 'translate(-50%, -50%)';
            gyatImg.style.width = '80px';
            gyatImg.style.height = '80px';
            gyatImg.style.objectFit = 'contain';
            gyatImg.style.zIndex = '10000';
            gyatImg.style.pointerEvents = 'none';
            gyatImg.style.animation = 'pulse 0.5s infinite alternate';
            document.body.appendChild(gyatImg);

            // Show caption and create VFX
            Trycaption('oH MY GOODNESS GRACIOUS ITS A GYATT 😳', 'Bounce');
           
            // Create heart particles around player's original position
            for (let i = 0; i < 10; i++) {
                vfx.lincolnKissHeartParticles.push({
                    x: originalX + (Math.random() - 0.5) * 40,
                    y: originalY + (Math.random() - 0.5) * 40,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3 - 1,
                    life: 2000,
                    t: 0,
                    size: Math.random() * 6 + 3,
                    color: 'pink'
                });
            }
           
            // After gyat appears, show Lincoln's chill response
            setTimeout(() => {
                if (!gyatImg || !gyatImg.parentElement) return;
               
                Trycaption('nah im just a chill guy', 'fade');
               
                // Force player to stay at original position during the move
                player.x = originalX;
                player.y = originalY;
                player.vx = 0;
                player.vy = 0;
               
                // Create and show chillguy image centered on the frozen player
                const chillGuyImg = document.createElement('img');
                chillGuyImg.src = 'chillguy.png';
                chillGuyImg.style.position = 'fixed';
               
                // Calculate the player's screen position relative to canvas
                const canvasRect = canvas.getBoundingClientRect();
                const playerScreenX = canvasRect.left + (player.x / W) * canvasRect.width;
                const playerScreenY = canvasRect.top + (player.y / H) * canvasRect.height;
               
                chillGuyImg.style.left = playerScreenX + 'px';
                chillGuyImg.style.top = playerScreenY + 'px';
                chillGuyImg.style.transform = 'translate(-50%, -50%)';
                chillGuyImg.style.width = '120px';
                chillGuyImg.style.height = '120px';
                chillGuyImg.style.objectFit = 'contain';
                chillGuyImg.style.zIndex = '10001';
                chillGuyImg.style.pointerEvents = 'none';
                document.body.appendChild(chillGuyImg);

                // Keep player frozen and update chill guy position to stay centered
                const maintainFreeze = setInterval(() => {
                    if (chillGuyImg.parentElement && player._frozenForKissMove) {
                        // Force player to stay at original position
                        player.x = originalX;
                        player.y = originalY;
                        player.vx = 0;
                        player.vy = 0;
                       
                        // Update chill guy position to stay centered on frozen player
                        const canvasRect = canvas.getBoundingClientRect();
                        const playerScreenX = canvasRect.left + (player.x / W) * canvasRect.width;
                        const playerScreenY = canvasRect.top + (player.y / H) * canvasRect.height;
                       
                        chillGuyImg.style.left = playerScreenX + 'px';
                        chillGuyImg.style.top = playerScreenY + 'px';
                    } else {
                        clearInterval(maintainFreeze);
                    }
                }, 16);

                // After exactly 2 seconds, remove everything and instantly teleport
                setTimeout(() => {
                    // Clean up images
                    if (document.body.contains(gyatImg)) {
                        document.body.removeChild(gyatImg);
                    }
                    if (document.body.contains(chillGuyImg)) {
                        document.body.removeChild(chillGuyImg);
                    }
                    clearInterval(maintainFreeze);
                   
                    // Instantly teleport to ball and end move
                    Trycaption('ok time to get the ball :D','Fade')

                    player._frozenForKissMove = false;
                    player.x = ball.x;
                    player.y = ball.y;
                    player.hasBall = true;
                    player.lincolnKissMoveActive = false;
                    player.lincolnKissMovePhase = '';
                   
                    // Add teleport effect
                    for (let i = 0; i < 15; i++) {
                        vfx.lincolnKissHeartParticles.push({
                            x: ball.x + (Math.random() - 0.5) * 50,
                            y: ball.y + (Math.random() - 0.5) * 50,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            life: 800,
                            t: 0,
                            size: Math.random() * 5 + 3,
                            color: 'white'
                        });
                    }
                }, 2000);
            }, 1000);

            lincolnKissMoveReadyAt = now + ABILITY_COOLDOWN;
        }

        // LINCOLN GYATT SHOWDOWN - Third move (X key)
        function tryLincolnGyattShowdown() {
            const now = performance.now();
            if (currentStyle !== 'lincoln') return;

            // Check cooldown
            if (now < lincolnGyattShowdownReadyAt) {
                const cooldownLeft = Math.ceil((lincolnGyattShowdownReadyAt - now) / 1000);
                showNotification(`Gyatt Showdown on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (player.lincolnGyattShowdownActive) return;

            // Activate Gyatt Showdown
            player.lincolnGyattShowdownActive = true;
            player.lincolnGyattShowdownEndTime = now + LINCOLN_GYATT_SHOWDOWN_DURATION;
            player.lincolnGyattShowdownOriginalMaxSpd = player.maxSpd;

            // Increase player speed
            player.maxSpd *= LINCOLN_GYATT_SHOWDOWN_SPEED_MULTIPLIER;

            // Create gyatt image attached to player
            const gyattImg = document.createElement('img');
            gyattImg.src = 'gyat.png';
            gyattImg.id = 'lincolnGyattImage';
            gyattImg.style.position = 'absolute';
            gyattImg.style.width = '40px';
            gyattImg.style.height = '40px';
            gyattImg.style.objectFit = 'contain';
            gyattImg.style.zIndex = '10000';
            gyattImg.style.pointerEvents = 'none';
            gyattImg.style.opacity = '0.9';
            gyattImg.style.transition = 'opacity 0.3s ease-in-out';
            document.body.appendChild(gyattImg);

            // Create initial burst VFX
            for (let i = 0; i < 50; i++) {
                const angle = (Math.PI * 2 * i) / 50;
                vfx.lincolnGyattParticles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * (5 + Math.random() * 10),
                    vy: Math.sin(angle) * (5 + Math.random() * 10),
                    life: 2000 + Math.random() * 1000,
                    t: 0,
                    size: 4 + Math.random() * 6,
                    hue: 300 + Math.random() * 60 // Purple to pink hues
                });
            }

            // Show notification and caption
            showNotification('GYATT SHOWDOWN ACTIVATED! 5x shot power, 2x speed!', 'success');
            Trycaption('GYATT MODE ENGAGED! 💪✨', 'Bounce');

            lincolnGyattShowdownReadyAt = now + ABILITY_COOLDOWN;
        }

        // ABBY COLOSSAL CALVES - Power shot move (C key)
        function tryAbbyColossalCalves() {
            const now = performance.now();
            if (currentStyle !== 'abby') return;

            if (!player.hasBall) {
                showNotification('Abby needs the ball for Colossal Calves!', 'warning');
                return;
            }

            if (now < abbyColossalCalvesReadyAt) {
                const cooldownLeft = Math.ceil((abbyColossalCalvesReadyAt - now) / 1000);
                showNotification(`Colossal Calves on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            // Powerful shot with special effects
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const angle = Math.atan2(dy, dx);
           
            // Release ball with EXTREME power - COLOSSAL FORCE!
            player.hasBall = false;
            ball.vx = Math.cos(angle) * 35; // EXTREMELY powerful shot!
            ball.vy = Math.sin(angle) * 35;
           
            // ULTIMATE COLOSSAL CALVES VFX - ABSOLUTELY INSANE!
            
            // MASSIVE PARTICLE EXPLOSION!
            for(let i = 0; i < 80; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 150,
                    y: ball.y + (Math.random() - 0.5) * 150,
                    vx: (Math.random() - 0.5) * 25,
                    vy: (Math.random() - 0.5) * 25,
                    life: 80,
                    t: 0,
                    color: 'rgba(255, 20, 147, 0.98)', // ULTRA INTENSE deep pink!
                    w: 15
                });
            }
           
            // COLOSSAL ENERGY RINGS!
            for(let ring = 0; ring < 5; ring++) {
                for(let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const radius = 40 + (ring * 25);
                    vfx.trails.push({
                        x: player.x + Math.cos(angle) * radius,
                        y: player.y + Math.sin(angle) * radius,
                        vx: Math.cos(angle) * (15 + ring * 5),
                        vy: Math.sin(angle) * (15 + ring * 5),
                        life: 70 - ring * 10,
                        t: 0,
                        color: `rgba(255, ${105 + ring * 30}, 180, 0.9)`,
                        w: 14 - ring * 2
                    });
                }
            }
           
            // EPIC CALVES LIGHTNING STORM!
            for(let i = 0; i < 35; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 120,
                    y: ball.y + (Math.random() - 0.5) * 120,
                    vx: (Math.random() - 0.5) * 35,
                    vy: (Math.random() - 0.5) * 35,
                    life: 60,
                    t: 0,
                    color: 'rgba(255, 192, 203, 0.95)', // Bright pink lightning!
                    w: 12
                });
            }
           
            // SHOCKWAVE EXPLOSION!
            for(let i = 0; i < 30; i++) {
                vfx.trails.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(i * 0.21) * 30,
                    vy: Math.sin(i * 0.21) * 30,
                    life: 55,
                    t: 0,
                    color: 'rgba(255, 0, 127, 0.85)', // Hot magenta shockwave!
                    w: 16
                });
            }
           
            // SPARKLE EFFECTS!
            for(let i = 0; i < 50; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 80,
                    y: ball.y + (Math.random() - 0.5) * 80,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20,
                    life: 50,
                    t: 0,
                    color: 'rgba(255, 255, 255, 0.9)', // Bright white sparkles!
                    w: 4
                });
            }

            showNotification('Colossal Calves activated! Powerful shot!', 'success');
            abbyColossalCalvesReadyAt = now + ABILITY_COOLDOWN;
        }

        // ABBY POWER PIN - Ball pins to wall on collision (V key)
        function tryAbbyPowerPin() {
            const now = performance.now();
            if (currentStyle !== 'abby') return;

            if (!player.hasBall) {
                showNotification('Abby needs the ball for Power Pin!', 'warning');
                return;
            }

            if (now < abbyPowerPinReadyAt) {
                const cooldownLeft = Math.ceil((abbyPowerPinReadyAt - now) / 1000);
                showNotification(`Power Pin on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const angle = Math.atan2(dy, dx);
           
            // Release ball with ULTIMATE pin power!
            player.hasBall = false;
            ball.vx = Math.cos(angle) * 28; // Much more powerful!
            ball.vy = Math.sin(angle) * 28;
           
            // Mark ball as having pin effect
            ball.abbyPowerPinActive = true;
            ball.abbyPowerPinEndTime = now + 8000; // Pin effect lasts 8 seconds
           
            // ULTIMATE POWER PIN VFX - ABSOLUTE PINNING DEVASTATION!
            
            // MASSIVE PIN EXPLOSION!
            for(let i = 0; i < 60; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 120,
                    y: ball.y + (Math.random() - 0.5) * 120,
                    vx: (Math.random() - 0.5) * 25,
                    vy: (Math.random() - 0.5) * 25,
                    life: 75,
                    t: 0,
                    color: 'rgba(255, 69, 0, 0.98)', // ULTRA INTENSE orange-red!
                    w: 14
                });
            }
           
            // ELECTRIC PIN STORM!
            for(let i = 0; i < 45; i++) {
                const angle = (i / 45) * Math.PI * 2;
                vfx.trails.push({
                    x: ball.x,
                    y: ball.y,
                    vx: Math.cos(angle) * 28,
                    vy: Math.sin(angle) * 28,
                    life: 65,
                    t: 0,
                    color: 'rgba(255, 140, 0, 0.95)', // INTENSE orange electric!
                    w: 12
                });
            }
           
            // GOLDEN PIN LIGHTNING!
            for(let i = 0; i < 35; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 90,
                    y: ball.y + (Math.random() - 0.5) * 90,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20,
                    life: 55,
                    t: 0,
                    color: 'rgba(255, 215, 0, 0.95)', // BRIGHT golden lightning!
                    w: 10
                });
            }
           
            // PIN ENERGY WAVES!
            for(let wave = 0; wave < 4; wave++) {
                for(let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const radius = 30 + (wave * 20);
                    vfx.trails.push({
                        x: ball.x + Math.cos(angle) * radius,
                        y: ball.y + Math.sin(angle) * radius,
                        vx: Math.cos(angle) * (20 + wave * 8),
                        vy: Math.sin(angle) * (20 + wave * 8),
                        life: 60 - wave * 10,
                        t: 0,
                        color: `rgba(255, ${165 - wave * 25}, 0, 0.9)`,
                        w: 12 - wave * 2
                    });
                }
            }
           
            // FIRE-LIKE PIN SPARKS!
            for(let i = 0; i < 40; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 60,
                    y: ball.y + (Math.random() - 0.5) * 60,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 45,
                    t: 0,
                    color: 'rgba(255, 100, 0, 0.9)', // Fiery orange sparks!
                    w: 8
                });
            }

            showNotification('Power Pin activated! Ball will stick to walls!', 'success');
            abbyPowerPinReadyAt = now + ABILITY_COOLDOWN;
        }

        // ABBY DEMON DRIVE - Player moves forward then kicks (X key)
        function tryAbbyDemonDrive() {
            const now = performance.now();
            if (currentStyle !== 'abby') return;

            if (!player.hasBall) {
                showNotification('Abby needs the ball for Demon Drive!', 'warning');
                return;
            }

            if (now < abbyDemonDriveReadyAt) {
                const cooldownLeft = Math.ceil((abbyDemonDriveReadyAt - now) / 1000);
                showNotification(`Demon Drive on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            // Start demon drive sequence
            player.abbyDemonDriveActive = true;
            player.abbyDemonDrivePhase = 'forward'; // forward -> stun -> kick
            player.abbyDemonDriveStartTime = now;
           
            // Store initial position and direction
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const angle = Math.atan2(dy, dx);
           
            player.abbyDemonDriveDirection = angle;
            player.abbyDemonDriveStartX = player.x;
            player.abbyDemonDriveStartY = player.y;
           
            // Move ball slightly in front during forward movement
            const ballOffset = 30;
            ball.x = player.x + Math.cos(angle) * ballOffset;
            ball.y = player.y + Math.sin(angle) * ballOffset;
            ball.vx = 0;
            ball.vy = 0;
           
            // ULTIMATE DEMON DRIVE INITIATION - HELLISH POWER!
            
            // MASSIVE DEMON EXPLOSION!
            for(let i = 0; i < 70; i++) {
                vfx.trails.push({
                    x: player.x + (Math.random() - 0.5) * 140,
                    y: player.y + (Math.random() - 0.5) * 140,
                    vx: (Math.random() - 0.5) * 30,
                    vy: (Math.random() - 0.5) * 30,
                    life: 85,
                    t: 0,
                    color: 'rgba(139, 0, 139, 0.98)', // ULTRA INTENSE dark magenta!
                    w: 18
                });
            }
           
            // DEMONIC ENERGY PORTAL RINGS!
            for(let ring = 0; ring < 6; ring++) {
                for(let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    const radius = 35 + (ring * 20);
                    vfx.trails.push({
                        x: player.x + Math.cos(angle) * radius,
                        y: player.y + Math.sin(angle) * radius,
                        vx: Math.cos(angle) * (25 + ring * 6),
                        vy: Math.sin(angle) * (25 + ring * 6),
                        life: 75 - ring * 8,
                        t: 0,
                        color: `rgba(${75 + ring * 20}, 0, ${130 + ring * 15}, 0.9)`,
                        w: 16 - ring * 2
                    });
                }
            }
           
            // HELLFIRE DEMON SPARKS!
            for(let i = 0; i < 50; i++) {
                vfx.trails.push({
                    x: player.x + (Math.random() - 0.5) * 100,
                    y: player.y + (Math.random() - 0.5) * 100,
                    vx: (Math.random() - 0.5) * 25,
                    vy: (Math.random() - 0.5) * 25,
                    life: 70,
                    t: 0,
                    color: 'rgba(148, 0, 211, 0.95)', // BRIGHT violet demon energy!
                    w: 14
                });
            }
           
            // DARK ENERGY TORNADO!
            for(let i = 0; i < 40; i++) {
                const angle = (i / 40) * Math.PI * 6; // Multiple rotations
                const radius = 20 + (i * 2);
                vfx.trails.push({
                    x: player.x + Math.cos(angle) * radius,
                    y: player.y + Math.sin(angle) * radius,
                    vx: Math.cos(angle) * 20,
                    vy: Math.sin(angle) * 20,
                    life: 65,
                    t: 0,
                    color: 'rgba(75, 0, 130, 0.9)', // Deep purple tornado!
                    w: 12
                });
            }
           
            // DEMON ESSENCE WISPS!
            for(let i = 0; i < 30; i++) {
                vfx.trails.push({
                    x: player.x + (Math.random() - 0.5) * 80,
                    y: player.y + (Math.random() - 0.5) * 80,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 80,
                    t: 0,
                    color: 'rgba(25, 0, 25, 0.8)', // Dark demon wisps!
                    w: 6
                });
            }

            showNotification('Demon Drive initiated! Get ready...', 'success');
            abbyDemonDriveReadyAt = now + ABILITY_COOLDOWN;
        }

        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        // ===== KORBIN ABILITIES =====

        function tryKorbinFieryApocalypse() {
            const now = performance.now();
            if (now < korbinFieryApocalypseReadyAt) {
                const cooldownLeft = Math.ceil((korbinFieryApocalypseReadyAt - now) / 1000);
                showNotification(`Fiery Apocalypse on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('need ball for fiery apocalypse fr', 'warning');
                return;
            }

            // Activate Fiery Apocalypse
            korbinFieryApocalypseReadyAt = now + KORBIN_FIERY_APOCALYPSE_COOLDOWN;
            
            // Calculate direction to mouse
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const angle = Math.atan2(dy, dx);
            
            // Create INSANE fire explosion around player before shot (optimized)
            for (let i = 0; i < 30; i++) { // Reduced from 100 to 30
                const explosionAngle = (Math.PI * 2 * i) / 30;
                const explosionRadius = 30 + Math.random() * 80; // Reduced spread
                vfx.korbinFireApocalypseExplosion.push({
                    x: player.x + Math.cos(explosionAngle) * explosionRadius,
                    y: player.y + Math.sin(explosionAngle) * explosionRadius,
                    vx: Math.cos(explosionAngle) * (3 + Math.random() * 6), // Reduced velocity
                    vy: Math.sin(explosionAngle) * (3 + Math.random() * 6),
                    life: 600 + Math.random() * 200, // Much shorter - 0.6-0.8 seconds
                    t: 0,
                    size: 6 + Math.random() * 8, // Smaller particles
                    hue: 0 + Math.random() * 60, // Red to orange flames
                    intensity: 0.8 + Math.random() * 0.2,
                    loop: Math.sin(i * 0.5) * 0.2 // Reduced loop effect
                });
            }

            // Create massive flame particles (optimized)
            for (let i = 0; i < 25; i++) { // Reduced from 80 to 25
                vfx.korbinFireApocalypseFlames.push({
                    x: player.x + (Math.random() - 0.5) * 120, // Reduced spread
                    y: player.y + (Math.random() - 0.5) * 120,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 800 + Math.random() * 300, // Shorter - 0.8-1.1 seconds
                    t: 0,
                    size: 12 + Math.random() * 15, // Slightly smaller
                    hue: 0 + Math.random() * 45, // Intense reds and oranges
                    intensity: 0.8 + Math.random() * 0.2,
                    loop: Math.cos(i * 0.3) * 0.3 // Reduced loop effect
                });
            }

            // Create ember shower (optimized)
            for (let i = 0; i < 40; i++) { // Reduced from 150 to 40
                vfx.korbinFireApocalypseEmbers.push({
                    x: player.x + (Math.random() - 0.5) * 150, // Reduced spread
                    y: player.y + (Math.random() - 0.5) * 150,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1000 + Math.random() * 600, // Shorter - 1-1.6 seconds
                    t: 0,
                    size: 2 + Math.random() * 5, // Smaller particles
                    hue: 15 + Math.random() * 30, // Orange to yellow embers
                    gravity: 0.08,
                    intensity: 0.7 + Math.random() * 0.3,
                    loop: Math.sin(i * 0.1) * 0.15 // Reduced loop effect
                });
            }

            // Create apocalyptic shockwave (optimized)
            for (let wave = 0; wave < 3; wave++) { // Reduced from 5 to 3 waves
                for (let i = 0; i < 20; i++) { // Reduced from 60 to 20 per wave
                    const shockAngle = (Math.PI * 2 * i) / 20;
                    vfx.korbinFireApocalypseShockwave.push({
                        x: player.x + Math.cos(shockAngle) * (wave * 30),
                        y: player.y + Math.sin(shockAngle) * (wave * 30),
                        vx: Math.cos(shockAngle) * (15 + wave * 3),
                        vy: Math.sin(shockAngle) * (15 + wave * 3),
                        life: 400 - wave * 50, // Much shorter - 0.4 to 0.3 seconds
                        t: 0,
                        size: 10 - wave * 2,
                        hue: 0 + wave * 15,
                        intensity: 1.0 - wave * 0.15,
                        delay: wave * 40, // Faster staggered waves
                        loop: Math.sin(shockAngle * 2 + wave) * 0.3 // Reduced loop effect
                    });
                }
            }

            // Fire the super-powered shot
            player.hasBall = false;
            ball.vx = Math.cos(angle) * KORBIN_FIERY_APOCALYPSE_DAMAGE * 20; // INSANE SPEED
            ball.vy = Math.sin(angle) * KORBIN_FIERY_APOCALYPSE_DAMAGE * 20;

            // Create trailing fire effects for the ball (optimized)
            for (let i = 0; i < 15; i++) { // Reduced from 50 to 15
                vfx.korbinFireApocalypseTrail.push({
                    x: ball.x + (Math.random() - 0.5) * 25, // Reduced spread
                    y: ball.y + (Math.random() - 0.5) * 25,
                    vx: ball.vx * 0.2 + (Math.random() - 0.5) * 6,
                    vy: ball.vy * 0.2 + (Math.random() - 0.5) * 6,
                    life: 600, // Shorter - 0.6 seconds
                    t: 0,
                    size: 6 + Math.random() * 8, // Smaller
                    hue: 0 + Math.random() * 60,
                    intensity: 0.8,
                    loop: Math.sin(i * 0.2) * 0.2 // Reduced loop effect
                });
            }

            showNotification('FIERY APOCALYPSE UNLEASHED!', 'success');
        }

        function tryKorbinBigBackPower() {
            const now = performance.now();
            if (now < korbinBigBackPowerReadyAt) {
                const cooldownLeft = Math.ceil((korbinBigBackPowerReadyAt - now) / 1000);
                showNotification(`Big Back Power on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            // Can use with or without ball
            
            // Activate Big Back Power
            korbinBigBackPowerReadyAt = now + KORBIN_BIG_BACK_POWER_COOLDOWN;
            player.korbinBigBackPowerActive = true;
            player.korbinBigBackPowerEndTime = now + KORBIN_BIG_BACK_POWER_DURATION;
            player.korbinBigBackPowerStunned = true; // Player is stunned during the move
            
            // Store original max speed and set new speed
            player.korbinBigBackPowerOriginalMaxSpd = player.maxSpd;
            player.maxSpd = KORBIN_BIG_BACK_POWER_SPEED;
            
            // Calculate initial direction based on current movement or mouse direction
            let dirX = 0, dirY = 0;
            if (Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.1) {
                // Use current movement direction
                const speed = Math.hypot(player.vx, player.vy);
                dirX = player.vx / speed;
                dirY = player.vy / speed;
            } else {
                // Use direction to mouse
                const dx = mouse.x - player.x;
                const dy = mouse.y - player.y;
                const distance = Math.hypot(dx, dy);
                if (distance > 0) {
                    dirX = dx / distance;
                    dirY = dy / distance;
                } else {
                    // Default direction (right)
                    dirX = 1;
                    dirY = 0;
                }
            }
            
            player.korbinBigBackPowerDirection = { x: dirX, y: dirY };
            
            // Set player velocity for fast movement
            player.vx = dirX * KORBIN_BIG_BACK_POWER_SPEED;
            player.vy = dirY * KORBIN_BIG_BACK_POWER_SPEED;
            
            // If player has ball, make it ungrabbable during the move
            if (player.hasBall) {
                ball.korbinBigBackProtected = true;
            }
            
            showNotification('BIG BACK POWER! Press SPACE to stop!', 'success');
        }

        function stopKorbinBigBackPower() {
            if (!player.korbinBigBackPowerActive) return;
            
            // Deactivate the move
            player.korbinBigBackPowerActive = false;
            player.korbinBigBackPowerStunned = false;
            
            // Restore original speed
            player.maxSpd = player.korbinBigBackPowerOriginalMaxSpd;
            
            // Stop player movement
            player.vx = 0;
            player.vy = 0;
            
            // Remove ball protection
            if (ball.korbinBigBackProtected) {
                ball.korbinBigBackProtected = false;
            }
            
            // Create massive wind shockwave effect
            createKorbinWindShockwave();
            
            showNotification('WIND SHOCKWAVE!', 'success');
        }

        function createKorbinWindShockwave() {
            // Create impressive wind shockwave effect (optimized for performance)
            for (let wave = 0; wave < 4; wave++) { // 4 expanding waves
                for (let i = 0; i < 25; i++) { // 25 particles per wave
                    const angle = (Math.PI * 2 * i) / 25;
                    vfx.korbinBigBackPowerShockwave.push({
                        x: player.x + Math.cos(angle) * (wave * 20),
                        y: player.y + Math.sin(angle) * (wave * 20),
                        vx: Math.cos(angle) * (20 + wave * 5),
                        vy: Math.sin(angle) * (20 + wave * 5),
                        life: 800 - wave * 100, // Staggered duration
                        t: 0,
                        size: 15 - wave * 2,
                        intensity: 0.9 - wave * 0.15,
                        delay: wave * 50, // Staggered timing
                        loop: Math.sin(angle * 3 + wave) * 0.4
                    });
                }
            }
            
            // Add wind burst particles
            for (let i = 0; i < 40; i++) {
                vfx.korbinBigBackPowerWindBurst.push({
                    x: player.x + (Math.random() - 0.5) * 60,
                    y: player.y + (Math.random() - 0.5) * 60,
                    vx: (Math.random() - 0.5) * 30,
                    vy: (Math.random() - 0.5) * 30,
                    life: 600 + Math.random() * 400,
                    t: 0,
                    size: 8 + Math.random() * 12,
                    intensity: 0.7 + Math.random() * 0.3,
                    spiral: Math.random() * Math.PI * 2
                });
            }
        }

        function tryKorbinBigShot() {
            const now = performance.now();
            if (now < korbinBigShotReadyAt) {
                const cooldownLeft = Math.ceil((korbinBigShotReadyAt - now) / 1000);
                showNotification(`Big Shot on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('need ball for big shot fr', 'warning');
                return;
            }

            // Activate Big Shot
            korbinBigShotReadyAt = now + KORBIN_BIG_SHOT_COOLDOWN;
            
            // Calculate direction to mouse
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const angle = Math.atan2(dy, dx);
            
            // Create intense wind buildup effect around player
            for (let i = 0; i < 35; i++) {
                const windAngle = (Math.PI * 2 * i) / 35;
                const windRadius = 40 + Math.random() * 60;
                vfx.korbinBigShotWindParticles.push({
                    x: player.x + Math.cos(windAngle) * windRadius,
                    y: player.y + Math.sin(windAngle) * windRadius,
                    vx: Math.cos(windAngle) * (2 + Math.random() * 4),
                    vy: Math.sin(windAngle) * (2 + Math.random() * 4),
                    life: 800 + Math.random() * 400,
                    t: 0,
                    size: 4 + Math.random() * 6,
                    opacity: 0.7 + Math.random() * 0.3,
                    swirl: Math.random() * Math.PI * 2
                });
            }

            // Create swirling wind effects
            for (let i = 0; i < 20; i++) {
                vfx.korbinBigShotWindSwirls.push({
                    x: player.x + (Math.random() - 0.5) * 100,
                    y: player.y + (Math.random() - 0.5) * 100,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 1000 + Math.random() * 600,
                    t: 0,
                    size: 8 + Math.random() * 12,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.3,
                    opacity: 0.6 + Math.random() * 0.4
                });
            }
            
            // Release the ball with MASSIVE power
            player.hasBall = false;
            ball.vx = Math.cos(angle) * KORBIN_BIG_SHOT_DAMAGE * 22; // Extremely fast
            ball.vy = Math.sin(angle) * KORBIN_BIG_SHOT_DAMAGE * 22;
            
            // Create powerful wind trail behind ball
            for (let i = 0; i < 15; i++) {
                vfx.korbinBigShotWindTrail.push({
                    x: ball.x - Math.cos(angle) * i * 8,
                    y: ball.y - Math.sin(angle) * i * 8,
                    vx: Math.cos(angle) * (5 - i * 0.3),
                    vy: Math.sin(angle) * (5 - i * 0.3),
                    life: 600 + Math.random() * 200,
                    t: 0,
                    size: 12 - i * 0.6,
                    opacity: (15 - i) / 15 * 0.8,
                    windForce: 1.0 - i * 0.05
                });
            }
            
            showNotification('BIG SHOT UNLEASHED!', 'success');
        }

        // ===== 67 KID ABILITIES =====

        function try67KidMayhem() {
            const now = performance.now();
            if (currentStyle !== '67kid') return;

            if (now < sixtySevenKidMayhemReadyAt) {
                const cooldownLeft = Math.ceil((sixtySevenKidMayhemReadyAt - now) / 1000);
                showNotification(`67 Mayhem on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('67 kid needs the ball for 67 Mayhem!', 'warning');
                return;
            }

            // Set cooldown
            sixtySevenKidMayhemReadyAt = now + SIXTY_SEVEN_KID_MAYHEM_COOLDOWN;
            
            // FREEZE PLAYER during entire sequence
            player._frozenFor67Mayhem = true;
            player._67MayhemStartTime = now;
            player._67MayhemPhase = 'text_spawning';
            
            // Store original player position
            player._67MayhemOriginalX = player.x;
            player._67MayhemOriginalY = player.y;
            
            // Phase 1: Spawn LOTS of "67" text all over screen
            for (let i = 0; i < 80; i++) { // LOTS of 67s!
                vfx.sixtySevenKidTextClones.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: SIXTY_SEVEN_KID_MAYHEM_67_DISPLAY_DURATION,
                    t: 0,
                    text: '67',
                    size: 0.5 + Math.random() * 0.8, // Size between 0.5 and 1.3
                    color: Math.random() > 0.5 ? '#00bcd4' : '#2196f3', // Cyan or blue
                    opacity: 0.9 + Math.random() * 0.1,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02
                });
            }
            
            // Create cyan/blue aura around player
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const distance = 50 + Math.random() * 30;
                vfx.sixtySevenKidMayhemAura.push({
                    x: player.x + Math.cos(angle) * distance,
                    y: player.y + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    life: SIXTY_SEVEN_KID_MAYHEM_67_DISPLAY_DURATION,
                    t: 0,
                    radius: 20 + Math.random() * 15, // Fixed radius property
                    intensity: 0.7 + Math.random() * 0.3
                });
            }
            
            // After 1 second, start blackout phase
            setTimeout(() => {
                if (gameState !== 'game' || currentStyle !== '67kid') return;
                
                player._67MayhemPhase = 'blackout';
                
                // Create blackout overlay
                vfx.sixtySevenKidBlackoutOverlay.push({
                    life: SIXTY_SEVEN_KID_MAYHEM_BLACKOUT_DURATION,
                    t: 0,
                    opacity: 1.0
                });
                
                // Clear all 67 text during blackout
                vfx.sixtySevenKidTextClones = [];
                
                // After blackout duration, auto goal and finish
                setTimeout(() => {
                    if (gameState !== 'game' || currentStyle !== '67kid') return;
                    
                    // AUTO GOAL!
                    ball.x = W - margin - goalDepth + 5; // Right goal
                    ball.y = H / 2;
                    ball.vx = 0;
                    ball.vy = 0;
                    player.hasBall = false;
                    
                    // Clear blackout
                    vfx.sixtySevenKidBlackoutOverlay = [];
                    
                    // Show AUTO GOAL notification
                    showNotification('AUTO GOAL!', 'success');
                    
                    // Unfreeze player after a brief moment
                    setTimeout(() => {
                        player._frozenFor67Mayhem = false;
                        player._67MayhemPhase = '';
                    }, 200);
                    
                }, SIXTY_SEVEN_KID_MAYHEM_BLACKOUT_DURATION);
                
            }, SIXTY_SEVEN_KID_MAYHEM_67_DISPLAY_DURATION);
            
            showNotification('67 MAYHEM ACTIVATED!', 'success');
        }

        // ===== WALLY ABILITIES =====

        function tryWallyRocketBoost() {
            const now = performance.now();
            if (now < wallyRocketBoostReadyAt) {
                const cooldownLeft = Math.ceil((wallyRocketBoostReadyAt - now) / 1000);
                showNotification(`Rocket Boost on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            // Activate Rocket Boost - very fast dash forward
            wallyRocketBoostReadyAt = now + WALLY_ROCKET_BOOST_COOLDOWN;
            player.wallyRocketBoostActive = true;
            player.wallyRocketBoostEndTime = now + WALLY_ROCKET_BOOST_DURATION;

            // Calculate direction to mouse
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const distance = Math.hypot(dx, dy);
            
            if (distance > 0) {
                // Setup smooth tween animation 200 pixels towards mouse cursor
                const moveDistance = 200; // Exactly 200 pixels
                const dirX = dx / distance;
                const dirY = dy / distance;
                
                // Store tween data
                player.wallyRocketBoostStartX = player.x;
                player.wallyRocketBoostStartY = player.y;
                player.wallyRocketBoostTargetX = player.x + (dirX * moveDistance);
                player.wallyRocketBoostTargetY = player.y + (dirY * moveDistance);
                
                // Keep target within bounds
                player.wallyRocketBoostTargetX = Math.max(player.r, Math.min(W - player.r, player.wallyRocketBoostTargetX));
                player.wallyRocketBoostTargetY = Math.max(player.r, Math.min(H - player.r, player.wallyRocketBoostTargetY));

                // Create rocket boost trail effects
                for (let i = 0; i < 20; i++) {
                    const angle = Math.atan2(dy, dx) + Math.PI + (Math.random() - 0.5) * 0.5;
                    const speed = 8 + Math.random() * 6;
                    vfx.wallyRocketTrail.push({
                        x: player.x + (Math.random() - 0.5) * 20,
                        y: player.y + (Math.random() - 0.5) * 20,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 400 + Math.random() * 200,
                        t: 0,
                        size: 4 + Math.random() * 6,
                        hue: 180 + Math.random() * 40, // Cyan trail
                        intensity: 0.8 + Math.random() * 0.2
                    });
                }
            }

            showNotification('ROCKET BOOST!', 'success');
        }

        function tryWallySpeedForce() {
            const now = performance.now();
            if (now < wallySpeedForceReadyAt) {
                const cooldownLeft = Math.ceil((wallySpeedForceReadyAt - now) / 1000);
                showNotification(`Speed Force on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            // Activate Speed Force
            wallySpeedForceReadyAt = now + WALLY_SPEED_FORCE_COOLDOWN;
            player.wallySpeedForceActive = true;
            player.wallySpeedForceEndTime = now + WALLY_SPEED_FORCE_DURATION;

            // Create dome effect around player
            for (let i = 0; i < 40; i++) {
                const angle = (Math.PI * 2 * i) / 40;
                const radius = WALLY_SPEED_FORCE_RANGE;
                vfx.wallySpeedForceDome.push({
                    x: player.x + Math.cos(angle) * radius,
                    y: player.y + Math.sin(angle) * radius,
                    angle: angle,
                    life: 800,
                    t: 0,
                    size: 8,
                    hue: 180, // Cyan dome
                    intensity: 0.6,
                    radius: radius
                });
            }

            showNotification('SPEED FORCE ACTIVATED!', 'success');
        }

        function tryWallyFlashyLightning() {
            const now = performance.now();
            if (now < wallyFlashyLightningReadyAt) {
                const cooldownLeft = Math.ceil((wallyFlashyLightningReadyAt - now) / 1000);
                showNotification(`Flashy Lightning on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            // Activate Flashy Lightning
            wallyFlashyLightningReadyAt = now + WALLY_FLASHY_LIGHTNING_COOLDOWN;
            player.wallyFlashyLightningActive = true;
            player.wallyFlashyLightningEndTime = now + WALLY_FLASHY_LIGHTNING_DURATION;
            player.wallyFlashyLightningOriginalMaxSpd = player.maxSpd;
            player.maxSpd *= WALLY_FLASHY_LIGHTNING_SPEED_BOOST; // 50% speed boost

            // Create lightning aura around player
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const radius = player.r * 3;
                vfx.wallyLightningAura.push({
                    x: player.x + Math.cos(angle) * radius,
                    y: player.y + Math.sin(angle) * radius,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    life: 300 + Math.random() * 200,
                    t: 0,
                    size: 3 + Math.random() * 4,
                    hue: 180 + Math.random() * 40, // Cyan to light blue
                    intensity: 0.9 + Math.random() * 0.1,
                    spark: true
                });
            }

            // Create lightning bolt effects
            for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 60;
                vfx.wallyLightningBolts.push({
                    x: player.x,
                    y: player.y,
                    targetX: player.x + Math.cos(angle) * distance,
                    targetY: player.y + Math.sin(angle) * distance,
                    life: 200 + Math.random() * 100,
                    t: 0,
                    intensity: 0.8 + Math.random() * 0.2,
                    width: 2 + Math.random() * 3,
                    segments: 5 + Math.floor(Math.random() * 8)
                });
            }

            showNotification('FLASHY LIGHTNING!', 'success');
        }
    </script>
</body>
</html>
