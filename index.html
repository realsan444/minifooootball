<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini Football by San - Free Browser Soccer Game | Play Online Now</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Play Mini Football by San - a free online browser soccer game! No downloads required. Play directly in your web browser. Choose characters, use special abilities, and score goals in this exciting website game by san.">
    <meta name="keywords" content="mini football by san, browser game, website game, online soccer game, web game, no download game, browser football game, play online, free web game, html5 game, san game developer">
    <meta name="author" content="san">
    <meta name="robots" content="index, follow">
    <meta name="application-name" content="Mini Football Browser Game">
    <meta name="category" content="Games">
    <meta name="game-type" content="Sports, Browser Game, Web Game">
    
    <!-- Open Graph Meta Tags (for social media sharing) -->
    <meta property="og:title" content="Mini Football by San - Free Browser Soccer Game">
    <meta property="og:description" content="Play Mini Football by San - a free browser soccer game! No downloads needed. Play this exciting website game directly in your browser. Choose characters, use special abilities, and score goals!">
    <meta property="og:type" content="game">
    <meta property="og:url" content="https://minifootball.pages.dev">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Mini Football by San - Free Browser Soccer Game">
    <meta name="twitter:description" content="Play Mini Football by San - an exciting free online soccer game created by san! Choose from multiple characters, use special abilities, and score goals."
    
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@900&display=swap" rel="stylesheet">
    <style>
        :root{
            --bg:#0b0f14;
            --panel:#1a202c;
            --field:#0e6f3b;
            --line:#e2e8f0;
            --accent:#48bb78;
            --accent-light:#81e6d9;
            --accent2:#f6ad55;
            --danger:#e53e3e;
            --kaiserA:#667eea;
            --kaiserB:#ed64a6;
            --glow:#ffffff;
            --robsan-dark-primary: #312e81;
            --robsan-dark-secondary: #4c1d95;
            --robsan-particle-color: rgba(68, 10, 107, 0.9);
            --robsan-particle-color-light: rgba(99, 58, 161, 0.7);
            --robsan-trail-color-start: rgba(20, 0, 40, 0.95);
            --robsan-trail-color-end: rgba(10, 0, 20, 0.7);
            --robsan-charge-aura-color1: rgba(30, 0, 50, 0.7);
            --robsan-charge-aura-color2: rgba(40, 0, 60, 0.4);
            --robsan-shadow-enhanced: rgba(15, 0, 30, 0.8);
            --robsan-void-enhanced: rgba(5, 0, 15, 0.9);
            --eclipse-aura-start: rgba(0, 0, 0, 0.8);
            --eclipse-aura-end: rgba(30, 0, 50, 0.4);
            --eclipse-line-color: rgba(50, 0, 80, 0.9);
            --eclipse-line-glow: rgba(100, 0, 150, 0.5);
            --void-dash-primary: #1e1b4b;
            --void-dash-secondary: #0c0a09;
            --void-trail-color-start: rgba(0, 0, 0, 0.9);
            --void-trail-color-end: rgba(50, 0, 80, 0.6);
            --xdrake-green-primary: #10b981;
            --xdrake-green-secondary: #059669;
            --xdrake-dash-trail-start: rgba(16, 185, 129, 0.9);
            --xdrake-dash-trail-end: rgba(5, 150, 105, 0.4);
            --xdrake-footwork-color: #6d4b2e;
            --xdrake-footwork-dust: rgba(109, 75, 46, 0.8);
            --xdrake-apex-aura-start: rgba(0, 100, 0, 0.95);
            --xdrake-apex-aura-end: rgba(100, 200, 100, 0.5);
            --xdrake-apex-ball-trail-start: rgba(0, 150, 0, 0.95);
            --xdrake-apex-ball-trail-end: rgba(0, 50, 0, 0.7);
            --xdrake-nature-essence: rgba(34, 197, 94, 0.8);
            --xdrake-earth-power: rgba(101, 69, 34, 0.9);
            --gojo-red-primary: #e53e3e;
            --gojo-red-secondary: #c53030;
            --gojo-blue-primary: #3182ce;
            --gojo-blue-secondary: #2c5282;
            --gojo-purple-primary: #805ad5;
            --gojo-purple-secondary: #553c9a;
            --gojo-red-trail-start: rgba(229, 62, 62, 0.9);
            --gojo-red-trail-end: rgba(197, 48, 48, 0.4);
            --gojo-blue-trail-start: rgba(49, 130, 206, 0.9);
            --gojo-blue-trail-end: rgba(44, 82, 130, 0.4);
            --gojo-purple-trail-start: rgba(128, 90, 213, 0.95);
            --gojo-purple-trail-end: rgba(85, 60, 154, 0.7);
            --gojo-aura-color: rgba(99, 102, 241, 0.5);
            --gojo-infinity-shimmer: rgba(255, 255, 255, 0.8);
            --gojo-domain-energy: rgba(128, 90, 213, 0.7);
            --eddie-primary: #1a202c;
            --eddie-secondary: #000000;
            --eddie-we-are-glow: rgba(255, 0, 0, 0.8);
            --eddie-we-are-aura: rgba(20, 20, 20, 0.5);
            --eddie-venom-strike-tendril-start: rgba(100, 0, 150, 0.9); 
            --eddie-venom-strike-tendril-end: rgba(0, 0, 0, 0.8);    
            --eddie-venom-strike-glow: rgba(150, 0, 200, 0.7); 
            --eddie-venom-strike-trail-start: rgba(30, 0, 50, 0.9);
            --eddie-venom-strike-trail-end: rgba(0, 0, 0, 0.6);
            --eddie-symbiote-montage-trail: rgba(100, 0, 150, 0.7);
            
            --zeus-primary: #3b82f6; 
            --zeus-secondary: #60a5fa; 
            --zeus-lightning-trail-start: rgba(59, 130, 246, 0.9);
            --zeus-lightning-trail-end: rgba(255, 255, 255, 0.6);
            --zeus-shield-aura: rgba(59, 130, 246, 0.4);
            --zeus-shield-glow: rgba(255, 255, 255, 0.7);
            --zeus-olympus-aura-start: rgba(253, 224, 71, 0.8); 
            --zeus-olympus-aura-end: rgba(59, 130, 246, 0.6); 
            --zeus-olympus-ball-trail-start: rgba(253, 224, 71, 0.9);
            --zeus-olympus-ball-trail-end: rgba(255, 255, 255, 0.7);
            
            --ignis-primary: #ff6b35; 
            --ignis-secondary: #e53e3e; 
            --ignis-fire-core: #fbbf24; 
            --ignis-fire-trail-start: rgba(255, 107, 53, 0.95); 
            --ignis-fire-trail-end: rgba(229, 62, 62, 0.7); 
            --ignis-fire-breath-start: rgba(251, 191, 36, 0.9); 
            --ignis-fire-breath-end: rgba(255, 107, 53, 0.4); 
            --ignis-fire-particle: rgba(234, 88, 12, 0.8); 
            --ignis-blaze-dash-trail-start: rgba(255, 107, 53, 0.9);
            --ignis-blaze-dash-trail-end: rgba(254, 158, 15, 0.6); 
            --ignis-phoenix-burst-core: rgba(251, 191, 36, 0.95); 
            --ignis-phoenix-burst-ring: rgba(255, 107, 53, 0.8); 
            --ignis-phoenix-aura: rgba(234, 88, 12, 0.6); 
            --ignis-stun-effect: rgba(255, 0, 0, 0.7); 
            
            --asher-primary: #a78bfa; 
            --asher-secondary: #7c3aed; 
            --asher-star-trail-start: rgba(233, 213, 255, 0.9); 
            --asher-star-trail-end: rgba(167, 139, 250, 0.6); 
            --asher-teleport-burst: rgba(255, 255, 255, 0.9);
            --asher-arrival-glimmer: rgba(209, 213, 219, 0.8);
            
            --leonardo-primary: #06b6d4; 
            --leonardo-secondary: #0891b2; 
            --leonardo-accent: #a5f3fc; 
            --leonardo-trail-start: rgba(6, 182, 212, 0.9);
            --leonardo-trail-end: rgba(165, 243, 252, 0.6);
            
            --angus-primary: #ffffff; 
            --angus-secondary: #f3f4f6; 
            --angus-accent: #e5e7eb; 
            --angus-trail-start: rgba(255, 255, 255, 0.95);
            --angus-trail-end: rgba(243, 244, 246, 0.7);
            --angus-burst-color: rgba(255, 255, 255, 0.95);
            --angus-charge-glow: rgba(255, 255, 255, 0.85);
            --angus-time-distort: rgba(200, 200, 255, 0.6);
            --angus-teleport-shimmer: rgba(255, 255, 255, 0.9);
            
            --diddy-primary: #8B4513; 
            --diddy-secondary: #A0522D; 
            --diddy-accent: #CD853F; 
            --diddy-oil-color: #FFD700; 
            --diddy-oil-shimmer: rgba(255, 215, 0, 0.8);
            --diddy-ascension-glow: rgba(255, 215, 0, 0.9);
            --diddy-trail-start: rgba(139, 69, 19, 0.9);
            --diddy-trail-end: rgba(160, 82, 45, 0.6);
            --baby-oil-guy-subtitle-bg: rgba(0, 0, 0, 0.8);
            --baby-oil-guy-subtitle-text: #FFD700;
            
            --eddie-awakening-bg: #1e3a8a; 
            --eddie-awakening-fill: #22c55e; 
            --eddie-awakening-glow: rgba(0, 0, 0, 0.9); 
            --eddie-awakening-aura: rgba(0, 0, 0, 0.8); 
            
            --cristiano-primary: #dc2626; 
            --cristiano-secondary: #16a34a; 
            --cristiano-accent: #fbbf24; 
            --cristiano-power-shot-trail-start: rgba(255, 50, 50, 0.95);
            --cristiano-power-shot-trail-end: rgba(255, 215, 0, 0.8);
            --cristiano-tackle-burst: rgba(255, 215, 0, 0.95);
            --cristiano-spirit-aura-start: rgba(255, 50, 50, 0.9);
            --cristiano-spirit-aura-end: rgba(22, 163, 74, 0.8);
            --cristiano-trail-start: rgba(255, 50, 50, 0.95);
            --cristiano-trail-end: rgba(255, 215, 0, 0.8);
            --cristiano-power-glow: rgba(255, 215, 0, 0.9);
            --cristiano-shot-explosion: rgba(255, 100, 100, 0.95);
            
            --hudson-primary: #e91e63; 
            --hudson-secondary: #3f51b5; 
            --hudson-emperor-pink: rgba(233, 30, 99, 0.9);
            --hudson-emperor-blue: rgba(63, 81, 181, 0.9);
            --hudson-emperor-trail-start: rgba(233, 30, 99, 0.95);
            --hudson-emperor-trail-end: rgba(63, 81, 181, 0.7);
            --hudson-emperor-aura: rgba(200, 50, 150, 0.6);
            --hudson-emperor-glow: rgba(150, 100, 200, 0.8);
            
            --saja-jin-primary: #4c1d95; 
            --saja-jin-secondary: #1e1b4b; 
            --saja-jin-soul-blue: #3b82f6; 
            --saja-jin-demonic-red: #dc2626; 
            --saja-jin-trail-start: rgba(59, 130, 246, 0.95); 
            --saja-jin-trail-end: rgba(76, 29, 149, 0.7); 
            --saja-jin-heroism-aura: rgba(220, 38, 38, 0.8); 
            --saja-jin-hypnotic-glow: rgba(168, 85, 247, 0.9); 
            --saja-jin-soul-particles: rgba(59, 130, 246, 0.8); 
            
            --lincoln-primary: #32cd32; 
            --lincoln-secondary: #228b22; 
            --lincoln-accent: #90ee90; 
            --lincoln-shrek-green: rgba(50, 205, 50, 0.9);
            --lincoln-trail-start: rgba(50, 205, 50, 0.95);
            --lincoln-trail-end: rgba(34, 139, 34, 0.7);
            --lincoln-shrek-glow: rgba(144, 238, 144, 0.8);
            
            --abby-primary: #ff1493; 
            --abby-secondary: #ff69b4; 
            --abby-accent: #ffc0cb; 
            --abby-colossal-trail-start: rgba(255, 20, 147, 0.95);
            --abby-colossal-trail-end: rgba(255, 105, 180, 0.7);
            --abby-power-pin-glow: rgba(255, 69, 0, 0.9); 
            --abby-demon-drive-aura: rgba(139, 0, 139, 0.8); 
            --abby-demon-drive-trail: rgba(255, 0, 255, 0.9); 
            
            --korbin-primary: #ff6b35; 
            --korbin-secondary: #f7931e; 
            --korbin-accent: #ffa500; 
            --korbin-placeholder-trail-start: rgba(255, 107, 53, 0.9);
            --korbin-placeholder-trail-end: rgba(247, 147, 30, 0.6);
            --korbin-placeholder-glow: rgba(255, 165, 0, 0.8);
            
            --wally-primary: #00bcd4; 
            --wally-secondary: #1565c0; 
            --wally-accent: #81d4fa; 
            --wally-rocket-boost-trail-start: rgba(0, 188, 212, 0.95);
            --wally-rocket-boost-trail-end: rgba(21, 101, 192, 0.7);
            --wally-speed-force-aura: rgba(0, 188, 212, 0.6);
            --wally-speed-force-dome: rgba(129, 212, 250, 0.4);
            --wally-flashy-lightning-glow: rgba(255, 255, 255, 0.9);
            --wally-flashy-lightning-aura: rgba(0, 188, 212, 0.8);
            --wally-trail-start: rgba(0, 188, 212, 0.95);
            --wally-trail-end: rgba(129, 212, 250, 0.7);
            
            --rabies-primary: #87ceeb;
            --rabies-secondary: #000000;
            --rabies-accent: #ffffff;
            --rabies-shadow: rgba(0, 0, 0, 0.9);
            --rabies-ragebait-trail-start: rgba(255, 0, 0, 0.95);
            --rabies-ragebait-trail-end: rgba(139, 0, 0, 0.7);
            --rabies-ragebait-vein: rgba(220, 20, 60, 0.9);
            --rabies-squid-glaze-tentacle: rgba(255, 255, 255, 0.8);
            --rabies-squid-glaze-coating: rgba(255, 255, 255, 0.6);
            --rabies-steal-ballrot-tentacle: rgba(255, 255, 255, 0.9);
            --rabies-pookie-power-aura: rgba(135, 206, 235, 0.7);
            --rabies-pookie-power-energy: rgba(255, 255, 255, 0.8);
            
            --sixsevenkid-primary: #00bcd4; 
            --sixsevenkid-secondary: #2196f3; 
            --sixsevenkid-accent: #ffffff; 
            --sixsevenkid-shadow: #000000; 
            --sixsevenkid-trail-start: rgba(0, 188, 212, 0.95); 
            --sixsevenkid-trail-end: rgba(33, 150, 243, 0.7); 
            --sixsevenkid-text-glow: rgba(0, 188, 212, 0.9); 
            --sixsevenkid-mayhem-aura: rgba(255, 255, 255, 0.8); 
            --sixsevenkid-blackout-overlay: rgba(0, 0, 0, 1); 
        }
        *{box-sizing:border-box}
        html,body{height:100%}

        
        .level-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 24px;
            background: var(--eddie-awakening-bg);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            z-index: 1000;
            padding: 0 20px;
        }
       
        .level-text {
            font-size: 0.9rem;
            color: var(--accent-light);
            text-shadow: 0 0 5px var(--glow);
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
            position: absolute;
            left: 20px;
        }
       
        .progress-bar {
            width: 40%;
            height: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }
       
        .progress-fill {
            height: 100%;
            background: var(--eddie-awakening-fill);
            transition: width 0.3s ease;
            width: 0%;
            box-shadow: 0 0 10px var(--eddie-awakening-fill);
        }
       
        .level-goals {
            font-size: 0.9rem;
            color: var(--accent-light);
            text-shadow: 0 0 5px var(--glow);
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
            position: absolute;
            right: 20px;
        }
       
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: var(--accent-light);
            text-shadow: 0 0 20px var(--glow);
            opacity: 0;
            pointer-events: none;
            animation: levelUpAnim 2s ease-out forwards;
            z-index: 1000;
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
        }
       
        @keyframes levelUpAnim {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        body{
            margin:0;
            display:flex;
            align-items:center;
            justify-content:center;
            flex-direction:column;
            background:radial-gradient(1000px 500px at 50% -10%, #1a202c 0%, var(--bg) 60%);
            color:var(--line);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .screen{
            position:absolute;
            inset:0;
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            transition:opacity 0.3s ease-in-out;
            opacity:0;
            visibility:hidden;
        }
        .screen.active{opacity:1; visibility:visible;}

        .main-menu{
            gap:28px;
        }
        .main-menu h1{
            font-size:3.8rem;
            margin:0 0 20px;
            text-align:center;
            color: var(--accent-light);
            text-shadow: 0 4px 12px rgba(0,0,0,0.5), 0 0 10px var(--glow);
            animation:popIn 0.6s cubic-bezier(.36,.07,.19,.97) both;
        }
        .menu-button{
            padding:12px 24px;
            border:2px solid var(--accent);
            border-radius:8px;
            background:linear-gradient(to bottom, rgba(72,187,120,0.2), rgba(72,187,120,0.1));
            color:var(--line);
            font-size:1.0rem;
            font-weight:bold;
            cursor:pointer;
            transition:transform 0.15s ease-in-out, background 0.15s ease-in-out, border-color 0.15s ease-in-out;
            width:180px;
            text-align:center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .menu-button:hover{
            transform:translateY(-2px);
            background:linear-gradient(to bottom, rgba(72,187,120,0.3), rgba(72,187,120,0.2));
            border-color: var(--accent-light);
        }
        .menu-button:active{transform:translateY(1px);}
       
        .menu-button.horizontal {
            width: 180px;
            margin: 0;
        }

        .menu-button.level-reset {
            background: linear-gradient(135deg, #10b981, #059669) !important;
            color: white !important;
            border: 2px solid #10b981 !important;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
            transition: all 0.3s ease;
        }

        .menu-button.level-reset:hover {
            background: linear-gradient(135deg, #059669, #047857) !important;
            border-color: #059669 !important;
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
            transform: translateY(-3px);
        }

        .menu-button.level-reset:active {
            transform: translateY(0px);
            box-shadow: 0 2px 10px rgba(16, 185, 129, 0.3);
        }

        .game-screen{
            gap:20px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .wrap{
            position:relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        canvas{
            background:linear-gradient(0deg, rgba(14,111,59,.95), rgba(12,98,52,.95));
            border:6px solid #2a4334;
            border-radius:12px;
            box-shadow:0 12px 30px rgba(0,0,0,.4);
        }
        .hud{position:absolute; inset:auto 20px 20px 20px; display:flex; justify-content:space-between; pointer-events:none; width: auto;}
        .hud > * {background:rgba(26, 32, 44, 0.85); border:1px solid rgba(255,255,255,0.05); backdrop-filter: blur(8px); padding:12px 18px; border-radius:8px; box-shadow: 0 6px 16px rgba(0,0,0,0.3);}

        #game-screen.active .hud {
            display: none;
        }

        .row{display:flex; gap:8px; align-items:center}
        .kbd{display:inline-block; padding:4px 8px; border-radius:4px; border:1px solid rgba(255,255,255,.1); font-weight:600; background:rgba(255,255,255,.04); font-size:0.9rem;}
        .powerbar{position:absolute; left:50%; transform:translateX(-50%); top:20px; width:60%; height:14px; border-radius:10px; background:rgba(255,255,255,.1); border:1px solid rgba(255,255,255,.15); overflow:hidden; box-shadow: 0 3px 8px rgba(0,0,0,0.4); transition: all 0.2s ease;}
        .fill{height:100%; width:0%; background:linear-gradient(90deg, var(--accent), var(--accent2), var(--accent-light)); border-radius:10px; transition:width .06s ease-out; box-shadow: 0 0 6px rgba(72,187,120,0.5);}
        .title{font-weight:700; letter-spacing:.3px; opacity:.9; font-size:1.1rem; color: var(--glow); text-shadow: 0 0 6px var(--glow);}
        .small{opacity:.7; font-size:0.85rem;}
        .badge{font-size:0.8rem; padding:3px 7px; border-radius:999px; border:1px solid rgba(255,255,255,.15); background:rgba(255,255,255,.05); margin-left:8px;}

        .movesbar{
            position:absolute;
            left:50%;
            bottom:20px;
            transform:translateX(-50%);
            display:flex; gap:16px; align-items:center; justify-content:center;
            padding:12px 20px; border-radius:10px; background:rgba(26, 32, 44, 0.7);
            border:1px solid rgba(255,255,255,.06); backdrop-filter: blur(8px);
            box-shadow:0 8px 20px rgba(0,0,0,.35); z-index:10;
        }
        .slot{
            position:relative; min-width:180px; height:42px; border-radius:8px; overflow:hidden; cursor:default;
            border:1px solid rgba(255,255,255,.1); background:linear-gradient(90deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
            box-shadow: inset 0 1px 0 rgba(255,255,255,.04), 0 4px 12px rgba(0,0,0,.2);

        }

        .slot .label{position:absolute; inset:0; display:flex; align-items:center; gap:8px; padding:0 12px; font-weight:600; letter-spacing:.2px; color: var(--line); text-shadow: 0 0 4px var(--glow);}
        .slot .key{font-size:0.8rem; font-weight:700; padding:3px 6px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.05);}
        .slot .name{opacity:.9;}
        .slot .ready{position:absolute; inset:0; background:linear-gradient(90deg, var(--kaiserA), var(--kaiserB)); opacity:.15; border-radius: 8px;}
        .slot.robsan .ready { background: linear-gradient(90deg, var(--robsan-dark-primary), var(--robsan-dark-secondary)); opacity: 0.2; }
        .slot.robsan.eclipse-ready .ready { background: linear-gradient(90deg, var(--eclipse-aura-start), var(--eclipse-aura-end)); opacity: 0.25; }
        .slot.robsan.void-ready .ready { background: linear-gradient(90deg, var(--void-dash-primary), var(--void-dash-secondary)); opacity: 0.25; }
        .slot.xdrake.ready .ready { background: linear-gradient(90deg, var(--xdrake-green-primary), var(--xdrake-green-secondary)); opacity: 0.25; }
        .slot.xdrake.footwork-ready .ready { background: linear-gradient(90deg, var(--xdrake-footwork-color), var(--xdrake-green-secondary)); opacity: 0.25; }
        .slot.xdrake.apex-ready .ready { background: linear-gradient(90deg, var(--xdrake-apex-aura-start), var(--xdrake-apex-aura-end)); opacity: 0.25; }
        .slot.gojo.ready .ready { background: linear-gradient(90deg, var(--gojo-blue-primary), var(--gojo-red-primary)); opacity: 0.25; }
        .slot.gojo.gojo-red-ready .ready { background: linear-gradient(90deg, var(--gojo-red-primary), var(--gojo-red-secondary)); opacity: 0.25; }
        .slot.gojo.gojo-blue-ready .ready { background: linear-gradient(90deg, var(--gojo-blue-primary), var(--gojo-blue-secondary)); opacity: 0.25; }
        .slot.gojo.gojo-purple-ready .ready { background: linear-gradient(90deg, var(--gojo-purple-primary), var(--gojo-purple-secondary)); opacity: 0.25; }
        .slot.eddie.ready .ready { background: linear-gradient(90deg, var(--eddie-primary), var(--eddie-secondary)); opacity: 0.35; }
        .slot.zeus.ready .ready { background: linear-gradient(90deg, var(--zeus-primary), var(--zeus-secondary)); opacity: 0.25; } 
        .slot.ignis.ready .ready { background: linear-gradient(90deg, var(--ignis-primary), var(--ignis-secondary)); opacity: 0.3; } 
        .slot.asher.ready .ready { background: linear-gradient(90deg, var(--asher-primary), var(--asher-secondary)); opacity: 0.25; } 
        .slot.rabies.ready .ready { background: linear-gradient(90deg, var(--rabies-primary), var(--rabies-secondary)); opacity: 0.3; } 
        .slot.rabies.ragebait-ready .ready { background: linear-gradient(90deg, var(--rabies-ragebait-aura), var(--rabies-primary)); opacity: 0.35; }
        .slot.rabies.squid-glaze-ready .ready { background: linear-gradient(90deg, var(--rabies-squid-glaze-color), var(--rabies-secondary)); opacity: 0.35; }
        .slot.rabies.steal-ballrot-ready .ready { background: linear-gradient(90deg, var(--rabies-steal-ballrot-energy), var(--rabies-secondary)); opacity: 0.35; }
        .slot.rabies.pookie-power-ready .ready { background: linear-gradient(90deg, var(--rabies-pookie-power-aura), var(--rabies-pookie-power-energy)); opacity: 0.35; } 


        .slot .pulse{position:absolute; inset:-1px; border-radius:inherit; border:1px solid transparent;}
        .slot.ready .pulse{animation:pulseGlow 1.2s ease-in-out infinite}
        .slot.robsan.ready .pulse {
             animation:pulseRobsanGlow 1.2s ease-in-out infinite;
        }
        .slot.robsan.eclipse-ready .pulse {
            animation:pulseEclipseGlow 1.2s ease-in-out infinite;
        }
        .slot.robsan.void-ready .pulse {
            animation:pulseVoidGlow 1.2s ease-in-out infinite;
        }

        .slot.xdrake.ready .pulse { animation:pulseXDDashGlow 1.2s ease-in-out infinite; }
        .slot.xdrake.footwork-ready .pulse { animation:pulseXDFootworkGlow 1.2s ease-in-out infinite; }
        .slot.xdrake.apex-ready .pulse { animation:pulseXDApexGlow 1.2s ease-in-out infinite; }
        .slot.gojo.gojo-red-ready .pulse { animation:pulseGojoRedGlow 1.2s ease-in-out infinite; }
        .slot.gojo.gojo-blue-ready .pulse { animation:pulseGojoBlueGlow 1.2s ease-in-out infinite; }
        .slot.gojo.gojo-purple-ready .pulse { animation:pulseGojoPurpleGlow 1.2s ease-in-out infinite; }
        .slot.eddie.ready .pulse { animation:pulseEddieGlow 1.2s ease-in-out infinite; }
        .slot.zeus.ready .pulse { animation:pulseZeusGlow 1.2s ease-in-out infinite; } 
        .slot.ignis.ready .pulse { animation:pulseIgnisGlow 1.2s ease-in-out infinite; } 
        .slot.asher.ready .pulse { animation:pulseAsherGlow 1.2s ease-in-out infinite; }
        .slot.rabies.ready .pulse { animation:pulseRabiesGlow 1.2s ease-in-out infinite; }
        .slot.rabies.ragebait-ready .pulse { animation:pulseRabiesRagebaitGlow 1.2s ease-in-out infinite; }
        .slot.rabies.squid-glaze-ready .pulse { animation:pulseRabiesSquidGlazeGlow 1.2s ease-in-out infinite; }
        .slot.rabies.steal-ballrot-ready .pulse { animation:pulseRabiesStealBallrotGlow 1.2s ease-in-out infinite; }
        .slot.rabies.pookie-power-ready .pulse { animation:pulseRabiesPookiePowerGlow 1.2s ease-in-out infinite; } 
        .slot.leonardo.ready .pulse { animation:pulseLeonardoGlow 1.2s ease-in-out infinite; }
.slot.leonardo.ready .ready { background: linear-gradient(90deg, var(--leonardo-primary), var(--leonardo-secondary)); opacity: 0.25; }
.slot.angus.ready .pulse { animation:pulseAngusGlow 1.2s ease-in-out infinite; }
.slot.angus.ready .ready { background: linear-gradient(90deg, var(--angus-primary), var(--angus-secondary)); opacity: 0.25; }

        .slot.diddy.ready .pulse { animation:pulseBabyOilGuyGlow 1.2s ease-in-out infinite; }
        .slot.diddy.ready .ready { background: linear-gradient(90deg, var(--diddy-primary), var(--diddy-secondary)); opacity: 0.25; }
        .slot.cristiano.ready .pulse { animation:pulseCristianoGlow 1.2s ease-in-out infinite; }
        .slot.cristiano.ready .ready { background: linear-gradient(90deg, var(--cristiano-primary), var(--cristiano-secondary)); opacity: 0.25; }
        .slot.hudson.ready .pulse { animation:pulseHudsonGlow 1.2s ease-in-out infinite; }
        .slot.hudson.ready .ready { background: linear-gradient(90deg, var(--hudson-primary), var(--hudson-secondary)); opacity: 0.25; }
        .slot.saja-jin.ready .pulse { animation:pulseSajaJinGlow 1.2s ease-in-out infinite; }
        .slot.saja-jin.ready .ready { background: linear-gradient(90deg, var(--saja-jin-primary), var(--saja-jin-secondary)); opacity: 0.25; }
        .slot.lincoln.ready .pulse { animation:pulseLincolnGlow 1.2s ease-in-out infinite; }
        .slot.lincoln.ready .ready { background: linear-gradient(90deg, var(--lincoln-primary), var(--lincoln-secondary)); opacity: 0.25; }
        .slot.abby.ready .pulse { animation:pulseAbbyGlow 1.2s ease-in-out infinite; }
        .slot.abby.ready .ready { background: linear-gradient(90deg, var(--abby-primary), var(--abby-secondary)); opacity: 0.25; }
        .slot.wally.ready .pulse { animation:pulseWallyGlow 1.2s ease-in-out infinite; }
        .slot.wally.ready .ready { background: linear-gradient(90deg, var(--wally-primary), var(--wally-secondary)); opacity: 0.25; }
        .slot.korbin.ready .pulse { animation:pulseKorbinGlow 1.2s ease-in-out infinite; }
        .slot.korbin.ready .ready { background: linear-gradient(90deg, var(--korbin-primary), var(--korbin-secondary)); opacity: 0.25; }
        .slot.sixsevenkid.ready .pulse { animation:pulse67KidGlow 1.2s ease-in-out infinite; }
        .slot.sixsevenkid.ready .ready { background: linear-gradient(90deg, var(--sixsevenkid-primary), var(--sixsevenkid-secondary)); opacity: 0.25; }
        .slot.rabies.ready .pulse { animation:pulseRabiesGlow 1.2s ease-in-out infinite; }
        .slot.rabies.ready .ready { background: linear-gradient(90deg, var(--rabies-primary), var(--rabies-secondary)); opacity: 0.25; }
        .slot.rabies.ragebait-ready .ready { background: linear-gradient(90deg, var(--rabies-ragebait-trail-start), var(--rabies-ragebait-trail-end)); opacity: 0.3; }
        .slot.rabies.squid-glaze-ready .ready { background: linear-gradient(90deg, var(--rabies-squid-glaze-tentacle), var(--rabies-squid-glaze-coating)); opacity: 0.3; }
        .slot.rabies.steal-ballrot-ready .ready { background: linear-gradient(90deg, var(--rabies-steal-ballrot-tentacle), var(--rabies-primary)); opacity: 0.3; }
        .slot.rabies.pookie-power-ready .ready { background: linear-gradient(90deg, var(--rabies-pookie-power-aura), var(--rabies-pookie-power-energy)); opacity: 0.3; }

        @keyframes pulseGlow{
            0%{box-shadow:0 0 0 0 rgba(102,126,234,.3), 0 0 0 0 rgba(237,100,166,.3)}
            70%{box-shadow:0 0 0 8px rgba(102,126,234,0), 0 0 0 16px rgba(237,100,166,0)}
            100%{box-shadow:0 0 0 0 rgba(102,126,234,0), 0 0 0 0 rgba(237,100,166,0)}
        }
        @keyframes pulseRobsanGlow{
            0%{box-shadow:0 0 0 0 rgba(49,46,129,.3), 0 0 0 0 rgba(76,29,149,.3)}
            70%{box-shadow:0 0 0 8px rgba(49,46,129,0), 0 0 0 16px rgba(76,29,149,0)}
            100%{box-shadow:0 0 0 0 rgba(49,46,129,0), 0 0 0 0 rgba(76,29,149,0)}
        }
        @keyframes pulseEclipseGlow{
            0%{box-shadow:0 0 0 0 rgba(0,0,0,.4), 0 0 0 0 rgba(30,0,50,.4)}
            70%{box-shadow:0 0 0 8px rgba(0,0,0,0), 0 0 0 16px rgba(30,0,50,0)}
            100%{box-shadow:0 0 0 0 rgba(0,0,0,0), 0 0 0 0 rgba(30,0,50,0)}
        }
        @keyframes pulseVoidGlow{
            0%{box-shadow:0 0 0 0 rgba(30,27,75,.4), 0 0 0 0 rgba(12,10,9,.4)}
            70%{box-shadow:0 0 0 8px rgba(30,27,75,0), 0 0 0 16px rgba(12,10,9,0)}
            100%{box-shadow:0 0 0 0 rgba(30,27,75,0), 0 0 0 0 rgba(12,10,9,0)}
        }
        @keyframes pulseXDDashGlow{
            0%{box-shadow:0 0 0 0 rgba(16,185,129,.4), 0 0 0 0 rgba(5,150,105,.4)}
            70%{box-shadow:0 0 0 8px rgba(16,185,129,0), 0 0 0 16px rgba(5,150,105,0)}
            100%{box-shadow:0 0 0 0 rgba(16,185,129,0), 0 0 0 0 rgba(5,150,105,0)}
        }
        @keyframes pulseXDFootworkGlow{
            0%{box-shadow:0 0 0 0 rgba(109,75,46,.4), 0 0 0 0 rgba(5,150,105,.4)}
            70%{box-shadow:0 0 0 8px rgba(109,75,46,0), 0 0 0 16px rgba(5,150,105,0)}
            100%{box-shadow:0 0 0 0 rgba(109,75,46,0), 0 0 0 0 rgba(5,150,105,0)}
        }
        @keyframes pulseXDApexGlow{
            0%{box-shadow:0 0 0 0 rgba(0,100,0,.4), 0 0 0 0 rgba(100,200,100,.4)}
            70%{box-shadow:0 0 0 8px rgba(0,100,0,0), 0 0 0 16px rgba(100,200,100,0)}
            100%{box-shadow:0 0 0 0 rgba(0,100,0,0), 0 0 0 0 rgba(100,200,100,0)}
        }
        @keyframes pulseGojoRedGlow{
            0%{box-shadow:0 0 0 0 rgba(229,62,62,.4), 0 0 0 0 rgba(197,48,48,.4)}
            70%{box-shadow:0 0 0 8px rgba(229,62,62,0), 0 0 0 16px rgba(197,48,48,0)}
            100%{box-shadow:0 0 0 0 rgba(229,62,62,0), 0 0 0 0 rgba(197,48,48,0)}
        }
        @keyframes pulseGojoBlueGlow{
            0%{box-shadow:0 0 0 0 rgba(49,130,206,.4), 0 0 0 0 rgba(44,82,130,.4)}
            70%{box-shadow:0 0 0 8px rgba(49,130,206,0), 0 0 0 16px rgba(44,82,130,0)}
            100%{box-shadow:0 0 0 0 rgba(49,130,206,0), 0 0 0 0 rgba(44,82,130,0)}
        }
        @keyframes pulseGojoPurpleGlow{
            0%{box-shadow:0 0 0 0 rgba(128,90,213,.4), 0 0 0 0 rgba(85,60,154,.4)}
            70%{box-shadow:0 0 0 8px rgba(128,90,213,0), 0 0 0 16px rgba(85,60,154,0)}
            100%{box-shadow:0 0 0 0 rgba(128,90,213,0), 0 0 0 0 rgba(85,60,154,0)}
        }
        @keyframes pulseEddieGlow{
            0%{box-shadow:0 0 0 0 rgba(0,0,0,.4), 0 0 0 0 rgba(26,32,44,.4)}
            70%{box-shadow:0 0 0 8px rgba(0,0,0,0), 0 0 0 16px rgba(26,32,44,0)}
            100%{box-shadow:0 0 0 0 rgba(0,0,0,0), 0 0 0 0 rgba(26,32,44,0)}
        }
        
        @keyframes pulseZeusGlow{
            0%{box-shadow:0 0 0 0 rgba(59,130,246,.4), 0 0 0 0 rgba(96,165,250,.4)}
            70%{box-shadow:0 0 0 8px rgba(59,130,246,0), 0 0 0 16px rgba(96,165,250,0)}
            100%{box-shadow:0 0 0 0 rgba(59,130,246,0), 0 0 0 0 rgba(96,165,250,0)}
        }
        
        @keyframes pulseIgnisGlow{
            0%{box-shadow:0 0 0 0 rgba(255,107,53,.5), 0 0 0 0 rgba(229,62,62,.5)}
            70%{box-shadow:0 0 0 8px rgba(255,107,53,0), 0 0 0 16px rgba(229,62,62,0)}
            100%{box-shadow:0 0 0 0 rgba(255,107,53,0), 0 0 0 0 rgba(229,62,62,0)}
        }
        
        @keyframes pulseAsherGlow{
            0%{box-shadow:0 0 0 0 rgba(167,139,250,.4), 0 0 0 0 rgba(233,213,255,.4)}
            70%{box-shadow:0 0 0 8px rgba(167,139,250,0), 0 0 0 16px rgba(233,213,255,0)}
            100%{box-shadow:0 0 0 0 rgba(167,139,250,0), 0 0 0 0 rgba(233,213,255,0)}
        }

        
        @keyframes pulseLeonardoGlow{
            0%{box-shadow:0 0 0 0 rgba(6,182,212,.4), 0 0 0 0 rgba(165,243,252,.4)}
            70%{box-shadow:0 0 0 8px rgba(6,182,212,0), 0 0 0 16px rgba(165,243,252,0)}
            100%{box-shadow:0 0 0 0 rgba(6,182,212,0), 0 0 0 0 rgba(165,243,252,0)}
        }
        
        @keyframes pulseAngusGlow{
            0%{box-shadow:0 0 0 0 rgba(255,255,255,.4), 0 0 0 0 rgba(243,244,246,.4)}
            70%{box-shadow:0 0 0 8px rgba(255,255,255,0), 0 0 0 16px rgba(243,244,246,0)}
            100%{box-shadow:0 0 0 0 rgba(255,255,255,0), 0 0 0 0 rgba(243,244,246,0)}
        }
        
        @keyframes pulseBabyOilGuyGlow{
            0%{box-shadow:0 0 0 0 rgba(139,69,19,.4), 0 0 0 0 rgba(255,215,0,.4)}
            70%{box-shadow:0 0 0 8px rgba(139,69,19,0), 0 0 0 16px rgba(255,215,0,0)}
            100%{box-shadow:0 0 0 0 rgba(139,69,19,0), 0 0 0 0 rgba(255,215,0,0)}
        }
        @keyframes pulseCristianoGlow{
            0%{box-shadow:0 0 0 0 rgba(220,38,38,.4), 0 0 0 0 rgba(22,163,74,.4)}
            70%{box-shadow:0 0 0 8px rgba(220,38,38,0), 0 0 0 16px rgba(22,163,74,0)}
            100%{box-shadow:0 0 0 0 rgba(220,38,38,0), 0 0 0 0 rgba(22,163,74,0)}
        }
        @keyframes pulseHudsonGlow{
            0%{box-shadow:0 0 0 0 rgba(233,30,99,.4), 0 0 0 0 rgba(63,81,181,.4)}
            70%{box-shadow:0 0 0 8px rgba(233,30,99,0), 0 0 0 16px rgba(63,81,181,0)}
            100%{box-shadow:0 0 0 0 rgba(233,30,99,0), 0 0 0 0 rgba(63,81,181,0)}
        }
        @keyframes pulseSajaJinGlow{
            0%{box-shadow:0 0 0 0 rgba(76,29,149,.4), 0 0 0 0 rgba(59,130,246,.4)}
            70%{box-shadow:0 0 0 8px rgba(76,29,149,0), 0 0 0 16px rgba(59,130,246,0)}
            100%{box-shadow:0 0 0 0 rgba(76,29,149,0), 0 0 0 0 rgba(59,130,246,0)}
        }
        @keyframes pulseLincolnGlow{
            0%{box-shadow:0 0 0 0 rgba(50,205,50,.4), 0 0 0 0 rgba(34,139,34,.4)}
            70%{box-shadow:0 0 0 8px rgba(50,205,50,0), 0 0 0 16px rgba(34,139,34,0)}
            100%{box-shadow:0 0 0 0 rgba(50,205,50,0), 0 0 0 0 rgba(34,139,34,0)}
        }
        @keyframes pulseAbbyGlow{
            0%{box-shadow:0 0 0 0 rgba(255,20,147,.4), 0 0 0 0 rgba(255,105,180,.4)}
            70%{box-shadow:0 0 0 8px rgba(255,20,147,0), 0 0 0 16px rgba(255,105,180,0)}
            100%{box-shadow:0 0 0 0 rgba(255,20,147,0), 0 0 0 0 rgba(255,105,180,0)}
        }
        @keyframes pulseWallyGlow{
            0%{box-shadow:0 0 0 0 rgba(0,188,212,.4), 0 0 0 0 rgba(21,101,192,.4)}
            70%{box-shadow:0 0 0 8px rgba(0,188,212,0), 0 0 0 16px rgba(21,101,192,0)}
            100%{box-shadow:0 0 0 0 rgba(0,188,212,0), 0 0 0 0 rgba(21,101,192,0)}
        }
        @keyframes pulseKorbinGlow{
            0%{box-shadow:0 0 0 0 rgba(255,107,53,.4), 0 0 0 0 rgba(247,147,30,.4)}
            70%{box-shadow:0 0 0 8px rgba(255,107,53,0), 0 0 0 16px rgba(247,147,30,0)}
            100%{box-shadow:0 0 0 0 rgba(255,107,53,0), 0 0 0 0 rgba(247,147,30,0)}
        }
        @keyframes pulse67KidGlow{
            0%{box-shadow:0 0 0 0 rgba(0,188,212,.4), 0 0 0 0 rgba(33,150,243,.4)}
            70%{box-shadow:0 0 0 8px rgba(0,188,212,0), 0 0 0 16px rgba(33,150,243,0)}
            100%{box-shadow:0 0 0 0 rgba(0,188,212,0), 0 0 0 0 rgba(33,150,243,0)}
        }
        @keyframes pulseRabiesGlow{
            0%{box-shadow:0 0 0 0 rgba(135,206,235,.4), 0 0 0 0 rgba(255,255,255,.4)}
            70%{box-shadow:0 0 0 8px rgba(135,206,235,0), 0 0 0 16px rgba(255,255,255,0)}
            100%{box-shadow:0 0 0 0 rgba(135,206,235,0), 0 0 0 0 rgba(255,255,255,0)}
        }
        @keyframes pulseRabiesRagebaitGlow{
            0%{box-shadow:0 0 0 0 rgba(255,0,0,.4), 0 0 0 0 rgba(135,206,235,.4)}
            70%{box-shadow:0 0 0 8px rgba(255,0,0,0), 0 0 0 16px rgba(135,206,235,0)}
            100%{box-shadow:0 0 0 0 rgba(255,0,0,0), 0 0 0 0 rgba(135,206,235,0)}
        }
        @keyframes pulseRabiesSquidGlazeGlow{
            0%{box-shadow:0 0 0 0 rgba(135,206,235,.4), 0 0 0 0 rgba(0,0,0,.4)}
            70%{box-shadow:0 0 0 8px rgba(135,206,235,0), 0 0 0 16px rgba(0,0,0,0)}
            100%{box-shadow:0 0 0 0 rgba(135,206,235,0), 0 0 0 0 rgba(0,0,0,0)}
        }
        @keyframes pulseRabiesStealBallrotGlow{
            0%{box-shadow:0 0 0 0 rgba(255,255,255,.4), 0 0 0 0 rgba(135,206,235,.4)}
            70%{box-shadow:0 0 0 8px rgba(255,255,255,0), 0 0 0 16px rgba(135,206,235,0)}
            100%{box-shadow:0 0 0 0 rgba(255,255,255,0), 0 0 0 0 rgba(135,206,235,0)}
        }
        @keyframes pulseRabiesPookiePowerGlow{
            0%{box-shadow:0 0 0 0 rgba(255,255,255,.5), 0 0 0 0 rgba(135,206,235,.5)}
            70%{box-shadow:0 0 0 8px rgba(255,255,255,0), 0 0 0 16px rgba(135,206,235,0)}
            100%{box-shadow:0 0 0 0 rgba(255,255,255,0), 0 0 0 0 rgba(135,206,235,0)}
        }

        
        .scoreboard {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 80px;
            height: 120px;
            background: rgba(26, 32, 44, 0.9);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            backdrop-filter: blur(8px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
        }
       
        .scoreboard-left {
            left: 10px;
        }
       
        .scoreboard-right {
            right: 10px;
        }
       
        .scoreboard-title {
            font-size: 0.8rem;
            color: var(--accent-light);
            text-shadow: 0 0 5px var(--glow);
            margin-bottom: 8px;
        }
       
        .scoreboard-score {
            font-size: 2.5rem;
            color: var(--glow);
            text-shadow: 0 0 10px var(--accent-light);
            line-height: 1;
        }

        
        @keyframes captionFade {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        @keyframes captionSlideFromTop {
            0% { transform: translateX(-50%) translateY(-100%); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        @keyframes captionSlideFromBottom {
            0% { transform: translateX(-50%) translateY(100%); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        @keyframes captionSlideFromLeft {
            0% { transform: translateX(-150%) translateY(0); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        @keyframes captionSlideFromRight {
            0% { transform: translateX(50%) translateY(0); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        @keyframes captionBounce {
            0% { transform: translateX(-50%) scale(0); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.1); opacity: 1; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        @keyframes captionZoom {
            0% { transform: translateX(-50%) scale(0); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        @keyframes captionFadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .slot .cool{
            position:absolute; left:0; top:0; bottom:0; width:0%;
            background:linear-gradient(90deg, rgba(102,126,234,.8), rgba(237,100,166,.8));
            opacity:.2; border-radius: 8px;
        }
        .slot.robsan .cool {
             background:linear-gradient(90deg, var(--robsan-dark-primary), var(--robsan-dark-secondary));
        }
        .slot.robsan.eclipse-cool .cool {
             background:linear-gradient(90deg, var(--eclipse-line-color), var(--eclipse-line-glow));
        }
        .slot.robsan.void-cool .cool {
             background:linear-gradient(90deg, var(--void-dash-primary), var(--void-dash-secondary));
        }
        .slot.xdrake .cool {
             background:linear-gradient(90deg, var(--xdrake-green-primary), var(--xdrake-green-secondary));
        }
        .slot.xdrake.footwork-cool .cool {
             background:linear-gradient(90deg, var(--xdrake-footwork-color), var(--xdrake-green-secondary));
        }
        .slot.xdrake.apex-cool .cool {
             background:linear-gradient(90deg, var(--xdrake-apex-aura-start), var(--xdrake-apex-aura-end));
        }
        .slot.gojo.gojo-red-cool .cool { background: linear-gradient(90deg, var(--gojo-red-primary), var(--gojo-red-secondary)); }
        .slot.gojo.gojo-blue-cool .cool { background: linear-gradient(90deg, var(--gojo-blue-primary), var(--gojo-blue-secondary)); }
        .slot.gojo.gojo-purple-cool .cool { background: linear-gradient(90deg, var(--gojo-purple-primary), var(--gojo-purple-secondary)); }
        .slot.eddie .cool { background: linear-gradient(90deg, var(--eddie-primary), var(--eddie-secondary)); }
        .slot.zeus .cool { background: linear-gradient(90deg, var(--zeus-primary), var(--zeus-secondary)); } 
        .slot.ignis .cool { background: linear-gradient(90deg, var(--ignis-primary), var(--ignis-secondary)); } 
        .slot.asher .cool { background: linear-gradient(90deg, var(--asher-primary), var(--asher-secondary)); } 
.slot.leonardo .cool { background: linear-gradient(90deg, var(--leonardo-primary), var(--leonardo-secondary)); }
        .slot.angus .cool { background: linear-gradient(90deg, var(--angus-primary), var(--angus-secondary)); }
        .slot.diddy .cool { background: linear-gradient(90deg, var(--diddy-primary), var(--diddy-secondary)); }
        .slot.korbin .cool { background: linear-gradient(90deg, var(--korbin-primary), var(--korbin-secondary)); }
        .slot.sixsevenkid .cool { background: linear-gradient(90deg, var(--sixsevenkid-primary), var(--sixsevenkid-secondary)); }

        .slot .coolText{position:absolute; right:8px; top:50%; transform:translateY(-50%); font-size:0.75rem; opacity:.7;}

        .modal-backdrop{
            position:fixed; inset:0; background:rgba(0,0,0,.7);
            backdrop-filter:blur(6px); z-index:100;
            display:flex; align-items:center; justify-content:center;
            opacity:0; visibility:hidden; transition:opacity 0.2s ease-in-out;
        }
        .modal-backdrop.open{opacity:1; visibility:visible;}
        .modal-content{
            background:var(--panel); border:1px solid rgba(255,255,255,.08);
            border-radius:12px; padding:32px; width:400px; max-width:90%;
            transform:scale(0.95) translateY(10px); transition:transform 0.3s cubic-bezier(.36,.07,.19,.97);
            box-shadow:0 10px 25px rgba(0,0,0,.5);
            color: var(--line);
            position: relative;
        }
        .modal-backdrop.open .modal-content{transform:scale(1) translateY(0);}
        .modal-content h2{margin-top:0; font-size:2.2rem; letter-spacing:.4px; color: var(--accent-light); text-shadow: 0 0 8px var(--glow);}
        .modal-content p{line-height:1.6; opacity:0.85; font-size:1rem; margin-bottom:0; color: var(--line);}
        .modal-content .close-button{
            position:absolute; top:10px; right:10px;
            padding:6px; background:none; border:none;
            color:rgba(255,255,255,0.7); font-size:1.4rem; cursor:pointer;
            transition:transform 0.15s ease-in-out, color 0.15s ease-in-out;
        }
        .modal-content .close-button:hover{color:var(--danger); transform:rotate(90deg);}
        .modal-content .toggle-container{
            display:flex; flex-direction:column; gap:10px; margin-top:20px;
        }
        .toggle-group{
            display:flex; flex-wrap: wrap; gap:8px;
            background:rgba(255,255,255,0.03); padding:5px; border-radius:8px;
            justify-content: center;
        }
        .toggle-button{
            flex:1; padding:10px 16px; border-radius:6px; cursor:pointer;
            background:transparent; transition:background 0.15s ease-in-out, color 0.15s ease-in-out, border-color 0.15s ease-in-out;
            border:1px solid transparent; font-weight:500; text-align:center; color: var(--line);
            min-width: 120px;
        }
        .toggle-button.active{background:var(--accent); color:var(--panel); border-color:var(--accent-light);}
        .toggle-button.robsan.active{background:var(--robsan-dark-primary); color:white; border-color:var(--robsan-dark-secondary);}
        .toggle-button.xdrake.active{background:var(--xdrake-green-primary); color:white; border-color:var(--xdrake-green-secondary);}
        .toggle-button.gojo.active{background:var(--gojo-blue-primary); color:white; border-color:var(--gojo-purple-primary);}
        .toggle-button.eddie.active{background:var(--eddie-primary); color:white; border-color:var(--eddie-secondary);}
        .toggle-button.zeus.active{background:var(--zeus-primary); color:white; border-color:var(--zeus-secondary);} 
        .toggle-button.ignis.active{background:var(--ignis-primary); color:white; border-color:var(--ignis-secondary);} 
        .toggle-button.asher.active{background:var(--asher-primary); color:white; border-color:var(--asher-secondary);} 
        .toggle-button.leonardo.active{background:var(--leonardo-primary); color:white; border-color:var(--leonardo-secondary);}
        .toggle-button.angus.active{background:var(--angus-primary); color:black; border-color:var(--angus-secondary);}
        .toggle-button.diddy.active{background:var(--diddy-primary); color:white; border-color:var(--diddy-secondary);}
        .toggle-button:hover:not(.active){border-color: rgba(255,255,255,0.2);}

        .exit-icon-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(229, 62, 62, 0.8);
            border: 2px solid var(--danger);
            color: var(--line);
            font-size: 1.8rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.15s ease-in-out, background 0.15s ease-in-out, border-color 0.15s ease-in-out, color 0.15s ease-in-out;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .exit-icon-button:hover {
            background: var(--danger);
            color: white;
            transform: scale(1.05);
        }

        .exit-icon-button:active {
            transform: scale(0.95);
        }

        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 32, 44, 0.95);
            border: 2px solid var(--danger);
            border-radius: 8px;
            padding: 12px 20px;
            color: var(--line);
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
            backdrop-filter: blur(8px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        
        .awakening-bar {
            position: fixed; 
            left: 50%;
            bottom: 10px; 
            transform: translateX(-50%);
            width: 60%; 
            height: 25px; 
            border-radius: 12px;
            background: linear-gradient(45deg, #1a202c, #2d3748);
            border: 2px solid rgba(0, 255, 255, 0.5);
            overflow: visible; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
            display: block;
            z-index: 10;
        }

        .awakening-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1rem;
            color: white; 
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 11;
        }

        .awakening-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ffff, #0080ff);
            border-radius: 8px;
            transition: width 0.3s ease-out;
            box-shadow: 0 0 6px rgba(0, 255, 255, 0.6);
        }

        .awakening-bar.full .awakening-fill {
            animation: pulseAwakeningGlow 1.5s ease-in-out infinite;
        }

        
        .awakened-movesbar {
            position: absolute;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            border: 2px solid rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            z-index: 10;
        }

        .awakened-slot {
            position: relative;
            width: 70px;
            height: 50px;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 100, 255, 0.1));
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(0, 255, 255, 0.9);
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .awakened-slot:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 100, 255, 0.2));
            border-color: rgba(0, 255, 255, 0.8);
            transform: translateY(-2px);
        }

        .awakened-slot .label {
            text-align: center;
            font-size: 0.7rem;
        }

        .awakened-slot .key {
            display: block;
            font-size: 1rem;
            font-weight: bold;
            color: rgba(0, 255, 255, 1);
        }

        .awakened-slot .name {
            display: block;
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 2px;
        }

        @keyframes pulseAwakeningGlow {
            0% { box-shadow: 0 0 6px rgba(0, 255, 255, 0.6); }
            50% { box-shadow: 0 0 15px rgba(0, 255, 255, 1), 0 0 25px rgba(0, 255, 255, 0.8); }
            100% { box-shadow: 0 0 6px rgba(34, 197, 94, 0.6); }
        }

        .awakening-label {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--eddie-awakening-fill);
            text-shadow: 0 0 4px rgba(34, 197, 94, 0.8);
            opacity: 0.9;
        }

        .notification.show {
            opacity: 1;
            visibility: visible;
        }

        .notification.success {
            border-color: var(--accent);
            background: rgba(72, 187, 120, 0.15);
        }

        .notification.warning {
            border-color: var(--accent2);
            background: rgba(246, 173, 85, 0.15);
        }

        @keyframes popIn{
            0%{transform:scale(0.9); opacity:0;}
            100%{transform:scale(1); opacity:1;}
        }
       
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
            20%, 40%, 60%, 80% { transform: translateX(2px); }
        }

        @keyframes shrekGlow {
            0% {
                filter: brightness(1.2) contrast(1.3) saturate(1.5) drop-shadow(0 0 20px rgba(50, 205, 50, 0.8));
            }
            100% {
                filter: brightness(1.5) contrast(1.4) saturate(1.8) drop-shadow(0 0 40px rgba(50, 205, 50, 1));
            }
        }

        @keyframes chillGuyFloat {
            0% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
                filter: drop-shadow(0 0 20px rgba(255,255,255,0.8));
            }
            100% {
                transform: translate(-50%, -50%) scale(1.05) rotate(2deg);
                filter: drop-shadow(0 0 30px rgba(100,200,255,0.9));
            }
        }

        @keyframes superKickCharge {
            0% {
                transform: translate(-50%, -50%) scale(1);
                filter: brightness(1.5) contrast(1.4) drop-shadow(0 0 30px rgba(255,215,0,0.8));
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                filter: brightness(2) contrast(1.6) drop-shadow(0 0 60px rgba(255,215,0,1));
            }
            100% {
                transform: translate(-50%, -50%) scale(1.1);
                filter: brightness(1.8) contrast(1.5) drop-shadow(0 0 45px rgba(255,215,0,0.9));
            }
        }

        @keyframes megaShake {
            0%, 100% { transform: translateX(0) translateY(0); }
            5% { transform: translateX(-5px) translateY(-3px); }
            10% { transform: translateX(5px) translateY(3px); }
            15% { transform: translateX(-8px) translateY(-5px); }
            20% { transform: translateX(8px) translateY(5px); }
            25% { transform: translateX(-6px) translateY(-2px); }
            30% { transform: translateX(6px) translateY(2px); }
            35% { transform: translateX(-4px) translateY(-4px); }
            40% { transform: translateX(4px) translateY(4px); }
            45% { transform: translateX(-7px) translateY(-1px); }
            50% { transform: translateX(7px) translateY(1px); }
            55% { transform: translateX(-3px) translateY(-6px); }
            60% { transform: translateX(3px) translateY(6px); }
            65% { transform: translateX(-5px) translateY(-3px); }
            70% { transform: translateX(5px) translateY(3px); }
            75% { transform: translateX(-2px) translateY(-2px); }
            80% { transform: translateX(2px) translateY(2px); }
            85% { transform: translateX(-4px) translateY(-1px); }
            90% { transform: translateX(4px) translateY(1px); }
            95% { transform: translateX(-1px) translateY(-1px); }
        }

        #tutorial-modal .modal-content {
            height: 60vh;
            overflow-y: auto;
            max-height: 80vh;
            width: 500px;
            padding-right: 20px;
        }
    </style>
</head>
<body>

    <div id="main-menu" class="screen active main-menu">
        <h1>mini Football!!!!!!</h1>
        <p style="color: white; font-size: 1rem; margin: 10px 0; text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 20px rgba(255,255,255,0.6), 0 0 30px rgba(255,255,255,0.4); text-align: center;">I quit bro unless i get motivation</p>
        <p style="color: red; font-size: 0.95rem; margin: 10px 0; text-shadow: 0 0 10px rgba(255,0,0,0.8), 0 0 20px rgba(255,0,0,0.6), 0 0 30px rgba(255,0,0,0.4); text-align: right; padding-right: 20px;">You know what guys i quit making this website i added too much i quit</p>
        <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 15px;">
            <button class="menu-button horizontal" id="play-btn">play</button>
            <button class="menu-button horizontal" id="level-boost-btn">add 15 levels SAN ONLY</button>
            <button class="menu-button horizontal level-reset" id="level-reset-btn">reset level</button>
        </div>
        <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 15px;">
            <button class="menu-button horizontal" id="tutorial-btn">tutorial</button>
            <button class="menu-button horizontal" id="styles-btn">styles</button>
            <button class="menu-button horizontal" id="credits-btn">credits</button>
        </div>
    </div>

    <div id="game-screen" class="screen game-screen">
        <button class="exit-icon-button" id="exit-game-btn">&times;</button>
        <div id="notification" class="notification"></div>
        <div class="wrap">
            <canvas id="game" width="960" height="560"></canvas>
            <div class="level-container">
                <div class="level-text">LEVEL <span id="level-number">1</span></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="level-progress"></div>
                </div>
                <div class="level-goals">GOALS: <span id="goals-progress">0</span>/<span id="goals-needed">2</span></div>
            </div>
            <!-- Scoreboards -->
            <div class="scoreboard scoreboard-left">
                <div class="scoreboard-title">YOU</div>
                <div class="scoreboard-score" id="score-left">0</div>
            </div>
            <div class="scoreboard scoreboard-right">
                <div class="scoreboard-title">AI</div>
                <div class="scoreboard-score" id="score-right">0</div>
            </div>
            <div class="hud">
                <div class="card">
                    <div class="title">mini football<span class="badge">wasd to move mouse to aim click to shoot</span></div>
                    <div class="row small" style="margin-top:6px">
                        <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span style="opacity:.6">D</span>
                        <span style="opacity:.6">move</span>
                        <span class="kbd">Click</span> <span style="opacity:.6">shoot</span>
                        <span style="opacity:.6">hold auto shoot @ 3s</span>
                        <span style="opacity:.6">c hudson impact (need ball)</span>
                    </div>
                </div>
            </div>
            <div class="powerbar" id="powerbar" aria-hidden="true"><div class="fill" id="powerfill"></div></div>

            <!-- Baby Oil Guy Subtitles System -->
            <div id="baby-oil-guy-subtitles" style="position: absolute; top: 30px; left: 50%; transform: translateX(-50%); background: black; color: white; padding: 12px 24px; border-radius: 8px; font-size: 1.6rem; font-family: 'Nunito', sans-serif; font-weight: 900; text-align: center; z-index: 1000; display: none; min-width: 400px; border: 2px solid #3b82f6; box-shadow: 0 0 20px rgba(59, 130, 246, 0.5), 0 0 40px rgba(59, 130, 246, 0.3);">
                <span id="subtitle-text"></span>
            </div>
        </div>
        <div class="movesbar">
            <div id="slotC" class="slot" aria-label="Special Ability C">
                <div class="ready"></div>
                <div class="pulse"></div>
                <div class="cool" id="coolC"></div>
                <div class="label">
                    <span class="key">C</span>
                    <span class="name" id="ability-name-C">Hudson Impact</span>
                    <span class="coolText" id="coolCText"></span>
                </div>
            </div>
            <div id="slotV" class="slot" aria-label="Special Ability V">
                <div class="ready"></div>
                <div class="pulse"></div>
                <div class="cool" id="coolV"></div>
                <div class="label">
                    <span class="key">V</span>
                    <span class="name" id="ability-name-V">Eclipse Grasp</span>
                    <span class="coolText" id="coolVText"></span>
                </div>
            </div>
            <div id="slotX" class="slot" aria-label="Special Ability X">
                <div class="ready"></div>
                <div class="pulse"></div>
                <div class="cool" id="coolX"></div>
                <div class="label">
                    <span class="key">X</span>
                    <span class="name" id="ability-name-X">Void Dash</span>
                    <span class="coolText" id="coolXText"></span>
                </div>
            </div>
            <div id="slotB" class="slot" aria-label="Special Ability B" style="display: none;">
                <div class="ready"></div>
                <div class="pulse"></div>
                <div class="cool" id="coolB"></div>
                <div class="label">
                    <span class="key">B</span>
                    <span class="name" id="ability-name-B">Pookie Power</span>
                    <span class="coolText" id="coolBText"></span>
                </div>
            </div>
        </div>
        <!-- Universal Awakening Bar -->
        <div id="awakening-bar" class="awakening-bar">
            <div class="awakening-label" id="awakening-label">G - Awakening: 0%</div>
            <div id="awakening-fill" class="awakening-fill"></div>
        </div>
        
        <!-- Awakened Moves Bar (shown during awakening) -->
        <div id="awakened-movesbar" class="awakened-movesbar" style="display: none;">
            <div id="awakened-slotC" class="awakened-slot" aria-label="Awakened Ability C">
                <div class="ready"></div>
                <div class="cool" id="awakened-coolC"></div>
                <div class="label">
                    <span class="key">C</span>
                    <span class="name" id="awakened-ability-name-C">Last Fear</span>
                    <span class="coolText" id="awakened-coolCText"></span>
                </div>
            </div>
            <div id="awakened-slotV" class="awakened-slot" aria-label="Awakened Ability V">
                <div class="ready"></div>
                <div class="cool" id="awakened-coolV"></div>
                <div class="label">
                    <span class="key">V</span>
                    <span class="name" id="awakened-ability-name-V">Eyes Closed</span>
                    <span class="coolText" id="awakened-coolVText"></span>
                </div>
            </div>
            <div id="awakened-slotX" class="awakened-slot" aria-label="Awakened Ability X">
                <div class="ready"></div>
                <div class="cool" id="awakened-coolX"></div>
                <div class="label">
                    <span class="key">X</span>
                    <span class="name" id="awakened-ability-name-X">Part of my Desire</span>
                    <span class="coolText" id="awakened-coolXText"></span>
                </div>
            </div>
        </div>
    </div>

    <div id="credits-modal" class="modal-backdrop">
        <div class="modal-content">
            <button class="close-button" id="close-credits">&times;</button>
            <h2>credits</h2>
            <p>this game was diddiled by san, on a more serious note this game will continue getting new updates and i take my time making these typa stuff..</p>
            <p style="margin-top:12px;">everything wa made by me except the images, but i made the ball, player, and the field. i scripted it all, Frooty24 on youtube helped me with some of the style designs, like gojo, XDrake, etc he also makes the images. well not the ball or the player or the field </p>
        </div>
    </div>

    <div id="styles-modal" class="modal-backdrop">
        <div class="modal-content">
            <button class="close-button" id="close-styles">&times;</button>
            <h2>styles</h2>
            <div class="toggle-container">
                <div class="toggle-group">
                    <button class="toggle-button" id="style-none">none</button>
                    <button class="toggle-button" id="style-gojo">satoru gojo</button>
                    <button class="toggle-button" id="style-hudson">hudson</button>
                    <button class="toggle-button" id="style-robsan">robsan</button>
                    <button class="toggle-button" id="style-xdrake">xdrake</button>
                    <button class="toggle-button" id="style-eddie">eddie</button>
                    <button class="toggle-button" id="style-zeus">zeus</button>
                    <button class="toggle-button" id="style-ignis">ignis</button>
                    <button class="toggle-button" id="style-asher">asher</button> <!-- NEW ASHER BUTTON -->
                    <button class="toggle-button" id="style-leonardo">leonardo</button>
                    <button class="toggle-button" id="style-angus">angus</button>
                    <button class="toggle-button" id="style-diddy">baby oil guy</button>
                    <button class="toggle-button" id="style-cristiano">cristiano</button>
                    <button class="toggle-button" id="style-saja-jin">saja-jin</button>
                    <button class="toggle-button" id="style-lincoln" style="opacity: 0.5; cursor: not-allowed;" title="Requires Level 15">lincoln (lvl 15)</button>
                    <button class="toggle-button" id="style-abby">abby saja</button>
                    <button class="toggle-button" id="style-korbin">korbin</button>
                    <button class="toggle-button" id="style-67kid">67 kid</button>
                    <button class="toggle-button" id="style-wally" style="opacity: 0.5; cursor: not-allowed;" title="Requires Level 50">wally (lvl 50)</button>
                    <button class="toggle-button" id="style-rabies">rabies</button>
                </div>
            </div>
        </div>
    </div>

    <div id="tutorial-modal" class="modal-backdrop">
        <div class="modal-content">
            <button class="close-button" id="close-tutorial">&times;</button>
            <h2>how to play mini Football</h2>
            <p>welcome to mini FootBall heres a quick guide to get you started</p>
            <h3>objective</h3>
            <p>the goal is simple control your player get the ball and shoot it into the opponents goal</p>
            <h3>controls</h3>
            <ul>
                <li>movement use the <span class="kbd">W</span> <span class="kbd">A</span> <span class="kbd">S</span> <span class="kbd">D</span> keys to move your player around the field your player has some momentum so anticipate your movements</li>
                <li>aiming move your <span class="kbd">mouse</span> to aim where you want to kick the ball</li>
                <li>shooting
                    <ul>
                        <li><span class="kbd">Click</span> and release the mouse button to shoot the longer you hold it the more powerful your shot will be</li>
                        <li><span class="kbd">Hold</span> the mouse button for 3 seconds and your player will automatically unleash a powerful shot</li>
                    </ul>
                </li>
            </ul>
            <h3>special abilities</h3>
            <p>depending on your chosen style youll have unique special abilities</p>
            <ul>
                <li>Hudson Impact (Hudson Style) press the <span class="kbd">C</span> key when you have possession of the ball to launch it with incredible speed and visual effects</li>
                <li>Robsan Style
                    <ul>
                        <li>Shadow Spiral press the <span class="kbd">C</span> key with the ball to perform a spinning dark aura move for 2 seconds followed by a 2-second charge then a powerful shadowy shot</li>
                        <li>Eclipse Grasp press the <span class="kbd">V</span> key when you do not have the ball your player will emit a dark aura for 02 seconds then a wiggly black line will draw the ball directly to you in 05 seconds no matter its distance</li>
                        <li>Void Dash press the <span class="kbd">X</span> key to instantly dash a short distance in the direction of your mouse cursor can be used with or without the ball for quick repositioning</li>
                    </ul>
                </li>
                <li>XDRAKE Style
                    <ul>
                        <li>Supernova press the <span class="kbd">C</span> key to instantly dash a medium distance in the direction of your mouse cursor your player will turn green and leave a bright green trail no ball required</li>
                        <li>Fossilised Footwork press the <span class="kbd">V</span> key when you have the ball perform a quick short forward burst with earthy visual effects and a unique trail</li>
                        <li>Ancient Apex press the <span class="kbd">X</span> key when you have the ball your player glows green and unleashes an extremely powerful shot with a fierce green aura</li>
                    </ul>
                </li>
                <li>Satoru Gojo Style harness cursed energy for devastating effects
                    <ul>
                        <li>Red press the <span class="kbd">C</span> key when you have the ball after a short charge the ball turns vibrant red and is launched with immense power</li>
                        <li>Lapse Blue press the <span class="kbd">V</span> key when you do not have the ball a large blue cursed energy ball appears and orbits you rapidly if it touches the main soccer ball you instantly gain possession</li>
                        <li>Purple press the <span class="kbd">X</span> key when you have the ball two powerful cursed energy spheres red and blue are launched outwards for 15 seconds then converge in the middle to create a massive 'Purple' attack unleashing the most powerful shot imaginable towards your cursor</li>
                    </ul>
                </li>
                <li>Eddie Style:
                    <ul>
                        <li>We Are: press the <span class="kbd">C</span> key to turn black for 10 seconds and gain increased speed</li>
                        <li>Venom Strike: press the <span class="kbd">V</span> key when you **do not have the ball** to instantly grab it from a large range and immediately shoot with all your might (extremely fast retrieval, with a powerful tendril aura)</li>
                        <li>Symbiote Montage: press the <span class="kbd">X</span> key when you **have the ball** to rapidly teleport to 3 random locations on the field, leaving black puddles behind. After the third teleport, you'll instantly appear in the center of the field with the ball. You'll then have 1 second to aim with your cursor before automatically unleashing a powerful shot.</li>
                    </ul>
                </li>
                <li>Zeus Style:
                    <ul>
                        <li>Lightning Bolt: Press the <span class="kbd">C</span> key when you have the ball to charge and unleash a super-fast, precise shot with an electrifying trail.</li>
                        <li>Heavenly Shield: Press the <span class="kbd">V</span> key to activate a protective aura around you for 1.5 seconds. Any soccer ball entering this aura will have its velocity significantly reduced, making it easier to gain possession.</li>
                        <li>Olympus' Fury: Press the <span class="kbd">X</span> key to generate a powerful pull that draws the ball directly to you for 3 seconds (if you don't have it). Once you have possession, you'll have 1.5 seconds to aim before unleashing an ultra-powerful, arcing lightning shot.</li>
                    </ul>
                </li>
                <li>Ignis Style:
                    <ul>
                        <li>Fire Breath: Press the <span class="kbd">C</span> key to unleash a cone of fire in your facing direction. Hold click to extend range, press <span class="kbd">Space</span> to cancel. Lasts 5 seconds, stuns AI if touched, and claims the ball if fire reaches it.</li>
                        <li>Blaze Dash: Press the <span class="kbd">V</span> key for a rapid, high-speed dash that leaves a trail of fire and applies knockback to the ball, pushing it away from your path.</li>
                        <li>Phoenix Burst: Press the <span class="kbd">X</span> key when you have the ball to charge up and release a massive explosion of fire that sends the ball flying with immense force toward your cursor.</li>
                    </ul>
                </li>
                <li>Asher Style:
                    <ul>
                        <li>Starfall Shot: Press the <span class="kbd">C</span> key when you have the ball to launch a shot that automatically homes in on the opponent's goal, leaving a starry trail.</li>
                        <li>Celestial Pull: Press the <span class="kbd">V</span> key when you do not have the ball to instantly teleport it to your position with a burst of light.</li>
                    </ul>
                </li>
                <li>all abilities have a cooldown period use them strategically</li>
            </ul>
            <h3>game interface</h3>
            <ul>
                <li>power bar located at the top of the screen this shows you the power of your shot when youre charging it</li>
                <li>moves bar at the bottom this bar displays the cooldown status and name of your active special abilityies watch for the ready indicator</li>
            </ul>
            <p>have fun and enjoy the game</p>
        </div>
    </div>

    <div id="ai-modal" class="modal-backdrop">
        <div class="modal-content">
            <button class="close-button" id="close-ai">&times;</button>
            <h2>Choose Game Mode</h2>
            <p>Select how you want to play</p>
            <div class="toggle-container">
                <div class="toggle-group" style="flex-direction: column; gap: 15px;">
                    <button class="menu-button" id="play-with-ai" style="width: 100%;">Play with AI</button>
                    <button class="menu-button" id="play-without-ai" style="width: 100%;">Play without AI Reccomended.</button>
                </div>
            </div>
        </div>
    </div>

    <div id="level-boost-modal" class="modal-backdrop">
        <div class="modal-content">
            <button class="close-button" id="close-level-boost">&times;</button>
            <h2>Level Boost</h2>
            <p>Enter the secret code to get 15 levels:</p>
            <input type="text" id="level-boost-code" placeholder="Enter code..." style="width: 100%; padding: 10px; margin: 10px 0; font-size: 16px; text-align: center; border: 2px solid #ddd; border-radius: 5px;">
            <button class="menu-button" id="submit-level-boost" style="width: 100%; margin-top: 10px;">Submit</button>
        </div>
    </div>

    <script>
        

        function TrySubtitle(text, callback) {
            const subtitleEl = document.getElementById('baby-oil-guy-subtitles');
            const textEl = document.getElementById('subtitle-text');

            subtitleEl.style.display = 'block';
            textEl.textContent = '';

            let charIndex = 0;
            const typeInterval = setInterval(() => {
                if (charIndex < text.length) {
                    textEl.textContent += text[charIndex];
                    charIndex++;
                } else {
                    clearInterval(typeInterval);
                    setTimeout(() => {
                        subtitleEl.style.display = 'none';
                        if (callback) callback();
                    }, 1000);
                }
            }, 50);
        }

        function Trycaption(text, style = 'Fade', callback) {
            const subtitleEl = document.getElementById('baby-oil-guy-subtitles');
            const textEl = document.getElementById('subtitle-text');

            subtitleEl.style.animation = '';
            subtitleEl.style.display = 'block';
            textEl.textContent = text;

            switch(style.toLowerCase()) {
                case 'fade':
                    subtitleEl.style.animation = 'captionFade 0.5s ease-in-out';
                    break;
                case 'slidefromtop':
                    subtitleEl.style.animation = 'captionSlideFromTop 0.6s ease-out';
                    break;
                case 'slidefrombottom':
                    subtitleEl.style.animation = 'captionSlideFromBottom 0.6s ease-out';
                    break;
                case 'slidefromleft':
                    subtitleEl.style.animation = 'captionSlideFromLeft 0.6s ease-out';
                    break;
                case 'slidefromright':
                    subtitleEl.style.animation = 'captionSlideFromRight 0.6s ease-out';
                    break;
                case 'bounce':
                    subtitleEl.style.animation = 'captionBounce 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                    break;
                case 'zoom':
                    subtitleEl.style.animation = 'captionZoom 0.5s ease-out';
                    break;
                case 'typewriter':
                    textEl.textContent = '';
                    subtitleEl.style.animation = 'captionFade 0.3s ease-in-out';
                    let charIndex = 0;
                    const typeInterval = setInterval(() => {
                        if (charIndex < text.length) {
                            textEl.textContent += text[charIndex];
                            charIndex++;
                        } else {
                            clearInterval(typeInterval);
                        }
                    }, 40);
                    break;
                default:
                    subtitleEl.style.animation = 'captionFade 0.5s ease-in-out';
            }

            setTimeout(() => {
                subtitleEl.style.animation = 'captionFadeOut 0.5s ease-in-out';
                setTimeout(() => {
                    subtitleEl.style.display = 'none';
                    if (callback) callback();
                }, 500);
            }, 2500);
        }

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;

        // Load PFP Images for Pookie Power
        const pookieImages = {};
        pookieImages.lumi = new Image();
        pookieImages.lumi.src = 'lumi.png';
        pookieImages.muichiro = new Image();
        pookieImages.muichiro.src = 'muichiro.png';
        pookieImages.seal = new Image();
        pookieImages.seal.src = 'seal.png';

        const pookieImageList = [pookieImages.lumi, pookieImages.muichiro, pookieImages.seal];

        const oilImage = new Image();
        let oilImageLoaded = false;
        oilImage.onload = function() {
            oilImageLoaded = true;
            console.log('Oil image loaded successfully!');
        };
        oilImage.onerror = function() {
            console.warn('Failed to load oil.png, using fallback effects');
        };
        oilImage.src = 'oil.png';

        let gameState = 'menu';
        let isPlaying = false;
        let currentStyle = 'hudson';
        let aiEnabled = false;

        const mainMenuScreen = document.getElementById('main-menu');
        const gameScreen = document.getElementById('game-screen');
        const playBtn = document.getElementById('play-btn');
        const tutorialBtn = document.getElementById('tutorial-btn');
        const stylesBtn = document.getElementById('styles-btn');
        const creditsBtn = document.getElementById('credits-btn');
        const levelBoostBtn = document.getElementById('level-boost-btn');
        const levelResetBtn = document.getElementById('level-reset-btn');
        const exitBtn = document.getElementById('exit-game-btn');

        const creditsModal = document.getElementById('credits-modal');
        const closeCreditsBtn = document.getElementById('close-credits');
        const stylesModal = document.getElementById('styles-modal');
        const closeStylesBtn = document.getElementById('close-styles');
        const tutorialModal = document.getElementById('tutorial-modal');
        const closeTutorialBtn = document.getElementById('close-tutorial');
        const aiModal = document.getElementById('ai-modal');
        const closeAiBtn = document.getElementById('close-ai');
        const playWithAiBtn = document.getElementById('play-with-ai');
        const playWithoutAiBtn = document.getElementById('play-without-ai');
       
        const levelBoostModal = document.getElementById('level-boost-modal');
        const closeLevelBoostBtn = document.getElementById('close-level-boost');
        const levelBoostCodeInput = document.getElementById('level-boost-code');
        const submitLevelBoostBtn = document.getElementById('submit-level-boost');

        const styleNoneBtn = document.getElementById('style-none');
        const styleHudsonBtn = document.getElementById('style-hudson');
        const styleRobsanBtn = document.getElementById('style-robsan');
        const styleXDrakeBtn = document.getElementById('style-xdrake');
        const styleGojoBtn = document.getElementById('style-gojo');
        const styleEddieBtn = document.getElementById('style-eddie');
        const styleZeusBtn = document.getElementById('style-zeus');
        const styleIgnisBtn = document.getElementById('style-ignis');
        const styleAsherBtn = document.getElementById('style-asher');
        const styleLeonardoBtn = document.getElementById('style-leonardo');
        const styleAngusBtn = document.getElementById('style-angus');
        const styleDiddyBtn = document.getElementById('style-diddy');
        const styleCristianoBtn = document.getElementById('style-cristiano');
        const styleSajaJinBtn = document.getElementById('style-saja-jin');
        const styleLincolnBtn = document.getElementById('style-lincoln');
        const styleAbbyBtn = document.getElementById('style-abby');
        const styleKorbinBtn = document.getElementById('style-korbin');
        const style67KidBtn = document.getElementById('style-67kid');
        const styleWallyBtn = document.getElementById('style-wally');
        const styleRabiesBtn = document.getElementById('style-rabies');

        const slotC = document.getElementById('slotC');
        const abilityNameCEl = document.getElementById('ability-name-C');
        const slotV = document.getElementById('slotV');
        const abilityNameVEl = document.getElementById('ability-name-V');
        const slotX = document.getElementById('slotX');
        const slotB = document.getElementById('slotB');
        const abilityNameXEl = document.getElementById('ability-name-X');
        const abilityNameBEl = document.getElementById('ability-name-B');

        const awakeningBar = document.getElementById('awakening-bar');
        const awakeningFill = document.getElementById('awakening-fill');

        const margin = 40;
        const goalW = 140, goalDepth = 18;

        const player = {
            x:W*0.25, y:H*0.5, r:18, speed:0, vx:0, vy:0, maxSpd:3.2, accel:0.6, drag:0.85, hasBall:false,
lastStealTime: 0, stealCooldown: 2000,
            spinning:false, spinTimer:0, charging:false, chargeTimer:0, telekinising:false,
            dashing:false, dashTimer:0,
            xdrakeSupernovaDashing: false, xdrakeSupernovaDashTimer: 0,
            xdrakeFossilFootworking: false, xdrakeFossilFootworkTimer: 0,
            xdrakeAncientApexCharging: false, xdrakeAncientApexChargeTimer: 0,

            gojoRedCharging: false,
            gojoRedChargeStartTime: 0,
            gojoRedActive: false,
            gojoLapseBlueActive: false,
            gojoLapseBlueBall: null,
            gojoPurpleActive: false,
            gojoPurpleConverging: false,
            gojoPurpleConvergenceStartTime: 0,
            gojoPurpleLeftBall: null,
            gojoPurpleRightBall: null,
            gojoPurpleInitialDir: 0,
            gojoPurpleShotFired: false,

            eddieWeAreActive: false,
            eddieWeAreOriginalMaxSpd: 3.2,
            eddieWeAreEndTime: 0,
            eddieVenomStrikeActive: false,
            eddieVenomStrikeEndTime: 0,
            eddieSymbioteMontageActive: false,
            eddieSymbioteMontagePhase: '',
            eddieSymbioteMontageTeleportCount: 0,
            eddieSymbioteMontageCurrentTeleportTarget: {x:0, y:0},
            eddieSymbioteMontageTeleportStartTime: 0,
            eddieSymbioteMontageTeleportEndTime: 0,
            eddieSymbioteMontageStartPlayerPos: {x:0, y:0},
            eddieSymbioteMontageAimStartTime: 0,
            eddieSymbioteMontageShotFired: false,
            eddieAwakeningProgress: 0,
            eddieAwakeningActive: false,
            eddieAwakeningEndTime: 0,
            eddieAwakeningVideoPlaying: false,
            
            awakeningProgress: 0,
            awakeningActive: false,
            awakeningEndTime: 0,
            awakeningEyesActive: false,
            awakeningAuraActive: false,
            
            lastFearActive: false,
            lastFearEndTime: 0,
            partOfMyDesireActive: false,
            partOfMyDesireEndTime: 0,
            partOfMyDesireOriginalMaxSpd: 3.2,

            zeusLightningCharging: false,
            zeusLightningChargeStartTime: 0,
            zeusLightningActive: false,
            zeusHeavenlyShieldActive: false,
            zeusHeavenlyShieldEndTime: 0,
            zeusHeavenlyShieldRadius: 0,
            zeusOlympusFuryActive: false,
            zeusOlympusFuryPhase: '',
            zeusOlympusFuryPullStartTime: 0,
            zeusOlympusFuryAimStartTime: 0,
            zeusOlympusFuryShotFired: false,
            zeusOlympusFuryOrigHasBall: false,
            asherAutoGoalActive: false,
            asherStarfallCharging: false,
            asherStarfallChargeStartTime: 0,
            leonardoFocusShotActive: false,
            leonardoShieldActive: false,
            leonardoShieldEndTime: 0,
            leonardoDashing: false,
            leonardoDashTimer: 0,
            leonardoDashEndX: 0,
            leonardoDashEndY: 0,
            angusCharging: false,
            angusChargeStartTime: 0,
            angusBurstUsesLeft: 3,
            angusTimeStopActive: false,
            angusTimeStopEndTime: 0,
            angusTeleportActive: false,
            diddyBabyOilActive: false,
            diddyBabyOilPhase: '',
            diddyBabyOilStartTime: 0,
            diddySlickShotActive: false,
            diddyOilSlickActive: false,
            diddyOilSlickEndTime: 0,
            isDribbling: false,
            dribbleEndTime: 0,
            hudsonEmperorDribbling: false,
            hudsonEmperorDribbleStartTime: 0,
            hudsonEmperorDribblePhase: '',
            hudsonEmperorDribbleStartX: 0,
            hudsonEmperorDribbleStartY: 0,
            hudsonEmperorDribbleMouseDir: 0,
            sajaJinDemonicHeroismActive: false,
            sajaJinDemonicHeroismEndTime: 0,
            sajaJinDemonicHeroismOriginalMaxSpd: 3.2,
            sajaJinSoulSuckingShotActive: false,
            sajaJinHypnoticShotActive: false,
            sajaJinHypnoticShotPhase: '',
            sajaJinHypnoticShotStartTime: 0,
            sajaJinHypnoticShotSpinAngle: 0,
            sajaJinHypnoticShotPlayerCenterX: 0,
            sajaJinHypnoticShotPlayerCenterY: 0
            ,sajaJinHypnoticLockUntil: 0,
            lincolnShrekMoveActive: false,
            lincolnShrekMovePhase: '',
            lincolnShrekMoveStartTime: 0,
           
            lincolnKissMoveActive: false,
            lincolnKissMovePhase: '',
            lincolnKissMoveStartTime: 0,
            lincolnKissBallDirection: 1,
            
            lincolnGyattShowdownActive: false,
            lincolnGyattShowdownEndTime: 0,
            lincolnGyattShowdownOriginalMaxSpd: 3.2,
            
            wallyRocketBoostActive: false,
            wallyRocketBoostEndTime: 0,
            wallySpeedForceActive: false,
            wallySpeedForceEndTime: 0,
            wallySpeedForceOriginalMaxSpd: 3.2,
            wallyFlashyLightningActive: false,
            wallyFlashyLightningEndTime: 0,
            wallyFlashyLightningOriginalMaxSpd: 3.2,
            
            korbinBigBackPowerActive: false,
            korbinBigBackPowerEndTime: 0,
            korbinBigBackPowerDirection: { x: 0, y: 0 },
            korbinBigBackPowerOriginalMaxSpd: 3.2,
            korbinBigBackPowerStunned: false,
            
            rabiesPookiePowerActive: false,
            rabiesPookiePowerEndTime: 0
                };

        const ball = {
            x:W*0.5, y:H*0.5, r:10, vx:0, vy:0, friction:0.988, maxSpeed:Infinity,
            bounceDamping: 0.75,
            isHoming: false,
            homingTargetX: 0,
            homingTargetY: 0,
            homingEndTime: 0,
        };

        const aiPlayer = {
            x: W*0.75, y: H*0.5, r: 18, speed: 0, vx: 0, vy: 0, maxSpd: 2.8, accel: 0.5, drag: 0.85, hasBall: false,
            targetX: 0, targetY: 0,
            lastThinkTime: 0,
            thinkInterval: 100,
            state: 'chase',
            shootPower: 0,
            shootCharging: false,
            shootStartTime: 0,
            lastShotTime: 0,
            shotCooldown: 1000,
            defensiveX: W*0.8,
            skill: 0.8,
            isDribbling: false,
            isStunned: false,
            stunEndTime: 0,
            ballPickupAttemptTime: 0,
            lastBallPickupAttempt: 0,
            lastStealAttempt: 0,
            stealCooldown: 0,
        };

        const keys = {};
        let mouse = {x:W/2, y:H/2, down:false};

        let chargeStart = 0; let autoShotFired = false; let autoTimer = null;
        const powerBar = document.getElementById('powerbar');
        const powerFill = document.getElementById('powerfill');
        const AUTO_MS = 2500;

        const ABILITY_COOLDOWN = 5500;
        const ROBSAN_SPIN_DURATION = 2000;
        const ROBSAN_CHARGE_DURATION = 2000;
        const ECLIPSE_AURA_DURATION = 200;
        const ECLIPSE_RETRIEVAL_DURATION = 500;
        const VOID_DASH_DURATION = 200;
        const VOID_DASH_SPEED = 25;

        const XDRAKE_SUPERNOVA_DASH_DURATION = 250;
        const XDRAKE_SUPERNOVA_DASH_SPEED = 30;
        const XDRAKE_FOSSIL_FOOTWORK_DURATION = 150;
        const XDRAKE_FOSSIL_FOOTWORK_SPEED = 18;
        const XDRAKE_ANCIENT_APEX_CHARGE_DURATION = 1000;
        const XDRAKE_ANCIENT_APEX_SHOT_POWER = 32;

        const GOJO_RED_CHARGE_DURATION = 500;
        const GOJO_RED_SHOT_POWER = 28;
        const GOJO_LAPSE_BLUE_BALL_RADIUS = ball.r * 3;
        const GOJO_LAPSE_BLUE_ORBIT_RADIUS = player.r * 4;
        const GOJO_LAPSE_BLUE_ORBIT_SPEED = 10;
        const GOJO_PURPLE_SPREAD_DISTANCE = 100;
        const GOJO_PURPLE_CONVERGE_DURATION = 1500;
        const GOJO_PURPLE_FINAL_SHOT_POWER = 40;
        const GOJO_PURPLE_SHOCKWAVE_DURATION = 200;
        let gojoPurpleShockwaveEndTime = 0;

        const EDDIE_WE_ARE_DURATION = 10000;
        const EDDIE_WE_ARE_SPEED_BOOST = 2;
        const EDDIE_VENOM_STRIKE_PULL_SPEED = 300;
        const EDDIE_VENOM_STRIKE_SHOT_POWER = 35;
        const EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION = 1000;
        const EDDIE_SYMBIOTE_MONTAGE_SHOT_POWER = 25;
        const EDDIE_SYMBIOTE_MONTAGE_TELEPORT_SPEED = 100;
        const PUDDLE_DURATION = 1500;

        const ZEUS_LIGHTNING_CHARGE_DURATION = 300;
        const ZEUS_LIGHTNING_SHOT_POWER = 28;
        const ZEUS_HEAVENLY_SHIELD_DURATION = 1500;
        const ZEUS_HEAVENLY_SHIELD_RADIUS = player.r * 3.5;
        const ZEUS_OLYMPUS_FURY_PULL_DURATION = 3000;
        const ZEUS_OLYMPUS_FURY_AIM_DURATION = 1500;
        const ZEUS_OLYMPUS_FURY_SHOT_POWER = 45;

        const IGNIS_FIRE_BREATH_DURATION = 10000;
        const IGNIS_FIRE_BREATH_CONE_ANGLE = Math.PI / 2;
        const IGNIS_FIRE_BREATH_BASE_RANGE = 120;
        const IGNIS_FIRE_BREATH_EXTENDED_RANGE = 180;
        const IGNIS_FIRE_BREATH_STUN_DURATION = 5000;
        const IGNIS_BLAZE_DASH_DURATION = 1000;
        const IGNIS_BLAZE_DASH_SPEED = 100000;
        const IGNIS_BLAZE_DASH_KNOCKBACK_FORCE = 15;
        const IGNIS_PHOENIX_BURST_CHARGE_DURATION = 300;
        const IGNIS_PHOENIX_BURST_EXPLOSION_RADIUS = 100;
        const IGNIS_PHOENIX_BURST_SHOT_POWER = 50;

        const ASHER_HOMING_SHOT_DURATION = 4000;
        const ASHER_HOMING_SHOT_POWER = 18;
        const ASHER_HOMING_TURN_RATE = 0.08;
        const ASHER_STARFALL_CHARGE_DURATION = 800;
        const ASHER_STARFALL_ORBIT_SPEED = 25;
        const ASHER_STARFALL_ORBIT_RADIUS = player.r + ball.r + 15;


        const LEONARDO_FOCUS_SHOT_POWER = 26;
        const LEONARDO_SHIELD_DURATION = 2500;
        const LEONARDO_SHIELD_RADIUS = player.r * 4.5;
        const LEONARDO_SHIELD_PULL_STRENGTH = 0.03;
        const LEONARDO_DASH_DURATION = 200;
        const LEONARDO_DASH_SPEED = 28;
        const LEONARDO_PATTERN_FIELD_DURATION = 1000;
        const ANGUS_CHARGE_DURATION = 2000;
        const ANGUS_BURST_POWER = 45;
        const ANGUS_TIME_STOP_DURATION = 3000;
        const ANGUS_TELEPORT_RANGE = 200;

        const DIDDY_BABY_OIL_DURATION = 4000;
        const DIDDY_SUBTITLE_DURATION = 1500;
        const DIDDY_RUN_SPEED = 35;
        const DIDDY_ASCENSION_SPEED = 25;
        const DIDDY_SLICK_SHOT_POWER = 30;
        const DIDDY_OIL_SLICK_DURATION = 5000;

        const CRISTIANO_POWER_SHOT_POWER = 35;
        const CRISTIANO_GOAT_TACKLE_RANGE = 200;
        const CRISTIANO_PORTUGUESE_SPIRIT_DURATION = 12000;
        const CRISTIANO_PORTUGUESE_SPIRIT_SPEED_MULTIPLIER = 2.2;
        const CRISTIANO_PORTUGUESE_SPIRIT_SHOT_POWER_BONUS = 25;

        const HUDSON_EMPEROR_DRIBBLE_DURATION = 800;
        const HUDSON_EMPEROR_DRIBBLE_SPEED = 20;
        const HUDSON_EMPEROR_DRIBBLE_DISTANCE = W * 0.5;

        const AWAKENING_GOALS_REQUIRED = 10;
        const AWAKENING_DURATION = 30000;
        const LAST_FEAR_DURATION = 5000;
        const PART_OF_MY_DESIRE_DURATION = 8000;
        const PART_OF_MY_DESIRE_SPEED_BOOST = 1.75;
        const PART_OF_MY_DESIRE_STRENGTH_BOOST = 1.4;

        let abilityReadyAt = 0;
        let shadowSpiralReadyAt = 0;
        let eclipseGraspReadyAt = 0;
        let voidDashReadyAt = 0;

        let supernovaReadyAt = 0;
        let fossilFootworkReadyAt = 0;
        let ancientApexReadyAt = 0;

        let gojoRedReadyAt = 0;
        let gojoLapseBlueReadyAt = 0;
        let gojoPurpleReadyAt = 0;

        let eddieWeAreReadyAt = 0;
        let eddieVenomStrikeReadyAt = 0;
        let eddieSymbioteMontageReadyAt = 0;

        let zeusLightningReadyAt = 0;
        let zeusHeavenlyShieldReadyAt = 0;
        let zeusOlympusFuryReadyAt = 0;

        let ignisFireBreathReadyAt = 0;
        let ignisBlazeDashReadyAt = 0;
        let ignisPhoenixBurstReadyAt = 0;

        let asherAutoGoalReadyAt = 0;
        let asherBallTeleportReadyAt = 0;

        let leonardoFocusShotReadyAt = 0;
        let leonardoShieldReadyAt = 0;
        let leonardoDashReadyAt = 0;
        let angusTimeStopReadyAt = 0;
        let angusTeleportReadyAt = 0;

        let diddyBabyOilReadyAt = 0;
        let diddySlickShotReadyAt = 0;
        let diddyOilSlickReadyAt = 0;

        let cristianoPowerShotReadyAt = 0;
        let cristianoGoatTackleReadyAt = 0;
        let cristianoPortugueseSpiritReadyAt = 0;

        let sajaJinDemonicHeroismReadyAt = 0;
        let sajaJinSoulSuckingShotReadyAt = 0;
        let sajaJinHypnoticShotReadyAt = 0;

        const LINCOLN_SHREK_MOVE_DURATION = 5000;
        const LINCOLN_SHREK1_DURATION = 2000;
        const LINCOLN_SHREK2_KICK_POWER = 10000;

        const LINCOLN_KISS_DURATION = 3000;
        const LINCOLN_KISS_PUDDLE_DURATION = 1500;
        const LINCOLN_KISS_BALL_MOVEMENT_DURATION = 1500;
        const LINCOLN_KISS_BALL_SPEED = 8;

        const LINCOLN_GYATT_SHOWDOWN_DURATION = 10000;
        const LINCOLN_GYATT_SHOWDOWN_SPEED_MULTIPLIER = 2;
        const LINCOLN_GYATT_SHOWDOWN_SHOT_MULTIPLIER = 5;

        let lincolnShrekMoveReadyAt = 0;
        let lincolnKissMoveReadyAt = 0;
        let lincolnGyattShowdownReadyAt = 0;
       
        let abbyColossalCalvesReadyAt = 0;
        let abbyPowerPinReadyAt = 0;
        let abbyDemonDriveReadyAt = 0;

        let korbinFieryApocalypseReadyAt = 0;
        let korbinBigBackPowerReadyAt = 0;
        let korbinBigShotReadyAt = 0;

        const KORBIN_FIERY_APOCALYPSE_COOLDOWN = 8000;
        const KORBIN_FIERY_APOCALYPSE_DAMAGE = 2.5;
        const KORBIN_FIERY_APOCALYPSE_RANGE = 150;
        const KORBIN_BIG_BACK_POWER_COOLDOWN = 15000;
        const KORBIN_BIG_BACK_POWER_SPEED = 10;
        const KORBIN_BIG_BACK_POWER_DURATION = 5000;
        const KORBIN_BIG_SHOT_COOLDOWN = 12000;
        const KORBIN_BIG_SHOT_DAMAGE = 3.0;
        const KORBIN_BIG_SHOT_WIND_DURATION = 1200;

        let wallyRocketBoostReadyAt = 0;
        let wallySpeedForceReadyAt = 0;
        let wallyFlashyLightningReadyAt = 0;

        const WALLY_ROCKET_BOOST_COOLDOWN = 6000;
        const WALLY_ROCKET_BOOST_DURATION = 400;
        const WALLY_ROCKET_BOOST_SPEED = 75;
        const WALLY_SPEED_FORCE_COOLDOWN = 10000;
        const WALLY_SPEED_FORCE_DURATION = 3000;
        const WALLY_SPEED_FORCE_RANGE = 300;
        const WALLY_SPEED_FORCE_SPEED_BOOST = 1.2;
        const WALLY_FLASHY_LIGHTNING_COOLDOWN = 12000;
        const WALLY_FLASHY_LIGHTNING_DURATION = 3500;
        const WALLY_FLASHY_LIGHTNING_SPEED_BOOST = 8.0;

        const SIXTY_SEVEN_KID_MAYHEM_COOLDOWN = 15000;
        const SIXTY_SEVEN_KID_MAYHEM_67_DISPLAY_DURATION = 1500;
        const SIXTY_SEVEN_KID_MAYHEM_BLACKOUT_DURATION = 1670;
        const SIXTY_SEVEN_KID_MAYHEM_TOTAL_FROZEN_DURATION = 1670;

        let sixtySevenKidMayhemReadyAt = 0;

        let hudsonEmperorDribbleReadyAt = 0;
const HUDSON_EMPEROR_DRIBBLE_COOLDOWN = 10000;

        // Rabies cooldowns and constants
        const RABIES_RAGEBAIT_COOLDOWN = 8000;
        const RABIES_SQUID_GLAZE_COOLDOWN = 12000;
        const RABIES_STEAL_BALLROT_COOLDOWN = 6000;
        const RABIES_POOKIE_POWER_COOLDOWN = 15000;
        
        let rabiesRagebaitReadyAt = 0;
        let rabiesSquidGlazeReadyAt = 0;
        let rabiesStealBallrotReadyAt = 0;
        let rabiesPookiePowerReadyAt = 0;

        const SAJA_JIN_DEMONIC_HEROISM_DURATION = 8000;
        const SAJA_JIN_DEMONIC_HEROISM_SPEED_BOOST = 1.4;
        const SAJA_JIN_SOUL_SUCKING_SHOT_POWER = 28;
        const SAJA_JIN_SOUL_SUCKING_TRAIL_DURATION = 800;
        const SAJA_JIN_HYPNOTIC_SHOT_SPIN_DURATION = 3500;
        const SAJA_JIN_HYPNOTIC_SHOT_SPIN_RADIUS = 70;
        const SAJA_JIN_HYPNOTIC_SHOT_SPIN_SPEED = 0.08;
        const SAJA_JIN_HYPNOTIC_SHOT_LEFT_DURATION = 1200;
        const SAJA_JIN_HYPNOTIC_SHOT_CAPTION_DURATION = 2500;
        const SAJA_JIN_HYPNOTIC_SHOT_GOAL_SPEED = 8;
        const SAJA_JIN_HYPNOTIC_SHOT_BURST_RADIUS = 150;
        const SAJA_JIN_HYPNOTIC_SHOT_SPIRAL_LAYERS = 3;

        let vfx = {
            trail:[], trails:[], sparks:[], shockwaves:[], flashes:[], lines:[],
            robsanParticles:[], robsanAura:[], shadowTrails:[], robsanChargeAura:[],
            eclipseAura:[], eclipseLines:[], voidTrails:[],
            xdrakeSupernovaTrails: [], xdrakeFootworkDust: [], xdrakeApexAura: [],

            gojoRedTrail: [],
            gojoBlueOrbitParticles: [],
            gojoPurpleCombineVFX: [],
            gojoPurpleTrail: [],

            leonardoFocusText: [],
            leonardoFocusParticles: [],
            leonardoShieldAura: [],
            leonardoShieldParticles: [],
            leonardoDashTrail: [],
            leonardoDashParticles: [],
            leonardoPatternField: [],
            leonardoFocusTrail: [],
            angusChargeParticles: [],
            angusBurstVFX: [],
            angusTimeStopField: [],
            angusTeleportTrail: [],
            diddyOilParticles: [],
            diddyAscensionVFX: [],
            diddyOilSlicks: [],
            diddySlickTrail: [],

            lincolnGyattAura: [],
            lincolnGyattParticles: [],
            lincolnGyattTrail: [],

            cristianoPowerShotTrail: [],
            cristianoGoatTackleParticles: [],
            cristianoPortugueseSpiritAura: [],
            cristianoMovementTrail: [],

            eddieWeAreAura: [],
            eddieWeAreParticles: [],
            eddieVenomTendrils: [],
            eddieVenomShotTrail: [],
            eddieSymbioteMontageAimAura: [],
            blackPuddles: [],

            zeusLightningParticles: [],
            zeusLightningTrail: [],
            zeusHeavenlyShieldWaves: [],
            zeusHeavenlyShieldAura: [],
            zeusOlympusFuryAura: [],
            zeusOlympusFuryBallTrail: [],
            zeusLightningChargeEffect: [],
            zeusOlympusFuryPullLines: [],
            zeusGroundScorches: [],

            asherStarTrail: [],
            asherTeleportBurst: [],
            asherArrivalGlimmer: [],

            hudsonEmperorDribbleTrail: [],
            hudsonEmperorDribbleParticles: [],
            hudsonEmperorDribbleAura: [],
            robsanGroundRupture: [],
            robsanEclipseWisps: [],
            robsanVoidPuffs: [],
            xdrakeSupernovaGroundCrack: [],
            xdrakeFootworkLeaves: [],
            xdrakeAncientApexGroundBurst: [],
            gojoRedExplosion: [],
            gojoLapseBluePullEffect: [],
            gojoPurpleArcs: [],
            eddieWeAreRipples: [],
            eddieVenomBallSwirl: [],
            eddieTeleportFlicker: [],

            hudsonSpeedLines: [],
            hudsonEnergyWaves: [],
            robsanShadowClones: [],
            robsanVoidRifts: [],
            xdrakeNatureSpirits: [],
            xdrakeTerraforms: [],
            gojoInfinityBarriers: [],
            gojoDomainExpansions: [],
            eddieSymbioteSpikes: [],
            eddieVenomDrops: [],
            zeusThunderClouds: [],
            zeusLightningBolts: [],

            sajaJinDemonicAura: [],
            sajaJinSoulTrail: [],
            sajaJinSoulParticles: [],
            sajaJinGhostTrail: [],
            sajaJinHypnoticGlow: [],
            sajaJinHypnoticTrail: [],
            sajaJinHypnoticSpinTrail: [],
            sajaJinHypnoticCaption: [],
            sajaJinHypnoticBurst: [],

            abbyColossalCalvesTrail: [],
            abbyPowerPinSparks: [],
            abbyDemonDriveAura: [],

            lincolnShrekParticles: [],
            lincolnShrekTrail: [],
            lincolnKissGyatGlow: [],
            lincolnKissWhitePuddles: [],
            lincolnKissBallTrail: [],
            lincolnKissHeartParticles: [],

            playerMovementTrail: [],

            fieldCracks: [],
            energyResidue: [],
            shockwaveRings: [],

            epicExplosions: [],
            massiveShockwaves: [],
            screenDistortions: [],
            energyNovas: [],
            particleStorms: [],
            chromaticAberrations: [],
            timeRipples: [],
            cosmicRifts: [],
            elementalBursts: [],
            dimensionalTears: [],
            powerSurges: [],
            mysticalRunes: [],
            energyMatrixes: [],
            celestialBeams: [],
            quantumFluctuations: [],
            vortexes: [],
            hyperTrails: [],
            auraExplosions: [],
            realityBreaks: [],
            cosmicWinds: [],

            korbinFireApocalypseFlames: [],
            korbinFireApocalypseEmbers: [],
            korbinFireApocalypseExplosion: [],
            korbinFireApocalypseTrail: [],
            korbinFireApocalypseShockwave: [],
            korbinBigShotWindParticles: [],
            korbinBigShotWindSwirls: [],
            korbinBigShotWindTrail: [],
            korbinBigBackPowerWindTrail: [],
            korbinBigBackPowerWindBurst: [],
            korbinBigBackPowerShockwave: [],

            wallyRocketTrail: [],
            wallySpeedForceDome: [],
            wallySpeedForceAura: [],
            wallyLightningAura: [],
            wallyLightningBolts: [],
            wallyMovementTrail: [],

            sixtySevenKidTextClones: [],
            sixtySevenKidMayhemAura: [],
            sixtySevenKidBlackoutOverlay: []
        };

        let scoreL = 0;
        let scoreR = 0;
       
        let playerLevel = parseInt(localStorage.getItem('playerLevel')) || 1;
        let playerGoals = parseInt(localStorage.getItem('playerGoals')) || 0;
        let goalsForNextLevel = playerLevel * 2;
        let lastGoalTime = 0;

        let last = performance.now();

        let loopId = null;

        function setGameState(state) {
            gameState = state;
            mainMenuScreen.classList.remove('active');
            gameScreen.classList.remove('active');
            isPlaying = false;
            if (loopId) cancelAnimationFrame(loopId);

            if (state === 'menu') {
                mainMenuScreen.classList.add('active');

                const movesbarContainer = slotC.closest('.movesbar');
                if (movesbarContainer) movesbarContainer.style.display = 'none';
            } else if (state === 'game') {
                gameScreen.classList.add('active');
                const movesbarContainer = slotC.closest('.movesbar');
                if (movesbarContainer) movesbarContainer.style.display = 'flex';


                if (currentStyle === 'none') {
                    if (movesbarContainer) movesbarContainer.style.display = 'none';
                } else if (currentStyle === 'hudson') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'none';
                    slotX.style.display = 'none';
                    slotB.style.display = 'none';
                } else if (currentStyle === 'asher') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'flex';
                    slotX.style.display = 'none';
                    slotB.style.display = 'none';
                } else if (currentStyle === 'eddie' || currentStyle === 'zeus' || currentStyle === 'ignis') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'flex';
                    slotX.style.display = 'flex';
                    slotB.style.display = 'none';
                } else if (currentStyle === 'robsan' || currentStyle === 'xdrake' || currentStyle === 'gojo' || 
                          currentStyle === 'leonardo' || currentStyle === 'angus' || currentStyle === 'diddy' || 
                          currentStyle === 'cristiano' || currentStyle === 'saja-jin' || currentStyle === 'abby' ||
                          currentStyle === 'wally') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'flex';
                    slotX.style.display = 'flex';
                    slotB.style.display = 'none';
                } else if (currentStyle === 'rabies') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'flex';
                    slotX.style.display = 'flex';
                    slotB.style.display = 'flex';
                } else if (currentStyle === 'lincoln') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'flex';
                    slotX.style.display = 'none';
                    slotB.style.display = 'none';
                } else if (currentStyle === '67kid') {
                    slotC.style.display = 'flex';
                    slotV.style.display = 'none';
                    slotX.style.display = 'none';
                    slotB.style.display = 'none';
                }
                resetGame();
                isPlaying = true;
                loop();
            }
        }

        function showModal(modal) {
            modal.classList.add('open');
        }

        function hideModal(modal) {
            modal.classList.remove('open');
        }

        function setPlayerStyle(style) {
            currentStyle = style;

            styleNoneBtn.classList.toggle('active', style === 'none');
            styleHudsonBtn.classList.toggle('active', style === 'hudson');
            styleRobsanBtn.classList.toggle('active', style === 'robsan');
            styleXDrakeBtn.classList.toggle('active', style === 'xdrake');
            styleGojoBtn.classList.toggle('active', style === 'gojo');
            styleEddieBtn.classList.toggle('active', style === 'eddie');
            styleZeusBtn.classList.toggle('active', style === 'zeus');
            styleIgnisBtn.classList.toggle('active', style === 'ignis');
            styleAsherBtn.classList.toggle('active', style === 'asher');
            styleLeonardoBtn.classList.toggle('active', style === 'leonardo');
            styleAngusBtn.classList.toggle('active', style === 'angus');
            styleDiddyBtn.classList.toggle('active', style === 'diddy');
            styleCristianoBtn.classList.toggle('active', style === 'cristiano');
            styleSajaJinBtn.classList.toggle('active', style === 'saja-jin');
            styleLincolnBtn.classList.toggle('active', style === 'lincoln');
            styleAbbyBtn.classList.toggle('active', style === 'abby');
            styleKorbinBtn.classList.toggle('active', style === 'korbin');
            style67KidBtn.classList.toggle('active', style === '67kid');
            styleWallyBtn.classList.toggle('active', style === 'wally');
            styleRabiesBtn.classList.toggle('active', style === 'rabies');




            slotC.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher','leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'korbin', '67kid', 'wally', 'rabies', 'ready', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool', 'ragebait-ready', 'squid-glaze-ready', 'steal-ballrot-ready', 'pookie-power-ready');
            slotV.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher','leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'korbin', '67kid', 'wally', 'rabies', 'ready', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool', 'ragebait-ready', 'squid-glaze-ready', 'steal-ballrot-ready', 'pookie-power-ready');
            slotX.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher','leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'korbin', '67kid', 'wally', 'rabies', 'ready', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool', 'ragebait-ready', 'squid-glaze-ready', 'steal-ballrot-ready', 'pookie-power-ready');
            slotB.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher','leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'korbin', '67kid', 'wally', 'rabies', 'ready', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool', 'ragebait-ready', 'squid-glaze-ready', 'steal-ballrot-ready', 'pookie-power-ready');

            if (style === 'hudson') {
                abilityNameCEl.textContent = 'Hudson Impact';
                abilityNameVEl.textContent = 'dribble like an emperor';
                abilityNameXEl.textContent = 'None';
                slotC.classList.add('hudson');
                slotV.classList.add('hudson');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'none';
            } else if (style === 'robsan') {
                abilityNameCEl.textContent = 'Shadow Spiral';
                abilityNameVEl.textContent = 'Eclipse Grasp';
                abilityNameXEl.textContent = 'Void Dash';
                slotC.classList.add('robsan');
                slotV.classList.add('robsan');
                slotX.classList.add('robsan');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'xdrake') {
                abilityNameCEl.textContent = 'Supernova';
                abilityNameVEl.textContent = 'Fossilised Footwork';
                abilityNameXEl.textContent = 'Ancient Apex';
                slotC.classList.add('xdrake');
                slotV.classList.add('xdrake');
                slotX.classList.add('xdrake');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'gojo') {
                abilityNameCEl.textContent = 'Red';
                abilityNameVEl.textContent = 'Lapse Blue';
                abilityNameXEl.textContent = 'Purple';
                slotC.classList.add('gojo');
                slotV.classList.add('gojo');
                slotX.classList.add('gojo');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'eddie') {
                slotC.classList.add('eddie');
                slotV.classList.add('eddie');
                slotX.classList.add('eddie');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
                awakeningBar.style.display = 'block';
                updateAwakeningBar();
                updateEddieAwakeningMoves();
            } else if (style === 'zeus') {
                abilityNameCEl.textContent = 'Lightning Bolt';
                abilityNameVEl.textContent = 'Heavenly Shield';
                abilityNameXEl.textContent = 'Olympus\' Fury';
                slotC.classList.add('zeus');
                slotV.classList.add('zeus');
                slotX.classList.add('zeus');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'ignis') {
                abilityNameCEl.textContent = 'Fire Breath';
                abilityNameVEl.textContent = 'Blaze Dash';
                abilityNameXEl.textContent = 'Phoenix Burst';
                slotC.classList.add('ignis');
                slotV.classList.add('ignis');
                slotX.classList.add('ignis');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'asher') {
                abilityNameCEl.textContent = 'Starfall Shot';
                abilityNameVEl.textContent = 'Celestial Pull';
                abilityNameXEl.textContent = 'None';
                slotC.classList.add('asher');
                slotV.classList.add('asher');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'none';
                } else if (style === 'leonardo') {
                abilityNameCEl.textContent = 'Focus Shot';
                abilityNameVEl.textContent = 'Sensory Shield';
                abilityNameXEl.textContent = 'Pattern Weave';
                slotC.classList.add('leonardo');
                slotV.classList.add('leonardo');
                slotX.classList.add('leonardo');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
                } else if (style === 'angus') {
                abilityNameCEl.textContent = `Power Burst (${player.angusBurstUsesLeft}/3)`;
                abilityNameVEl.textContent = 'Time Stop';
                abilityNameXEl.textContent = 'Shadow Teleport';
                slotC.classList.add('angus');
                slotV.classList.add('angus');
                slotX.classList.add('angus');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'diddy') {
                abilityNameCEl.textContent = 'Baby Oil Ascension';
                abilityNameVEl.textContent = 'Slick Shot';
                abilityNameXEl.textContent = 'Baby oil Blindness';
                slotC.classList.add('diddy');
                slotV.classList.add('diddy');
                slotX.classList.add('diddy');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'cristiano') {
                abilityNameCEl.textContent = 'Power Shot';
                abilityNameVEl.textContent = "GOAT's Tackle";
                abilityNameXEl.textContent = 'Portuguese Spirit';
                slotC.classList.add('cristiano');
                slotV.classList.add('cristiano');
                slotX.classList.add('cristiano');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'saja-jin') {
                abilityNameCEl.textContent = 'Demonic Heroism';
                abilityNameVEl.textContent = 'Soul-Sucking Shot';
                abilityNameXEl.textContent = 'Hypnotic Shot';
                slotC.classList.add('saja-jin');
                slotV.classList.add('saja-jin');
                slotX.classList.add('saja-jin');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'lincoln') {
                abilityNameCEl.textContent = 'Shrek Move';
                abilityNameVEl.textContent = 'Chill Guy Grasp';
                abilityNameXEl.textContent = 'None';
                slotC.classList.add('lincoln');
                slotV.classList.add('lincoln');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'none';
            } else if (style === 'abby') {
                abilityNameCEl.textContent = 'Colossal Calves';
                abilityNameVEl.textContent = 'Power Pin';
                abilityNameXEl.textContent = 'Demon Drive';
                slotC.classList.add('abby');
                slotV.classList.add('abby');
                slotX.classList.add('abby');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'korbin') {
                abilityNameCEl.textContent = 'Fiery Apocalypse';
                abilityNameVEl.textContent = 'Big Back Power';
                abilityNameXEl.textContent = 'Big Shot';
                slotC.classList.add('korbin');
                slotV.classList.add('korbin');
                slotX.classList.add('korbin');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === '67kid') {
                abilityNameCEl.textContent = '67 Mayhem';
                abilityNameVEl.textContent = 'None';
                abilityNameXEl.textContent = 'None';
                slotC.classList.add('67kid');
                slotC.style.display = 'flex';
                slotV.style.display = 'none';
                slotX.style.display = 'none';
            } else if (style === 'wally') {
                abilityNameCEl.textContent = 'Rocket Boost';
                abilityNameVEl.textContent = 'Speed Force';
                abilityNameXEl.textContent = 'Flashy Lightning';
                slotC.classList.add('wally');
                slotV.classList.add('wally');
                slotX.classList.add('wally');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
            } else if (style === 'rabies') {
                abilityNameCEl.textContent = 'Ragebait';
                abilityNameVEl.textContent = 'Steal a Ballrot';
                abilityNameXEl.textContent = 'Squid Glaze';
                abilityNameBEl.textContent = 'Pookie Power';
                slotC.classList.add('rabies');
                slotV.classList.add('rabies');
                slotX.classList.add('rabies');
                slotB.classList.add('rabies');
                slotC.style.display = 'flex';
                slotV.style.display = 'flex';
                slotX.style.display = 'flex';
                slotB.style.display = 'flex';
            }
            else {
                abilityNameCEl.textContent = 'no ability';
                abilityNameVEl.textContent = 'no ability';
                abilityNameXEl.textContent = 'no ability';
                abilityNameBEl.textContent = 'no ability';
                slotC.style.display = 'none';
                slotV.style.display = 'none';
                slotX.style.display = 'none';
                slotB.style.display = 'none';
            }

            if (style === 'wally') {
                awakeningBar.style.display = 'block';
                updateAwakeningBar();
            } else {
                awakeningBar.style.display = 'none';
            }

            const movesbarContainer = slotC.closest('.movesbar');
            movesbarContainer.style.display = (style === 'none') ? 'none' : 'flex';


            abilityReadyAt = 0;
            shadowSpiralReadyAt = 0;
            eclipseGraspReadyAt = 0;
            voidDashReadyAt = 0;
            supernovaReadyAt = 0;
            fossilFootworkReadyAt = 0;
            ancientApexReadyAt = 0;
            gojoRedReadyAt = 0;
            gojoLapseBlueReadyAt = 0;
            gojoPurpleReadyAt = 0;
            eddieWeAreReadyAt = 0;
            eddieVenomStrikeReadyAt = 0;
            eddieSymbioteMontageReadyAt = 0;
            zeusLightningReadyAt = 0;
            zeusHeavenlyShieldReadyAt = 0;
            zeusOlympusFuryReadyAt = 0;
            asherAutoGoalReadyAt = 0;
            asherBallTeleportReadyAt = 0;
            cristianoPowerShotReadyAt = 0;
            cristianoGoatTackleReadyAt = 0;
            cristianoPortugueseSpiritReadyAt = 0;
            sajaJinDemonicHeroismReadyAt = 0;
            sajaJinSoulSuckingShotReadyAt = 0;
            sajaJinHypnoticShotReadyAt = 0;
            abbyColossalCalvesReadyAt = 0;
            abbyPowerPinReadyAt = 0;
            abbyDemonDriveReadyAt = 0;
            korbinFieryApocalypseReadyAt = 0;
            korbinBigBackPowerReadyAt = 0;
            if (player.korbinBigBackPowerActive) {
                player.korbinBigBackPowerActive = false;
                player.korbinBigBackPowerStunned = false;
                player.maxSpd = player.korbinBigBackPowerOriginalMaxSpd;
                if (ball.korbinBigBackProtected) {
                    ball.korbinBigBackProtected = false;
                }
            }
            wallyRocketBoostReadyAt = 0;
            wallySpeedForceReadyAt = 0;
            wallyFlashyLightningReadyAt = 0;
            sixtySevenKidMayhemReadyAt = 0;
            
            player.awakeningProgress = 0;
            if (player.awakeningActive) {
                player.awakeningActive = false;
                player.awakeningEndTime = 0;
                player.lastFearActive = false;
                player.lastFearEndTime = 0;
                player.partOfMyDesireActive = false;
                player.partOfMyDesireEndTime = 0;
                player.partOfMyDesireOriginalMaxSpd = 3.2;
            }
        }



        window.onload = function() {
            setGameState('menu');
            setPlayerStyle('hudson');
            initializeLevelSystem();
        };



        playBtn.addEventListener('click', () => showModal(aiModal));
        tutorialBtn.addEventListener('click', () => showModal(tutorialModal));
        creditsBtn.addEventListener('click', () => showModal(creditsModal));
        stylesBtn.addEventListener('click', () => showModal(stylesModal));
        levelBoostBtn.addEventListener('click', () => showModal(levelBoostModal));
        levelResetBtn.addEventListener('click', () => {
            playerLevel = 1;
            playerGoals = 0;
            goalsForNextLevel = playerLevel * 2;
            updateLevelDisplay();
            showNotification('Level reset to beginning!', 'success');
        });
        exitBtn.addEventListener('click', () => setGameState('menu'));
        closeCreditsBtn.addEventListener('click', () => hideModal(creditsModal));
        closeStylesBtn.addEventListener('click', () => hideModal(stylesModal));
        closeTutorialBtn.addEventListener('click', () => hideModal(tutorialModal));
        closeAiBtn.addEventListener('click', () => hideModal(aiModal));
        closeLevelBoostBtn.addEventListener('click', () => hideModal(levelBoostModal));
       
        submitLevelBoostBtn.addEventListener('click', () => {
            const enteredCode = levelBoostCodeInput.value.trim();
            if (enteredCode === 'Sablol') {
                playerLevel += 15;
                updateLevelDisplay();
                showNotification('Code accepted! You gained 15 levels!', 'success');
                hideModal(levelBoostModal);
                levelBoostCodeInput.value = '';
            } else {
                hideModal(levelBoostModal);
                levelBoostCodeInput.value = 'wrong one buddy bang bang';
            }
        });
       
        levelBoostCodeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitLevelBoostBtn.click();
            }
        });
        playWithAiBtn.addEventListener('click', () => {
            aiEnabled = true;
            hideModal(aiModal);
            setGameState('game');
        });
        playWithoutAiBtn.addEventListener('click', () => {
            aiEnabled = false;
            hideModal(aiModal);
            setGameState('game');
        });

        styleNoneBtn.addEventListener('click', () => setPlayerStyle('none'));
        styleHudsonBtn.addEventListener('click', () => setPlayerStyle('hudson'));
        styleRobsanBtn.addEventListener('click', () => setPlayerStyle('robsan'));
        styleXDrakeBtn.addEventListener('click', () => setPlayerStyle('xdrake'));
        styleGojoBtn.addEventListener('click', () => setPlayerStyle('gojo'));
        styleEddieBtn.addEventListener('click', () => setPlayerStyle('eddie'));
        styleZeusBtn.addEventListener('click', () => setPlayerStyle('zeus'));
        styleIgnisBtn.addEventListener('click', () => setPlayerStyle('ignis'));
        styleAsherBtn.addEventListener('click', () => setPlayerStyle('asher'));
        styleLeonardoBtn.addEventListener('click', () => setPlayerStyle('leonardo'));
        styleAngusBtn.addEventListener('click', () => setPlayerStyle('angus'));
        styleDiddyBtn.addEventListener('click', () => setPlayerStyle('diddy'));
        styleCristianoBtn.addEventListener('click', () => setPlayerStyle('cristiano'));
        styleSajaJinBtn.addEventListener('click', () => setPlayerStyle('saja-jin'));
        styleLincolnBtn.addEventListener('click', () => {
            if (playerLevel >= 15) {
                setPlayerStyle('lincoln');
            } else {
                showNotification(`Lincoln requires level 15! You are level ${playerLevel}`, 'warning');
            }
        });
        styleAbbyBtn.addEventListener('click', () => setPlayerStyle('abby'));
        styleKorbinBtn.addEventListener('click', () => setPlayerStyle('korbin'));
        style67KidBtn.addEventListener('click', () => setPlayerStyle('67kid'));
        styleWallyBtn.addEventListener('click', () => {
            if (playerLevel >= 50) {
                setPlayerStyle('wally');
            } else {
                showNotification(`Wally requires level 50! You are level ${playerLevel}`, 'warning');
            }
        });
        styleRabiesBtn.addEventListener('click', () => setPlayerStyle('rabies'));

        window.addEventListener('keydown', e => {
            if (gameState !== 'game') return;
            const k = e.key.toLowerCase();
            keys[k] = true;

            if (k === 'e') {
                const now = performance.now();
                const d = Math.hypot(ball.x - player.x, ball.y - player.y);

                const keydownHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                if (keydownHypnoticLocked) {
                    showNotification('Ball is under Hypnotic control — cannot steal now', 'info');
                    return;
                }

                if (now - player.lastStealTime < player.stealCooldown) {
                    const cooldownLeft = Math.ceil((player.stealCooldown - (now - player.lastStealTime)) / 1000);
                    showNotification(`Steal on cooldown for ${cooldownLeft}s`, 'error');
                    return;
                }

                if (aiEnabled && aiPlayer.hasBall && d < player.r + ball.r + 20 && !player.hasBall && !player.eddieSymbioteMontageActive) {
                    aiPlayer.hasBall = false;
                    player.hasBall = true;
                    ball.vx = 0;
                    ball.vy = 0;
                    player.lastStealTime = now;
                    aiPlayer.lastStolenFromTime = now;
                    showNotification('yoink got the ball lol', 'success');
                } else if (!aiEnabled || !aiPlayer.hasBall) {
                    showNotification('e is for stealing from ai step on ball to pick up', 'info');
                } else if (d >= player.r + ball.r + 20) {
                    showNotification('too far from ai to steal smh', 'warning');
                } else if (player.hasBall) {
                    showNotification('you already got the ball bestie', 'info');
                }
            } else if (k === 'q') {
                if (player.hasBall && !player.isDribbling) {
                    player.isDribbling = true;
                    player.dribbleEndTime = performance.now() + 3000;
                    player.maxSpd *= 1.2;
                    showNotification('dribbling activated fr', 'success');
                }
            } else if (k === 'c') {
                if (currentStyle === 'wally' && player.awakeningActive) {
                    tryLastFear();
                } else if (currentStyle === 'hudson') {
                    tryKaiser();
                } else if (currentStyle === 'robsan') {
                    tryRobsanShadowSpiral();
                } else if (currentStyle === 'xdrake') {
                    tryXDrakeSupernova();
                } else if (currentStyle === 'gojo') {
                    tryGojoRed();
                } else if (currentStyle === 'eddie') {
                    if (player.eddieAwakeningActive) {
                        tryEddieVenomDevastation();
                    } else {
                        tryEddieWeAre();
                    }
                } else if (currentStyle === 'zeus') {
                    tryZeusLightningBolt();
                } else if (currentStyle === 'ignis') {
                    tryIgnisFireBreath();
                } else if (currentStyle === 'leonardo') {
                    tryLeonardoFocusShot();
                } else if (currentStyle === 'asher') {
                    tryAsherAutoGoal();
                } else if (currentStyle === 'angus') {
                    tryAngusPowerBurst();
                } else if (currentStyle === 'diddy') {
                    tryDiddyBabyOilAscension();
                } else if (currentStyle === 'cristiano') {
                    tryCristianoPowerShot();
                } else if (currentStyle === 'saja-jin') {
                    trySajaJinDemonicHeroism();
                } else if (currentStyle === 'lincoln') {
                    tryLincolnShrekMove();
                } else if (currentStyle === 'abby') {
                    tryAbbyColossalCalves();
                } else if (currentStyle === 'korbin') {
                    tryKorbinFieryApocalypse();
                } else if (currentStyle === '67kid') {
                    try67KidMayhem();
                } else if (currentStyle === 'wally') {
                    tryWallyRocketBoost();
                } else if (currentStyle === 'rabies') {
                    tryRabiesRagebait();
                }
            } else if (k === 'v') {
                if (currentStyle === 'wally' && player.awakeningActive) {
                    tryEyesClosed();
                } else if (currentStyle === 'hudson') {
                    tryHudsonEmperorDribble();
                } else if (currentStyle === 'robsan') {
                    tryRobsanEclipseGrasp();
                } else if (currentStyle === 'xdrake') {
                    tryXDrakeFossilFootwork();
                } else if (currentStyle === 'gojo') {
                    tryGojoLapseBlue();
                } else if (currentStyle === 'eddie') {
                    if (player.eddieAwakeningActive) {
                        tryEddieShadowRealm();
                    } else {
                        tryEddieVenomStrike();
                    }
                } else if (currentStyle === 'zeus') {
                    tryZeusHeavenlyShield();
                } else if (currentStyle === 'ignis') {
                    tryIgnisBlazeDash();
                } else if (currentStyle === 'leonardo') {
                    tryLeonardoSensoryShield();

                } else if (currentStyle === 'asher') {
                    tryAsherBallTeleport();
                } else if (currentStyle === 'leonardo') {
                    tryLeonardoSensoryShield();
                } else if (currentStyle === 'angus') {
                    tryAngusTimeStop();
                } else if (currentStyle === 'diddy') {
                    tryDiddySlickShot();
                } else if (currentStyle === 'cristiano') {
                    tryCristianoGoatTackle();
                } else if (currentStyle === 'saja-jin') {
                    trySajaJinSoulSuckingShot();
                } else if (currentStyle === 'lincoln') {
                    tryLincolnKissMove();
                } else if (currentStyle === 'abby') {
                    tryAbbyPowerPin();
                } else if (currentStyle === 'korbin') {
                    tryKorbinBigBackPower();
                } else if (currentStyle === 'wally') {
                    tryWallySpeedForce();
                } else if (currentStyle === 'rabies') {
                    tryRabiesStealBallrot();
                }
            } else if (k === 'x') {
                if (currentStyle === 'wally' && player.awakeningActive) {
                    tryPartOfMyDesire();
                } else if (currentStyle === 'robsan') {
                    tryRobsanVoidDash();
                } else if (currentStyle === 'xdrake') {
                    tryXDrakeAncientApex();
                } else if (currentStyle === 'gojo') {
                    tryGojoPurple();
                } else if (currentStyle === 'eddie') {
                    tryEddieSymbioteMontage();
                } else if (currentStyle === 'zeus') {
                    tryZeusOlympusFury();
                } else if (currentStyle === 'ignis') {
                    tryIgnisPhoenixBurst();
                } else if (currentStyle === 'leonardo') {
                    tryLeonardoPatternWeave();
                } else if (currentStyle === 'angus') {
                    tryAngusShadowTeleport();
                } else if (currentStyle === 'diddy') {
                    tryDiddyOilSlickTrap();
                } else if (currentStyle === 'cristiano') {
                    tryCristianoPortugueseSpirit();
                } else if (currentStyle === 'saja-jin') {
                    trySajaJinHypnoticShot();
                } else if (currentStyle === 'lincoln') {
                    tryLincolnGyattShowdown();
                } else if (currentStyle === 'abby') {
                    tryAbbyDemonDrive();
                } else if (currentStyle === 'korbin') {
                    tryKorbinBigShot();
                } else if (currentStyle === 'wally') {
                    tryWallyFlashyLightning();
                } else if (currentStyle === 'rabies') {
                    tryRabiesSquidGlaze();
                }
            } else if (k === 'b') {
                if (currentStyle === 'rabies') {
                    tryRabiesPookiePower();
                }
            } else if (k === 'g') {
                if (currentStyle === 'wally' && player.awakeningProgress >= AWAKENING_GOALS_REQUIRED && player.hasBall && !player.awakeningActive) {
                    triggerAwakening();
                }
                else if (currentStyle === 'eddie' && player.eddieAwakeningProgress >= 100 && player.hasBall && !player.eddieAwakeningActive) {
                    triggerEddieAwakening();
                }
            } else if (k === ' ') {
                if (currentStyle === 'korbin' && player.korbinBigBackPowerActive) {
                    stopKorbinBigBackPower();
                } else if (currentStyle === 'ignis' && player.ignisFireBreathActive) {
                    player.ignisFireBreathActive = false;
                    showNotification('fire breath cancelled', 'info');
                }
            }
        });
        window.addEventListener('keyup', e => {
            if (gameState !== 'game') return;
            keys[e.key.toLowerCase()] = false;
        });
        canvas.addEventListener('mousemove', e => {
            if (gameState !== 'game') return;
            const rect = canvas.getBoundingClientRect();
            mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
            mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
        });
        canvas.addEventListener('mousedown', () => {
            if (gameState !== 'game') return;

            if (!player.spinning && !player.charging && !player.telekinising && !player.dashing &&
                !player.xdrakeSupernovaDashing && !player.xdrakeFossilFootworking && !player.xdrakeAncientApexCharging &&
                !player.gojoPurpleActive && !player.gojoRedCharging && !player.eddieVenomStrikeActive && !player.eddieSymbioteMontageActive &&
                !player.zeusLightningCharging && !player.zeusOlympusFuryActive && !player.asherAutoGoalActive &&
                !player.rabiesPookiePowerActive && player.hasBall) {
                mouse.down = true;
                chargeStart = performance.now();
                autoShotFired = false;
                powerBar.style.opacity = 1;
                autoTimer = setTimeout(() => {
                    if (mouse.down && player.hasBall && !autoShotFired) {
                        autoShotFired = true;
                        shoot(1.25);
                        endCharge();
                    }
                }, AUTO_MS);
            } else if (currentStyle === 'xdrake' && player.xdrakeAncientApexCharging) {
                 mouse.down = true;
                 powerBar.style.opacity = 1;
            } else if (currentStyle === 'gojo' && player.gojoRedCharging) {
                mouse.down = true;
                powerBar.style.opacity = 1;
            } else if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                 mouse.down = true;
                 powerBar.style.opacity = 1;
            } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming') {
                 mouse.down = true;
                 powerBar.style.opacity = 1;
            } else if (currentStyle === 'ignis' && player.ignisFireBreathActive) {
                player.ignisFireBreathExtended = true;
                mouse.down = true;
                
                for (let i = 0; i < 15; i++) {
                    const angle = player.ignisFireBreathDirection + (Math.random() - 0.5) * IGNIS_FIRE_BREATH_CONE_ANGLE;
                    const distance = (player.ignisFireBreathExtended ? IGNIS_FIRE_BREATH_EXTENDED_RANGE : IGNIS_FIRE_BREATH_BASE_RANGE) * (0.5 + Math.random() * 0.5);
                    const x = player.x + Math.cos(angle) * distance;
                    const y = player.y + Math.sin(angle) * distance;
                    
                    vfx.ignisFireBreathParticles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        life: 1500 + Math.random() * 700,
                        t: 0,
                        size: 6 + Math.random() * 8
                    });
                }
            }
        });
        window.addEventListener('mouseup', () => {
            if (gameState !== 'game') return;

            if (!player.spinning && !player.charging && !player.telekinising && !player.dashing &&
                !player.xdrakeSupernovaDashing && !player.xdrakeFossilFootworking && !player.xdrakeAncientApexCharging &&
                !player.gojoPurpleActive && !player.gojoRedCharging && !player.asherAutoGoalActive &&
                mouse.down && player.hasBall && !autoShotFired && !player.zeusLightningCharging) {
                const held = (performance.now() - chargeStart);
                const t = clamp(held / AUTO_MS, 0, 1);
                const scale = lerp(0.55, 1.0, t);
                shoot(scale);
            } else if (currentStyle === 'xdrake' && player.xdrakeAncientApexCharging && mouse.down) {
                 xdrakeAncientApexShoot(1.0);
                 player.xdrakeAncientApexCharging = false;
                 endCharge();
            } else if (currentStyle === 'gojo' && player.gojoRedCharging) {
                if ((performance.now() - player.gojoRedChargeStartTime) < GOJO_RED_CHARGE_DURATION) {
                    player.gojoRedCharging = false;
                    clearTimeout(autoTimer);
                    endCharge();
                }
            } else if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                 if ((performance.now() - player.zeusLightningChargeStartTime) < ZEUS_LIGHTNING_CHARGE_DURATION) {
                    player.zeusLightningCharging = false;
                    clearTimeout(autoTimer);
                    endCharge();
                }
            } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming' && mouse.down) {
                 zeusOlympusFuryShoot();
            } else if (currentStyle === 'ignis' && player.ignisFireBreathActive) {
                player.ignisFireBreathExtended = false;
                mouse.down = false;
            }
            endCharge();
        });

        const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
        const lerp=(a,b,t)=>a+(b-a)*t;

        function showNotification(message, type = 'error') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }

        function getRGBA(colorStr, alpha) {
            if (colorStr.startsWith('#')) {
                const hex = colorStr.slice(1);
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            } else if (colorStr.startsWith('rgb(')) {
                const parts = colorStr.slice(4, -1).split(',').map(s => s.trim());
                return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha})`;
            } else if (colorStr.startsWith('rgba(')) {
                const parts = colorStr.slice(5, -1).split(',').map(s => s.trim());
                const a = parseFloat(parts[3]);
                return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha * a})`;
            }

            return `rgba(0, 0, 0, ${alpha})`;
        }

        function endCharge(){
            mouse.down=false;
            chargeStart=0;
            clearTimeout(autoTimer); autoTimer=null;
            powerBar.style.opacity=0.6;
            powerFill.style.width='0%';
            powerFill.style.transition = 'width 0.3s ease-out';
            setTimeout(() => {
                powerFill.style.transition = 'width 0.06s ease-out';
            }, 300);
            player.gojoRedCharging = false;
            player.zeusLightningCharging = false;
        }


        function updatePlayer(dt){
            const now = performance.now();

            if (player.isDribbling && now > player.dribbleEndTime) {
                player.isDribbling = false;
                player.maxSpd = player.maxSpd / 1.2;
                showNotification('dribbling ended', 'info');
            }

            if (player.hudsonEmperorDribbling) {
                const dribbleDuration = now - player.hudsonEmperorDribbleStartTime;
                const halfDuration = HUDSON_EMPEROR_DRIBBLE_DURATION / 2;

                if (dribbleDuration <= halfDuration) {
                    player.hudsonEmperorDribblePhase = 'left';
                    const progress = dribbleDuration / halfDuration;
                    const angle = player.hudsonEmperorDribbleMouseDir - Math.PI/3;
                    const targetX = player.hudsonEmperorDribbleStartX + Math.cos(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;
                    const targetY = player.hudsonEmperorDribbleStartY + Math.sin(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;

                    player.vx = (targetX - player.x) * 0.2;
                    player.vy = (targetY - player.y) * 0.2;
                } else if (dribbleDuration <= HUDSON_EMPEROR_DRIBBLE_DURATION) {
                    player.hudsonEmperorDribblePhase = 'right';
                    const progress = (dribbleDuration - halfDuration) / halfDuration;
                    const leftAngle = player.hudsonEmperorDribbleMouseDir - Math.PI/3;
                    const midX = player.hudsonEmperorDribbleStartX + Math.cos(leftAngle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE;
                    const midY = player.hudsonEmperorDribbleStartY + Math.sin(leftAngle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE;

                    const angle = player.hudsonEmperorDribbleMouseDir + Math.PI/3;
                    const targetX = midX + Math.cos(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;
                    const targetY = midY + Math.sin(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;

                    player.vx = (targetX - player.x) * 0.2;
                    player.vy = (targetY - player.y) * 0.2;
                } else {
                    player.hudsonEmperorDribbling = false;
                    player.hudsonEmperorDribblePhase = '';
                    player.vx = 0;
                    player.vy = 0;
                    showNotification('emperor dribble complete fr', 'success');
                }

            if (Math.random() < 0.6) {
                vfx.hudsonEmperorDribbleTrail.push(newHudsonEmperorTrail(player.x, player.y, player.hudsonEmperorDribblePhase));
                vfx.hudsonEmperorDribbleParticles.push(newHudsonEmperorParticle(player.x, player.y, player.hudsonEmperorDribblePhase));
            }
            if (Math.random() < 0.3) {
                vfx.hudsonEmperorDribbleAura.push(newHudsonEmperorAura(player.x, player.y));
            }
        }

        if (currentStyle === 'lincoln' && player.lincolnGyattShowdownActive) {
            const now = performance.now();
            const timeLeft = (player.lincolnGyattShowdownEndTime - now) / LINCOLN_GYATT_SHOWDOWN_DURATION;
            
            if (Math.random() < 0.3) {
                vfx.lincolnGyattAura.push({
                    x: player.x + (Math.random() - 0.5) * 40,
                    y: player.y + (Math.random() - 0.5) * 40,
                    life: 1000,
                    t: 0,
                    size: 15 + Math.random() * 10,
                    hue: 280 + Math.random() * 80,
                    intensity: timeLeft
                });
            }
            
            if (Math.random() < 0.2) {
                vfx.lincolnGyattTrail.push({
                    x: player.x + (Math.random() - 0.5) * 20,
                    y: player.y + (Math.random() - 0.5) * 20,
                    life: 800,
                    t: 0,
                    size: 8 + Math.random() * 6,
                    hue: 300 + Math.random() * 60,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2
                });
            }
            
            if (Math.random() < 0.1) {
                vfx.lincolnGyattParticles.push({
                    x: player.x + (Math.random() - 0.5) * 60,
                    y: player.y + (Math.random() - 0.5) * 60,
                    life: 1500,
                    t: 0,
                    size: 3 + Math.random() * 4,
                    hue: 280 + Math.random() * 100,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3
                });
            }
        }
            if (player.abbyDemonDriveActive) {
                const driveDuration = now - player.abbyDemonDriveStartTime;
               
                if (player.abbyDemonDrivePhase === 'forward' && driveDuration < 500) {
                    const progress = driveDuration / 500;
                    const moveDistance = 120;
                    const targetX = player.abbyDemonDriveStartX + Math.cos(player.abbyDemonDriveDirection) * moveDistance * progress;
                    const targetY = player.abbyDemonDriveStartY + Math.sin(player.abbyDemonDriveDirection) * moveDistance * progress;
                   
                    ball.x = targetX + Math.cos(player.abbyDemonDriveDirection) * 40;
                    ball.y = targetY + Math.sin(player.abbyDemonDriveDirection) * 40;
                    ball.vx = Math.cos(player.abbyDemonDriveDirection) * 30;
                    ball.vy = Math.sin(player.abbyDemonDriveDirection) * 30;
                   
                    for(let i = 0; i < 25; i++) {
                        vfx.trails.push({
                            x: ball.x + (Math.random() - 0.5) * 120,
                            y: ball.y + (Math.random() - 0.5) * 120,
                            vx: (Math.random() - 0.5) * 25,
                            vy: (Math.random() - 0.5) * 25,
                            life: 65,
                            t: 0,
                            color: 'rgba(139, 0, 139, 0.98)',
                            w: 16
                        });
                    }
                   
                    for(let i = 0; i < 20; i++) {
                        vfx.trails.push({
                            x: ball.x,
                            y: ball.y,
                            vx: (Math.random() - 0.5) * 30,
                            vy: (Math.random() - 0.5) * 30,
                            life: 50,
                            t: 0,
                            color: 'rgba(255, 0, 255, 0.95)',
                            w: 14
                        });
                    }
                   
                    for(let ring = 0; ring < 3; ring++) {
                        for(let i = 0; i < 15; i++) {
                            const angle = (i / 15) * Math.PI * 2;
                            const radius = 25 + (ring * 15);
                            vfx.trails.push({
                                x: ball.x + Math.cos(angle) * radius,
                                y: ball.y + Math.sin(angle) * radius,
                                vx: Math.cos(angle) * (18 + ring * 5),
                                vy: Math.sin(angle) * (18 + ring * 5),
                                life: 55 - ring * 10,
                                t: 0,
                                color: `rgba(${139 + ring * 30}, 0, ${139 + ring * 30}, 0.9)`,
                                w: 12 - ring * 2
                            });
                        }
                    }
                   
                    for(let i = 0; i < 15; i++) {
                        vfx.trails.push({
                            x: ball.x + (Math.random() - 0.5) * 80,
                            y: ball.y + (Math.random() - 0.5) * 80,
                            vx: (Math.random() - 0.5) * 20,
                            vy: (Math.random() - 0.5) * 20,
                            life: 45,
                            t: 0,
                            color: 'rgba(75, 0, 130, 0.9)',
                            w: 10
                        });
                    }
                   
                } else if (player.abbyDemonDrivePhase === 'forward' && driveDuration >= 500) {
                    player.abbyDemonDrivePhase = 'stun';
                    player.vx = 0;
                    player.vy = 0;
                    showNotification('Stunned! Preparing super kick...', 'info');
                   
                } else if (player.abbyDemonDrivePhase === 'stun' && driveDuration < 1500) {
                    player.vx = 0;
                    player.vy = 0;
                   
                    for(let i = 0; i < 20; i++) {
                        vfx.trails.push({
                            x: player.x + (Math.random() - 0.5) * 100,
                            y: player.y + (Math.random() - 0.5) * 100,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15,
                            life: 50,
                            t: 0,
                            color: 'rgba(255, 255, 0, 0.9)',
                            w: 10
                        });
                    }
                   
                    for(let i = 0; i < 15; i++) {
                        const angle = (i / 15) * Math.PI * 2;
                        vfx.trails.push({
                            x: player.x + Math.cos(angle) * 60,
                            y: player.y + Math.sin(angle) * 60,
                            vx: Math.cos(angle) * 12,
                            vy: Math.sin(angle) * 12,
                            life: 45,
                            t: 0,
                            color: 'rgba(255, 215, 0, 0.85)',
                            w: 8
                        });
                    }
                   
                    for(let i = 0; i < 25; i++) {
                        vfx.trails.push({
                            x: player.x + (Math.random() - 0.5) * 80,
                            y: player.y + (Math.random() - 0.5) * 80,
                            vx: (Math.random() - 0.5) * 10,
                            vy: (Math.random() - 0.5) * 10,
                            life: 40,
                            t: 0,
                            color: 'rgba(255, 255, 255, 0.8)',
                            w: 6
                        });
                    }
                   
                } else if (player.abbyDemonDrivePhase === 'stun' && driveDuration >= 1500) {
                    player.abbyDemonDrivePhase = 'kick';
                   
                    player.x = ball.x - Math.cos(player.abbyDemonDriveDirection) * 25;
                    player.y = ball.y - Math.sin(player.abbyDemonDriveDirection) * 25;
                   
                    player.hasBall = false;
                    ball.vx = Math.cos(player.abbyDemonDriveDirection) * 50;
                    ball.vy = Math.sin(player.abbyDemonDriveDirection) * 50;
                   
                    for(let i = 0; i < 80; i++) {
                        vfx.trails.push({
                            x: ball.x + (Math.random() - 0.5) * 200,
                            y: ball.y + (Math.random() - 0.5) * 200,
                            vx: (Math.random() - 0.5) * 40,
                            vy: (Math.random() - 0.5) * 40,
                            life: 90,
                            t: 0,
                            color: 'rgba(255, 0, 255, 0.98)',
                            w: 20
                        });
                    }
                   
                    for(let i = 0; i < 50; i++) {
                        const angle = (i / 50) * Math.PI * 2;
                        vfx.trails.push({
                            x: ball.x,
                            y: ball.y,
                            vx: Math.cos(angle) * 35,
                            vy: Math.sin(angle) * 35,
                            life: 70,
                            t: 0,
                            color: 'rgba(139, 0, 139, 0.95)',
                            w: 16
                        });
                    }
                   
                    for(let i = 0; i < 40; i++) {
                        vfx.trails.push({
                            x: ball.x + (Math.random() - 0.5) * 150,
                            y: ball.y + (Math.random() - 0.5) * 150,
                            vx: (Math.random() - 0.5) * 30,
                            vy: (Math.random() - 0.5) * 30,
                            life: 80,
                            t: 0,
                            color: 'rgba(75, 0, 130, 0.9)',
                            w: 14
                        });
                    }
                   
                    for(let wave = 0; wave < 5; wave++) {
                        for(let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2;
                            const radius = 40 + (wave * 25);
                            vfx.trails.push({
                                x: ball.x + Math.cos(angle) * radius,
                                y: ball.y + Math.sin(angle) * radius,
                                vx: Math.cos(angle) * (30 + wave * 8),
                                vy: Math.sin(angle) * (30 + wave * 8),
                                life: 75 - wave * 10,
                                t: 0,
                                color: `rgba(${148 + wave * 20}, 0, ${211 - wave * 30}, 0.9)`,
                                w: 18 - wave * 3
                            });
                        }
                    }
                   
                    for(let i = 0; i < 35; i++) {
                        vfx.trails.push({
                            x: ball.x,
                            y: ball.y,
                            vx: (Math.random() - 0.5) * 45,
                            vy: (Math.random() - 0.5) * 45,
                            life: 65,
                            t: 0,
                            color: 'rgba(25, 0, 25, 0.85)',
                            w: 12
                        });
                    }
                   
                    player.abbyDemonDriveActive = false;
                    player.abbyDemonDrivePhase = '';
                    showNotification('DEMON DRIVE COMPLETE! Super kick!', 'success');
                }
            }

            let ax=0, ay=0;
            if(keys['w']||keys['arrowup']) ay-=player.accel;
            if(keys['s']||keys['arrowdown']) ay+=player.accel;
            if(keys['a']||keys['arrowleft']) ax-=player.accel;
            if(keys['d']||keys['arrowright']) ax+=player.accel;


            const isPlayerMovementRestricted = player.spinning || player.charging || player.telekinising || player.dashing ||
                                               player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking ||
                                               player.xdrakeAncientApexCharging || player.gojoPurpleActive || player.gojoRedCharging ||
                                               player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                               player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive ||
                                               player.abbyDemonDriveActive || player.sajaJinHypnoticShotActive || player.korbinBigBackPowerStunned ||
                                               player.rabiesPookiePowerActive;

            if (!isPlayerMovementRestricted) {

                const accelSmoothing = 0.8;
                player.vx = player.vx * accelSmoothing + (player.vx + ax) * (1 - accelSmoothing);
                player.vy = player.vy * accelSmoothing + (player.vy + ay) * (1 - accelSmoothing);

                const sp=Math.hypot(player.vx, player.vy);
                let currentMaxSpd = player.maxSpd;
                if (currentStyle === 'eddie' && player.eddieWeAreActive) {
                    currentMaxSpd = player.eddieWeAreOriginalMaxSpd * EDDIE_WE_ARE_SPEED_BOOST;
                }
                if (currentStyle === 'saja-jin' && player.sajaJinDemonicHeroismActive) {
                    currentMaxSpd = player.sajaJinDemonicHeroismOriginalMaxSpd * SAJA_JIN_DEMONIC_HEROISM_SPEED_BOOST;
                }
                if(sp>currentMaxSpd){ player.vx*=currentMaxSpd/sp; player.vy*=currentMaxSpd/sp; }

                if(ax===0 && ay===0){
                    const smoothDrag = player.drag * 0.98;
                    player.vx *= smoothDrag;
                    player.vy *= smoothDrag;
                    if (Math.abs(player.vx) < 0.01) player.vx = 0;
                    if (Math.abs(player.vy) < 0.01) player.vy = 0;
                }
            } else {

                player.vx *= player.drag;
                player.vy *= player.drag;
            }

            if (currentStyle === 'eddie' && player.eddieSymbioteMontageActive) {
                if (player.eddieSymbioteMontagePhase === 'teleporting') {
                    const progress = clamp((now - player.eddieSymbioteMontageTeleportStartTime) / (player.eddieSymbioteMontageTeleportEndTime - player.eddieSymbioteMontageTeleportStartTime), 0, 1);
                    player.x = lerp(player.eddieSymbioteMontageStartPlayerPos.x, player.eddieSymbioteMontageCurrentTeleportTarget.x, progress);
                    player.y = lerp(player.eddieSymbioteMontageStartPlayerPos.y, player.eddieSymbioteMontageCurrentTeleportTarget.y, progress);

                    if (player.hasBall) {
                        const ballOffsetDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                        ball.x = player.x + Math.cos(ballOffsetDir) * (player.r + ball.r + 4);
                        ball.y = player.y + Math.sin(ballOffsetDir) * (player.r + ball.r + 4);
                        ball.vx = player.vx;
                        ball.vy = player.vy;
                    }

                    if (progress >= 1) {
                        vfx.blackPuddles.push(newBlackPuddle(player.x, player.y));
                        player.eddieSymbioteMontageTeleportCount++;
                        if (player.eddieSymbioteMontageTeleportCount < 3) {
                            startNewSymbioteMontageTeleport();
                        } else {
                            player.x = W / 2;
                            player.y = H / 2;
                            player.vx = 0;
                            player.vy = 0;
                            const ballOffsetDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                            ball.x = player.x + Math.cos(ballOffsetDir) * (player.r + ball.r + 4);
                            ball.y = player.y + Math.sin(ballOffsetDir) * (player.r + ball.r + 4);
                            player.hasBall = true;

                            player.eddieSymbioteMontagePhase = 'aiming';
                            player.eddieSymbioteMontageAimStartTime = now;

                            vfx.eddieSymbioteMontageAimAura.push({
                                x: player.x, y: player.y,
                                end: now + EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION,
                                radius: player.r * 2.5,
                                t: 0, life: EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION
                            });
                        }
                    }
                } else if (player.eddieSymbioteMontagePhase === 'aiming') {
                    player.vx = 0;
                    player.vy = 0;

                    if (!player.eddieSymbioteMontageShotFired && (now - player.eddieSymbioteMontageAimStartTime) >= EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION) {

                        const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                        ball.vx = Math.cos(dir) * EDDIE_SYMBIOTE_MONTAGE_SHOT_POWER;
                        ball.vy = Math.sin(dir) * EDDIE_SYMBIOTE_MONTAGE_SHOT_POWER;
                        ball.maxSpeed = 100000;
                        player.hasBall = false;
                        player.eddieSymbioteMontageShotFired = true;


                        vfx.eddieVenomShotTrail.push({
                            end: performance.now() + 600,
                            w: 20,
                            colorStart: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-start'),
                            colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-end')
                        });
                        shockwave(player.x, player.y, 25, 'eddie-venom');

                        const origFric = ball.friction;
                        ball.friction = 0.99;
                        setTimeout(() => { ball.friction = origFric; ball.maxSpeed = 18; }, 600);

                        player.eddieSymbioteMontageActive = false;
                        player.eddieSymbioteMontageAimStartTime = 0;
                        player.eddieSymbioteMontageShotFired = false;
                    }
                }
            }


            const prevX = player.x;
            const prevY = player.y;

            if (!player._frozenForKissMove && !player._frozenFor67Mayhem) {
                player.x+=player.vx; player.y+=player.vy;
            }

            if (currentStyle === 'cristiano' && player.cristianoPortugueseSpiritActive) {
                const moveDistance = Math.hypot(player.x - prevX, player.y - prevY);
                if (moveDistance > 2) {
                    vfx.cristianoMovementTrail.push({
                        startX: prevX,
                        startY: prevY,
                        endX: player.x,
                        endY: player.y,
                        life: 400,
                        t: 0
                    });
                }
            }

            const left=margin, right=W-margin, top=margin, bottom=H-margin;
            const currentR = player.r;
            if(player.x-currentR<left){ player.x=left+currentR; player.vx*=-0.2; }
            if(player.x+currentR>right){ player.x=right-currentR; player.vx*=-0.2; }
            if(player.y-currentR<top){ player.y=top+currentR; player.vy*=-0.2; }
            if(player.y+currentR>bottom){ player.y=bottom-currentR; player.vy*=-0.2; }


            if (player.spinning) {
                player.spinTimer -= dt;
                if (player.spinTimer <= 0) {
                    player.spinning = false;
                    player.spinTimer = 0;
                    player.charging = true;
                    player.chargeTimer = ROBSAN_CHARGE_DURATION;
                    vfx.robsanChargeAura.push({x:player.x, y:player.y, end:performance.now() + ROBSAN_CHARGE_DURATION, radius:player.r*1.2, t:0, life:ROBSAN_CHARGE_DURATION});
                }
            }
            if (player.charging) {
                player.chargeTimer -= dt;
                if (player.chargeTimer <= 0) {
                    player.charging = false;
                    player.chargeTimer = 0;
                }
            }

            if (player.dashing) {
                player.dashTimer -= dt;
                if (player.dashTimer <= 0) {
                    player.dashing = false;
                    player.dashTimer = 0;
                    vfx.robsanVoidPuffs.push(newRobsanVoidPuff(player.x, player.y, 'end'));
                }
            }

            if (player.xdrakeSupernovaDashing) {
                player.xdrakeSupernovaDashTimer -= dt;
                if (player.xdrakeSupernovaDashTimer <= 0) {
                    player.xdrakeSupernovaDashing = false;
                    player.xdrakeSupernovaDashTimer = 0;
                }
            }

            if (player.xdrakeFossilFootworking) {
                player.xdrakeFossilFootworkTimer -= dt;
                if (player.xdrakeFossilFootworkTimer <= 0) {
                    player.xdrakeFossilFootworking = false;
                    player.xdrakeFossilFootworkTimer = 0;
                }
            }

            if (player.xdrakeAncientApexCharging) {
                const chargeDuration = now - player.ancientApexChargeTimer;
                if (chargeDuration >= XDRAKE_ANCIENT_APEX_CHARGE_DURATION && player.hasBall && mouse.down) {
                     xdrakeAncientApexShoot(1.0);
                     player.xdrakeAncientApexCharging = false;
                     endCharge();
                }
            }


            if (player.gojoLapseBlueActive && player.gojoLapseBlueBall) {
                player.gojoLapseBlueBall.angle += player.gojoLapseBlueBall.speed * (dt / 1000);
                player.gojoLapseBlueBall.x = player.x + Math.cos(player.gojoLapseBlueBall.angle) * player.gojoLapseBlueBall.orbitRadius;
                player.gojoLapseBlueBall.y = player.y + Math.sin(player.gojoLapseBlueBall.angle) * player.gojoLapseBlueBall.orbitRadius;


                vfx.gojoBlueOrbitParticles.push({
                    x: player.gojoLapseBlueBall.x,
                    y: player.gojoLapseBlueBall.y,
                    life: 200 + Math.random() * 200, t: 0, r: 2 + Math.random() * 3,
                    vx: -player.vx * 0.2 + (Math.random() - 0.5) * 0.5,
                    vy: -player.vy * 0.2 + (Math.random() - 0.5) * 0.5,
                    color: 'rgba(49, 130, 206,'
                });
            }


            if (player.gojoPurpleActive && player.gojoPurpleConverging) {

                const convergenceProgress = clamp((now - player.gojoPurpleConvergenceStartTime) / GOJO_PURPLE_CONVERGE_DURATION, 0, 1);


                const dir = player.gojoPurpleInitialDir;
                const spreadDist = GOJO_PURPLE_SPREAD_DISTANCE;
                const leftSpreadX = player.x + Math.cos(dir - Math.PI/2) * spreadDist;
                const leftSpreadY = player.y + Math.sin(dir - Math.PI/2) * spreadDist;
                const rightSpreadX = player.x + Math.cos(dir + Math.PI/2) * spreadDist;
                const rightSpreadY = player.y + Math.sin(dir + Math.PI/2) * spreadDist;


                const targetX = player.x;
                const targetY = player.y;

                player.gojoPurpleLeftBall.x = lerp(leftSpreadX, targetX, convergenceProgress);
                player.gojoPurpleLeftBall.y = lerp(leftSpreadY, targetY, convergenceProgress);

                player.gojoPurpleRightBall.x = lerp(rightSpreadX, targetX, convergenceProgress);
                player.gojoPurpleRightBall.y = lerp(rightSpreadY, targetY, convergenceProgress);


                if (convergenceProgress >= 1 && !player.gojoPurpleShotFired) {

                    const finalX = (player.gojoPurpleLeftBall.x + player.gojoPurpleRightBall.x) / 2;
                    const finalY = (player.gojoPurpleLeftBall.y + player.gojoPurpleRightBall.y) / 2;

                    vfx.gojoPurpleCombineVFX.push({x: finalX, y: finalY, t: 0, life: GOJO_PURPLE_SHOCKWAVE_DURATION, radius: GOJO_LAPSE_BLUE_BALL_RADIUS * 1.5});
                    shockwave(finalX, finalY, GOJO_LAPSE_BLUE_BALL_RADIUS * 1.5, 'gojo-purple');

                    gojoPurpleShockwaveEndTime = now + GOJO_PURPLE_SHOCKWAVE_DURATION;
                    player.gojoPurpleShotFired = true;

                    for(let i=0; i<8; i++) {
                        vfx.gojoPurpleArcs.push(newGojoPurpleArc(finalX, finalY, i * (Math.PI / 4)));
                    }
                }
            }


            if (player.gojoPurpleShotFired && now >= gojoPurpleShockwaveEndTime && gojoPurpleShockwaveEndTime !== 0) {
                 if (player.gojoPurpleLeftBall && player.gojoPurpleRightBall) {
                     const finalX = (player.gojoPurpleLeftBall.x + player.gojoPurpleRightBall.x) / 2;
                     const finalY = (player.gojoPurpleLeftBall.y + player.gojoPurpleRightBall.y) / 2;
                     shootPurpleShot(finalX, finalY, player.gojoPurpleInitialDir);
                 }

                 player.gojoPurpleActive = false;
                 player.gojoPurpleConverging = false;
                 player.gojoPurpleConvergenceStartTime = 0;
                 player.gojoPurpleLeftBall = null;
                 player.gojoPurpleRightBall = null;
                 player.gojoPurpleInitialDir = 0;
                 player.gojoPurpleShotFired = false;
                 gojoPurpleShockwaveEndTime = 0;


                 player.x = W * 0.25;
                 player.y = H * 0.5;
                 player.vx = 0;
                 player.vy = 0;
            }


            if (currentStyle === 'eddie' && player.eddieWeAreActive && now >= player.eddieWeAreEndTime) {
                player.eddieWeAreActive = false;
                player.maxSpd = player.eddieWeAreOriginalMaxSpd;
                const currentSpeed = Math.hypot(player.vx, player.vy);
                if (currentSpeed > player.maxSpd) {
                    player.vx *= player.maxSpd / currentSpeed;
                    player.vy *= player.maxSpd / currentSpeed;
                }
            }

            if (currentStyle === 'ignis' && player.ignisFireBreathActive && now >= (player.ignisFireBreathStartTime + IGNIS_FIRE_BREATH_DURATION)) {
                player.ignisFireBreathActive = false;
                player.ignisFireBreathExtended = false;
                showNotification('fire breath extinguished', 'info');
            }

            if (currentStyle === 'ignis' && player.ignisBlazeDashing && now >= (player.ignisBlazeDashStartTime + IGNIS_BLAZE_DASH_DURATION)) {
                player.ignisBlazeDashing = false;
                showNotification('blaze dash ended', 'info');
            }

            if (currentStyle === 'ignis' && player.ignisFireBreathActive) {
                if (Math.random() < 0.3) {
                    checkIgnisFireBreathBallCollision();
                }
                
                player.ignisFireBreathDirection = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                
                if (Math.random() < 0.4) {
                    const particleCount = mouse.down ? 3 : 1;
                    const baseSize = mouse.down ? 4 : 2;
                    
                    for (let i = 0; i < particleCount; i++) {
                        const angle = player.ignisFireBreathDirection + (Math.random() - 0.5) * IGNIS_FIRE_BREATH_CONE_ANGLE;
                        const distance = (player.ignisFireBreathExtended ? IGNIS_FIRE_BREATH_EXTENDED_RANGE : IGNIS_FIRE_BREATH_BASE_RANGE) * (0.3 + Math.random() * 0.7);
                        const x = player.x + Math.cos(angle) * distance;
                        const y = player.y + Math.sin(angle) * distance;
                        
                        vfx.ignisFireBreathParticles.push({
                            x: x,
                            y: y,
                            vx: Math.cos(angle) * (1.5 + Math.random() * 2),
                            vy: Math.sin(angle) * (1.5 + Math.random() * 2),
                            life: 800 + Math.random() * 400,
                            t: 0,
                            size: baseSize + Math.random() * 3
                        });
                    }
                }
                
                if (Math.random() < 0.2) {
                    const lineCount = mouse.down ? 2 : 1;
                    
                    for (let i = 0; i < lineCount; i++) {
                        const angle = player.ignisFireBreathDirection + (Math.random() - 0.5) * IGNIS_FIRE_BREATH_CONE_ANGLE;
                        const maxRange = player.ignisFireBreathExtended ? IGNIS_FIRE_BREATH_EXTENDED_RANGE : IGNIS_FIRE_BREATH_BASE_RANGE;
                        const endX = player.x + Math.cos(angle) * maxRange;
                        const endY = player.y + Math.sin(angle) * maxRange;
                        
                        vfx.ignisFireBreathLines.push({
                            startX: player.x,
                            startY: player.y,
                            endX: endX,
                            endY: endY,
                            life: 300 + Math.random() * 200,
                            t: 0,
                            thickness: mouse.down ? 4 : 2
                        });
                    }
                }
            }

            if (currentStyle === 'ignis' && player.ignisBlazeDashing) {
                const dashSpeed = IGNIS_BLAZE_DASH_SPEED;
                player.vx = Math.cos(player.ignisBlazeDashDirection) * dashSpeed;
                player.vy = Math.sin(player.ignisBlazeDashDirection) * dashSpeed;
                
                for (let i = 0; i < 3; i++) {
                    const offsetX = (Math.random() - 0.5) * 20;
                    const offsetY = (Math.random() - 0.5) * 20;
                    const backwardX = player.x - Math.cos(player.ignisBlazeDashDirection) * (15 + Math.random() * 10);
                    const backwardY = player.y - Math.sin(player.ignisBlazeDashDirection) * (15 + Math.random() * 10);
                    
                    vfx.ignisBlazeDashParticles.push({
                        x: backwardX + offsetX,
                        y: backwardY + offsetY,
                        vx: (Math.random() - 0.5) * 4 - Math.cos(player.ignisBlazeDashDirection) * 2,
                        vy: (Math.random() - 0.5) * 4 - Math.sin(player.ignisBlazeDashDirection) * 2,
                        life: 600 + Math.random() * 400,
                        t: 0,
                        size: 2 + Math.random() * 4
                    });
                }
                
                if (Math.random() < 0.7) {
                    const trailX = player.x - Math.cos(player.ignisBlazeDashDirection) * 25;
                    const trailY = player.y - Math.sin(player.ignisBlazeDashDirection) * 25;
                    
                    vfx.ignisBlazeDashFlames.push({
                        x: trailX + (Math.random() - 0.5) * 15,
                        y: trailY + (Math.random() - 0.5) * 15,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 800 + Math.random() * 300,
                        t: 0,
                        size: 3 + Math.random() * 5
                    });
                }
            }

            if (currentStyle === 'cristiano' && player.cristianoPortugueseSpiritActive && now >= player.cristianoPortugueseSpiritEndTime) {
                player.cristianoPortugueseSpiritActive = false;
                player.maxSpd = player.maxSpd / CRISTIANO_PORTUGUESE_SPIRIT_SPEED_MULTIPLIER;
                const currentSpeed = Math.hypot(player.vx, player.vy);
                if (currentSpeed > player.maxSpd) {
                    player.vx *= player.maxSpd / currentSpeed;
                    player.vy *= player.maxSpd / currentSpeed;
                }
                showNotification('portuguese spirit ended', 'info');
            }

            if (currentStyle === 'saja-jin' && player.sajaJinDemonicHeroismActive && now >= player.sajaJinDemonicHeroismEndTime) {
                player.sajaJinDemonicHeroismActive = false;
                player.maxSpd = player.sajaJinDemonicHeroismOriginalMaxSpd;
                const currentSpeed = Math.hypot(player.vx, player.vy);
                if (currentSpeed > player.maxSpd) {
                    player.vx *= player.maxSpd / currentSpeed;
                    player.vy *= player.maxSpd / currentSpeed;
                }
                showNotification('demonic heroism ended', 'info');
            }

            if (currentStyle === 'lincoln' && player.lincolnGyattShowdownActive && now >= player.lincolnGyattShowdownEndTime) {
                player.lincolnGyattShowdownActive = false;
                player.maxSpd = player.lincolnGyattShowdownOriginalMaxSpd;
                const currentSpeed = Math.hypot(player.vx, player.vy);
                if (currentSpeed > player.maxSpd) {
                    player.vx *= player.maxSpd / currentSpeed;
                    player.vy *= player.maxSpd / currentSpeed;
                }
                showNotification('GYATT SHOWDOWN ended!', 'info');
                
                const gyattImg = document.getElementById('lincolnGyattImage');
                if (gyattImg) {
                    gyattImg.style.opacity = '0';
                    setTimeout(() => {
                        if (gyattImg.parentNode) {
                            gyattImg.parentNode.removeChild(gyattImg);
                        }
                    }, 300);
                }
            }

            if (currentStyle === 'lincoln' && player.lincolnGyattShowdownActive) {
                const gyattImg = document.getElementById('lincolnGyattImage');
                if (gyattImg && canvas) {
                    const rect = canvas.getBoundingClientRect();
                    const centerX = rect.left + (player.x * rect.width / W);
                    const centerY = rect.top + (player.y * rect.height / H);
                    gyattImg.style.left = (centerX - 20) + 'px';
                    gyattImg.style.top = (centerY - 20) + 'px';
                }
            }

            if (currentStyle === 'zeus' && player.zeusHeavenlyShieldActive) {
                if (now >= player.zeusHeavenlyShieldEndTime) {
                    player.zeusHeavenlyShieldActive = false;
                    vfx.zeusHeavenlyShieldAura = [];
                } else {
                    if (Math.random() < 0.2) {
                        vfx.zeusHeavenlyShieldWaves.push(newZeusShieldWave(player.x, player.y));
                    }
                }
            }

            if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                const chargeDuration = now - player.zeusLightningChargeStartTime;
                if (chargeDuration >= ZEUS_LIGHTNING_CHARGE_DURATION && player.hasBall && mouse.down) {
                    zeusLightningShoot();
                    player.zeusLightningCharging = false;
                    vfx.zeusLightningChargeEffect = [];
                    endCharge();
                } else {
                    if (Math.random() < 0.3) {
                        vfx.zeusLightningChargeEffect.push(newZeusLightningChargeParticle(player.x, player.y));
                    }
                }
            }

            if (currentStyle === 'ignis' && player.ignisPhoenixBurstCharging) {
                const chargeDuration = now - player.ignisPhoenixBurstChargeStartTime;
                
                if (Math.random() < 0.5) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 15 + Math.random() * 25;
                    const x = player.x + Math.cos(angle) * distance;
                    const y = player.y + Math.sin(angle) * distance;
                    
                    vfx.ignisPhoenixBurstChargeAura.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * (0.5 + Math.random() * 1.5),
                        vy: Math.sin(angle) * (0.5 + Math.random() * 1.5),
                        life: 600 + Math.random() * 400,
                        t: 0,
                        size: 2 + Math.random() * 4,
                        intensity: chargeDuration / IGNIS_PHOENIX_BURST_CHARGE_DURATION
                    });
                }
                
                if (Math.random() < (chargeDuration / IGNIS_PHOENIX_BURST_CHARGE_DURATION) * 0.3) {
                    const angle = Math.random() * Math.PI * 2;
                    const x = player.x + Math.cos(angle) * 10;
                    const y = player.y + Math.sin(angle) * 10;
                    
                    vfx.ignisPhoenixBurstChargeAura.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2,
                        life: 800 + Math.random() * 300,
                        t: 0,
                        size: 3 + Math.random() * 5,
                        intensity: 1.0
                    });
                }
            }

            if (currentStyle === 'leonardo' && player.leonardoShieldActive && now >= player.leonardoShieldEndTime) {
                player.leonardoShieldActive = false;
            }
            if (currentStyle === 'leonardo' && player.leonardoDashing) {
                player.leonardoDashTimer -= dt;
                if (player.leonardoDashTimer <= 0) {
                    player.leonardoDashing = false;
                }
            }

            if (currentStyle === 'wally' && player.wallyRocketBoostActive) {
                if (now >= player.wallyRocketBoostEndTime) {
                    player.wallyRocketBoostActive = false;
                    player.vx *= 0.3;
                    player.vy *= 0.3;
                } else {
                    const elapsed = now - (player.wallyRocketBoostEndTime - WALLY_ROCKET_BOOST_DURATION);
                    const progress = Math.min(1, elapsed / WALLY_ROCKET_BOOST_DURATION);
                    
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    
                    player.x = player.wallyRocketBoostStartX + (player.wallyRocketBoostTargetX - player.wallyRocketBoostStartX) * easeProgress;
                    player.y = player.wallyRocketBoostStartY + (player.wallyRocketBoostTargetY - player.wallyRocketBoostStartY) * easeProgress;
                }
            }

            if (currentStyle === 'wally' && player.wallySpeedForceActive) {
                if (now >= player.wallySpeedForceEndTime) {
                    player.wallySpeedForceActive = false;
                    player.maxSpd = player.wallySpeedForceOriginalMaxSpd;
                } else {
                    const distToBall = Math.hypot(ball.x - player.x, ball.y - player.y);
                    if (distToBall <= WALLY_SPEED_FORCE_RANGE && !player.hasBall) {
                        const dx = player.x - ball.x;
                        const dy = player.y - ball.y;
                        const force = 0.8;
                        ball.vx += dx * force / distToBall;
                        ball.vy += dy * force / distToBall;
                    }
                    if (!player.hasBall && player.maxSpd === player.wallySpeedForceOriginalMaxSpd) {
                        player.maxSpd *= WALLY_SPEED_FORCE_SPEED_BOOST;
                    } else if (player.hasBall && player.maxSpd > player.wallySpeedForceOriginalMaxSpd) {
                        player.maxSpd = player.wallySpeedForceOriginalMaxSpd;
                    }
                }
            }

            if (currentStyle === 'wally' && player.wallyFlashyLightningActive && now >= player.wallyFlashyLightningEndTime) {
                player.wallyFlashyLightningActive = false;
                player.maxSpd = player.wallyFlashyLightningOriginalMaxSpd;
            }

            if (currentStyle === 'korbin' && player.korbinBigBackPowerActive) {
                if (now >= player.korbinBigBackPowerEndTime) {
                    stopKorbinBigBackPower();
                } else {
                    player.vx = player.korbinBigBackPowerDirection.x * KORBIN_BIG_BACK_POWER_SPEED;
                    player.vy = player.korbinBigBackPowerDirection.y * KORBIN_BIG_BACK_POWER_SPEED;
                    
                    const futureX = player.x + player.vx;
                    const futureY = player.y + player.vy;
                    
                    if (futureX <= margin + player.r || futureX >= W - margin - player.r ||
                        futureY <= margin + player.r || futureY >= H - margin - player.r) {
                        stopKorbinBigBackPower();
                        showNotification('Hit wall! Big Back Power stopped!', 'info');
                    }
                    
                    if (Math.random() < 0.4) {
                        vfx.korbinBigBackPowerWindTrail.push({
                            x: player.x + (Math.random() - 0.5) * 40,
                            y: player.y + (Math.random() - 0.5) * 40,
                            vx: -player.vx * 0.3 + (Math.random() - 0.5) * 5,
                            vy: -player.vy * 0.3 + (Math.random() - 0.5) * 5,
                            life: 400 + Math.random() * 200,
                            t: 0,
                            size: 8 + Math.random() * 6,
                            intensity: 0.6 + Math.random() * 0.4,
                            spin: (Math.random() - 0.5) * 0.2
                        });
                    }
                }
            }

            if (currentStyle === 'zeus' && player.zeusOlympusFuryActive) {
                if (player.zeusOlympusFuryPhase === 'pulling') {
                    const pullTimeElapsed = now - player.zeusOlympusFuryPullStartTime;
                    if (pullTimeElapsed >= ZEUS_OLYMPUS_FURY_PULL_DURATION || player.hasBall) {
                        player.zeusOlympusFuryPhase = 'aiming';
                        player.zeusOlympusFuryAimStartTime = now;
                        player.hasBall = true;

                        vfx.zeusOlympusFuryPullLines = [];

                        vfx.zeusOlympusFuryAura.push({
                            x: player.x, y: player.y,
                            end: now + ZEUS_OLYMPUS_FURY_AIM_DURATION,
                            radius: player.r * 2.5,
                            t: 0, life: ZEUS_OLYMPUS_FURY_AIM_DURATION
                        });
                    } else {
                        vfx.zeusOlympusFuryPullLines.push(newZeusOlympusFuryPullLine(player.x, player.y, ball.x, ball.y));
                    }
                } else if (player.zeusOlympusFuryPhase === 'aiming') {
                    player.vx = 0;
                    player.vy = 0;

                    if (!player.zeusOlympusFuryShotFired && (now - player.zeusOlympusFuryAimStartTime) >= ZEUS_OLYMPUS_FURY_AIM_DURATION) {
                        zeusOlympusFuryShoot();
                    }
                }
            }

            // Rabies Pookie Power state cleanup
            if (currentStyle === 'rabies' && player.rabiesPookiePowerActive && now >= player.rabiesPookiePowerEndTime) {
                player.rabiesPookiePowerActive = false;
                player.rabiesPookiePowerEndTime = 0;
            }
        }

function updateBall(dt){
            const currentR = player.r;
            if (player.asherStarfallCharging) {
                const elapsed = performance.now() - player.asherStarfallChargeStartTime;
                const angle = (elapsed / 1000) * ASHER_STARFALL_ORBIT_SPEED;

                ball.x = player.x + Math.cos(angle) * ASHER_STARFALL_ORBIT_RADIUS;
                ball.y = player.y + Math.sin(angle) * ASHER_STARFALL_ORBIT_RADIUS;
                ball.vx = 0;
                ball.vy = 0;

                if (Math.random() < 0.5) {
                    vfx.sparks.push({
                        x: ball.x, y: ball.y,
                        vx: (Math.random() - 0.5) * 1.5,
                        vy: (Math.random() - 0.5) * 1.5,
                        life: 150 + Math.random() * 150,
                        t: 0, r: 1 + Math.random() * 1.5,
                        color: 'rgba(233, 213, 255,'
                    });
                }
                return;
            }

            // Handle ball tween to player (for rabies steal move)
            if (ball.tweenToPlayer) {
                const now = performance.now();
                const elapsed = now - ball.tweenStartTime;
                const progress = Math.min(elapsed / ball.tweenDuration, 1);
                
                // Smooth easing function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                ball.x = ball.tweenStartX + (ball.tweenTargetX - ball.tweenStartX) * easeProgress;
                ball.y = ball.tweenStartY + (ball.tweenTargetY - ball.tweenStartY) * easeProgress;
                
                ball.vx = 0;
                ball.vy = 0;
                
                if (progress >= 1) {
                    ball.tweenToPlayer = false;
                }
                return;
            }

            if (ball.isHoming) {
                const now = performance.now();
                if (now > ball.homingEndTime) {
                    ball.isHoming = false;
                    player.asherAutoGoalActive = false;
                    ball.maxSpeed = 18;
                } else {
                    const targetDir = Math.atan2(ball.homingTargetY - ball.y, ball.homingTargetX - ball.x);
                    const currentDir = Math.atan2(ball.vy, ball.vx);

                    let angleDiff = targetDir - currentDir;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                    const newDir = currentDir + clamp(angleDiff, -ASHER_HOMING_TURN_RATE, ASHER_HOMING_TURN_RATE);

                    const currentSpeed = Math.hypot(ball.vx, ball.vy);
                    ball.vx = Math.cos(newDir) * currentSpeed;
                    ball.vy = Math.sin(newDir) * currentSpeed;
                }
            }

            if(player.hasBall && !player.gojoPurpleActive && !player.gojoRedCharging && !player.eddieVenomStrikeActive && !(currentStyle === 'eddie' && player.eddieSymbioteMontageActive) &&
               !player.zeusLightningCharging && !(player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming')){
                const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);
                let dist = currentR + ball.r + 4;

                ball.x=player.x+Math.cos(dir)*dist;
                ball.y=player.y+Math.sin(dir)*dist;
                ball.vx=player.vx; ball.vy=player.vy;
            } else if (player.telekinising || (currentStyle === 'eddie' && player.eddieVenomStrikeActive) ||
                       (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'pulling' && !player.hasBall)) {

                const dt_s = dt / 1000;

                const dx = player.x - ball.x;
                const dy = player.y - ball.y;
                const dist = Math.hypot(dx, dy);
                const dir = Math.atan2(dy, dx);

                let pullSpeed = EDDIE_VENOM_STRIKE_PULL_SPEED;
                if (currentStyle === 'zeus' && player.zeusOlympusFuryActive) {
                    pullSpeed = 400;
                }

                ball.vx = Math.cos(dir) * pullSpeed;
                ball.vy = Math.sin(dir) * pullSpeed;

                ball.x += ball.vx * dt_s;
                ball.y += ball.vy * dt_s;


                if(dist < currentR + ball.r + 6){
                    player.hasBall = true;
                    player.telekinising = false;
                    vfx.eclipseLines = [];

                    if (currentStyle === 'eddie' && player.eddieVenomStrikeActive) {

                        const shootDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                        ball.vx = Math.cos(shootDir) * EDDIE_VENOM_STRIKE_SHOT_POWER + player.vx * 0.3;
                        ball.vy = Math.sin(shootDir) * EDDIE_VENOM_STRIKE_SHOT_POWER + player.vy * 0.3;
                        player.hasBall = false;
                        player.eddieVenomStrikeActive = false;
                        vfx.eddieVenomBallSwirl = [];

                        vfx.eddieVenomShotTrail.push({
                            end: performance.now() + 600,
                            w: 20,
                            colorStart: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-start'),
                            colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-end')
                        });
                        shockwave(player.x, player.y, 25, 'eddie-venom');
                        const origFric = ball.friction;
                        ball.friction = 0.99;
                        setTimeout(() => { ball.friction = origFric; ball.maxSpeed = 18; }, 600);
                    } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive) {
                        ball.vx = player.vx;
                        ball.vy = player.vy;
                    }
                } else if ((currentStyle === 'eddie' && player.eddieVenomStrikeActive) || (currentStyle === 'zeus' && player.zeusOlympusFuryActive)) {
                     vfx.eddieVenomBallSwirl.push(newEddieVenomBallSwirlParticle(ball.x, ball.y, dir + Math.PI));
                }
            }
            else{
                if (player.sajaJinHypnoticShotActive) {
                    const now = performance.now();
                    const elapsedTime = now - player.sajaJinHypnoticShotStartTime;

                    if (player.sajaJinHypnoticShotPhase === 'spinning') {
                        const spinProgress = elapsedTime / SAJA_JIN_HYPNOTIC_SHOT_SPIN_DURATION;
                        const smoothSpinSpeed = SAJA_JIN_HYPNOTIC_SHOT_SPIN_SPEED * (1 + Math.sin(elapsedTime * 0.003) * 0.3);
                        
                        if (isFinite(smoothSpinSpeed)) {
                            player.sajaJinHypnoticShotSpinAngle += smoothSpinSpeed;
                        }
                       
                        const baseRadius = SAJA_JIN_HYPNOTIC_SHOT_SPIN_RADIUS;
                        const radiusPulse = baseRadius + Math.sin(elapsedTime * 0.005) * 15;
                        
                        if (isFinite(player.sajaJinHypnoticShotPlayerCenterX) && 
                            isFinite(player.sajaJinHypnoticShotPlayerCenterY) &&
                            isFinite(player.sajaJinHypnoticShotSpinAngle) && 
                            isFinite(radiusPulse) && radiusPulse > 0) {
                            
                            const newX = player.sajaJinHypnoticShotPlayerCenterX + Math.cos(player.sajaJinHypnoticShotSpinAngle) * radiusPulse;
                            const newY = player.sajaJinHypnoticShotPlayerCenterY + Math.sin(player.sajaJinHypnoticShotSpinAngle) * radiusPulse;
                            
                            if (isFinite(newX) && isFinite(newY)) {
                                ball.x = newX;
                                ball.y = newY;
                            }
                        }
                        ball.vx = 0;
                        ball.vy = 0;

                        for (let layer = 0; layer < SAJA_JIN_HYPNOTIC_SHOT_SPIRAL_LAYERS; layer++) {
                            const layerRadius = baseRadius * (0.6 + layer * 0.3);
                            const layerAngle = player.sajaJinHypnoticShotSpinAngle + (layer * Math.PI * 0.67);
                            
                            if (isFinite(layerRadius) && isFinite(layerAngle) && 
                                isFinite(player.sajaJinHypnoticShotPlayerCenterX) && 
                                isFinite(player.sajaJinHypnoticShotPlayerCenterY) && 
                                layerRadius > 0) {
                                
                                const layerX = player.sajaJinHypnoticShotPlayerCenterX + Math.cos(layerAngle) * layerRadius;
                                const layerY = player.sajaJinHypnoticShotPlayerCenterY + Math.sin(layerAngle) * layerRadius;
                                
                                if (isFinite(layerX) && isFinite(layerY)) {
                                    vfx.sajaJinHypnoticSpinTrail.push({
                                        x: layerX,
                                        y: layerY,
                                        life: 600 + layer * 100,
                                        t: 0,
                                        angle: layerAngle,
                                        layer: layer,
                                        intensity: 1 - (layer * 0.25)
                                    });
                                }
                            }
                        }

                        if (isFinite(ball.x) && isFinite(ball.y) && isFinite(player.sajaJinHypnoticShotSpinAngle)) {
                            vfx.sajaJinHypnoticSpinTrail.push({
                                x: ball.x,
                                y: ball.y,
                                life: 800,
                                t: 0,
                                angle: player.sajaJinHypnoticShotSpinAngle,
                                layer: -1,
                                intensity: 1.2
                            });
                        }

                        if (Math.floor(elapsedTime / 200) % 2 === 0 && 
                            isFinite(player.sajaJinHypnoticShotPlayerCenterX) && 
                            isFinite(player.sajaJinHypnoticShotPlayerCenterY) && 
                            isFinite(baseRadius) && baseRadius > 0) {
                            
                            vfx.sajaJinHypnoticGlow.push({
                                x: player.sajaJinHypnoticShotPlayerCenterX,
                                y: player.sajaJinHypnoticShotPlayerCenterY,
                                radius: baseRadius * 1.5,
                                life: 1000,
                                t: 0,
                                type: 'pulse_ring'
                            });
                        }

                        if (elapsedTime >= SAJA_JIN_HYPNOTIC_SHOT_SPIN_DURATION) {
                            player.sajaJinHypnoticShotPhase = 'left';
                            player.sajaJinHypnoticShotStartTime = now;
                            showNotification('Ball slowly commanded to drift left...', 'info');
                        }
                    } else if (player.sajaJinHypnoticShotPhase === 'left') {
                        const LEFT_TOTAL_SHIFT = 12;
                        const dt_s_local = (typeof dt !== 'undefined') ? dt / 1000 : 1/
                        60;
                        const perFrameShift = LEFT_TOTAL_SHIFT * (dt_s_local / (SAJA_JIN_HYPNOTIC_SHOT_LEFT_DURATION / 1000));
                        ball.vx = 0;
                        ball.vy = 0;
                        ball.x -= perFrameShift;

                        if (elapsedTime >= SAJA_JIN_HYPNOTIC_SHOT_LEFT_DURATION) {
                            player.sajaJinHypnoticShotPhase = 'caption';
                            player.sajaJinHypnoticShotStartTime = now;
                            ball.vx = 0;
                            ball.vy = 0;

                            vfx.sajaJinHypnoticCaption.push({
                                text: "Ball, go in the goal or else I'll suck that soul outta you!",
                                x: W/2,
                                y: H/4,
                                life: SAJA_JIN_HYPNOTIC_SHOT_CAPTION_DURATION,
                                t: 0
                            });
                            showNotification("Saja Jin threatens the ball!", 'warning');
                        }
                    } else if (player.sajaJinHypnoticShotPhase === 'caption') {
                        ball.vx = 0;
                        ball.vy = 0;

                        if (elapsedTime >= SAJA_JIN_HYPNOTIC_SHOT_CAPTION_DURATION) {
                            player.sajaJinHypnoticShotPhase = 'goal';
                            player.sajaJinHypnoticShotStartTime = now;
                            showNotification('Ball obeys and heads to goal!', 'success');
                        }
                    } else if (player.sajaJinHypnoticShotPhase === 'goal') {
                        const goalX = W - margin - goalDepth/2;
                        const goalY = H/2;
                        const dx = goalX - ball.x;
                        const dy = goalY - ball.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        if (dist > 30) {
                            const goalPhaseTime = elapsedTime;
                            const curveIntensity = Math.sin(goalPhaseTime * 0.008) * 0.3;
                            
                            const perpX = -dy / dist;
                            const perpY = dx / dist;
                            
                            const baseVx = (dx / dist) * SAJA_JIN_HYPNOTIC_SHOT_GOAL_SPEED;
                            const baseVy = (dy / dist) * SAJA_JIN_HYPNOTIC_SHOT_GOAL_SPEED;
                            
                            ball.vx = baseVx + perpX * curveIntensity;
                            ball.vy = baseVy + perpY * curveIntensity;
                            
                            ball.x += ball.vx;
                            ball.y += ball.vy;
                            
                            const goalSpinAngle = goalPhaseTime * 0.05;
                            const spinTrailRadius = 15 + Math.sin(goalPhaseTime * 0.006) * 5;
                            
                            for (let i = 0; i < 4; i++) {
                                const angle = goalSpinAngle + (i * Math.PI * 0.5);
                                vfx.sajaJinHypnoticTrail.push({
                                    x: ball.x + Math.cos(angle) * spinTrailRadius,
                                    y: ball.y + Math.sin(angle) * spinTrailRadius,
                                    life: 400,
                                    t: 0,
                                    angle: angle,
                                    type: 'goal_spiral'
                                });
                            }
                            
                            vfx.sajaJinHypnoticGlow.push({
                                x: ball.x,
                                y: ball.y,
                                radius: 25 + Math.sin(goalPhaseTime * 0.01) * 8,
                                life: 300,
                                t: 0,
                                type: 'moving_aura'
                            });
                            
                        } else {
                            player.sajaJinHypnoticShotPhase = 'burst';
                            player.sajaJinHypnoticShotStartTime = now;
                            ball.vx = 0;
                            ball.vy = 0;

                            vfx.sajaJinHypnoticBurst.push({
                                x: ball.x,
                                y: ball.y,
                                radius: SAJA_JIN_HYPNOTIC_SHOT_BURST_RADIUS,
                                life: 2000,
                                t: 0,
                                type: 'main_burst'
                            });
                            
                            for (let ring = 0; ring < 4; ring++) {
                                setTimeout(() => {
                                    vfx.sajaJinHypnoticBurst.push({
                                        x: ball.x,
                                        y: ball.y,
                                        radius: SAJA_JIN_HYPNOTIC_SHOT_BURST_RADIUS * (0.7 + ring * 0.2),
                                        life: 1500,
                                        t: 0,
                                        type: 'ring_burst',
                                        delay: ring * 150
                                    });
                                }, ring * 150);
                            }

                            for (let i = 0; i < 80; i++) {
                                const angle = (Math.PI * 2 * i) / 80;
                                const spiralAngle = angle + (i * 0.2);
                                const speed = 8 + Math.random() * 8;
                                vfx.sajaJinSoulParticles.push({
                                    x: ball.x,
                                    y: ball.y,
                                    vx: Math.cos(spiralAngle) * speed,
                                    vy: Math.sin(spiralAngle) * speed,
                                    life: 1500 + Math.random() * 500,
                                    t: 0,
                                    size: Math.random() * 10 + 6,
                                    spiralAngle: spiralAngle
                                });
                            }
                            showNotification('HYPNOTIC BURST - GOAL INEVITABLE!', 'success');
                        }
                    } else if (player.sajaJinHypnoticShotPhase === 'burst') {
                        ball.vx = 0;
                        ball.vy = 0;

                        if (elapsedTime >= 800) {
                            const goalX = W - margin - goalDepth/2;
                            const goalY = H/2;

                            const NUDGE_FORWARD = Math.min(10, SAJA_JIN_HYPNOTIC_SHOT_GOAL_SPEED / 4);
                            ball.x = goalX - NUDGE_FORWARD;
                            ball.y = goalY;
                            ball.vx = NUDGE_FORWARD;
                            ball.vy = 0;

                            player.sajaJinHypnoticLockUntil = performance.now() + 1000;
                            player.sajaJinHypnoticShotActive = false;
                            showNotification('Hypnotic Shot COMPLETE!', 'success');

                            setTimeout(() => {
                                try {
                                    if (gameState !== 'game') return;
                                    ball.vx = 0;
                                    ball.x = Math.min((ball.x + NUDGE_FORWARD), goalX);
                                } catch (e) {
                                }
                            }, 300);
                        }
                    }
                } else {
                    ball.vx*=ball.friction; ball.vy*=ball.friction;
                    const sp=Math.hypot(ball.vx, ball.vy);
                    if(sp>ball.maxSpeed){ ball.vx*=ball.maxSpeed/sp; ball.vy*=ball.maxSpeed/sp; }
                    
                    if (player.lastFearActive && sp > 1) {
                        const distanceToPlayer = Math.hypot(ball.x - player.x, ball.y - player.y);
                        const shieldRadius = player.r * 3.5;
                        
                        if (distanceToPlayer <= shieldRadius) {
                            const angleToPlayer = Math.atan2(ball.y - player.y, ball.x - player.x);
                            const currentSpeed = Math.hypot(ball.vx, ball.vy);
                            
                            ball.vx = Math.cos(angleToPlayer) * currentSpeed * 1.2;
                            ball.vy = Math.sin(angleToPlayer) * currentSpeed * 1.2;
                            
                            for (let i = 0; i < 10; i++) {
                                vfx.sparks.push({
                                    x: ball.x + (Math.random() - 0.5) * 30,
                                    y: ball.y + (Math.random() - 0.5) * 30,
                                    vx: Math.cos(angleToPlayer + (Math.random() - 0.5)) * 5,
                                    vy: Math.sin(angleToPlayer + (Math.random() - 0.5)) * 5,
                                    life: 600,
                                    t: 0,
                                    r: 1.5 + Math.random() * 2,
                                    color: 'rgba(0, 255, 255,'
                                });
                            }
                            
                            showNotification('Shield deflected the ball!', 'success');
                        }
                    }
                    
                    ball.x+=ball.vx; ball.y+=ball.vy;

                    if (currentStyle === 'korbin' && sp > 15 && Math.random() < 0.4) {
                        for (let i = 0; i < 2; i++) {
                            vfx.korbinFireApocalypseTrail.push({
                                x: ball.x + (Math.random() - 0.5) * 20,
                                y: ball.y + (Math.random() - 0.5) * 20,
                                vx: -ball.vx * 0.15 + (Math.random() - 0.5) * 3,
                                vy: -ball.vy * 0.15 + (Math.random() - 0.5) * 3,
                                life: 300 + Math.random() * 200,
                                t: 0,
                                size: 4 + Math.random() * 5,
                                hue: Math.random() * 60,
                                intensity: 0.6 + Math.random() * 0.2,
                                loop: Math.sin(performance.now() * 0.01 + i) * 0.1
                            });
                        }

                        if (Math.random() < 0.2) {
                            vfx.korbinFireApocalypseEmbers.push({
                                x: ball.x + (Math.random() - 0.5) * 15,
                                y: ball.y + (Math.random() - 0.5) * 15,
                                vx: -ball.vx * 0.08 + (Math.random() - 0.5) * 5,
                                vy: -ball.vy * 0.08 + (Math.random() - 0.5) * 5,
                                life: 400 + Math.random() * 300,
                                t: 0,
                                size: 1 + Math.random() * 3,
                                hue: 15 + Math.random() * 30,
                                gravity: 0.03,
                                intensity: 0.6,
                                loop: Math.cos(performance.now() * 0.015) * 0.1
                            });
                        }
                    }
                }

                const left=margin+2, right=W-margin-2, top=margin+2, bottom=H-margin-2;

                const now = performance.now();
                const powerPinActive = ball.abbyPowerPinActive && now < ball.abbyPowerPinEndTime;
                const stickyMode = ball.stickyMode && now < ball.stickyModeEndTime;
               
                if(ball.x-ball.r<left){
                    ball.x=left+ball.r;
                    if(powerPinActive) {
                        ball.vx = 0; ball.vy = 0;
                        for(let i = 0; i < 6; i++) {
                            vfx.trails.push({
                                x: ball.x, y: ball.y,
                                vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
                                life: 25, t: 0,
                                color: 'rgba(255, 69, 0, 0.8)', w: 4
                            });
                        }
                        showNotification('Ball pinned to wall!', 'info');
                    } else if (ball.squidGlazed && performance.now() < ball.squidGlazeEndTime) {
                        ball.vx = 0; ball.vy *= 0.3;
                        // Add squid glaze VFX
                        for(let i = 0; i < 8; i++) {
                            vfx.rabiesSquidGlaze.push({
                                x: ball.x + (Math.random() - 0.5) * 20,
                                y: ball.y + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                r: 3 + Math.random() * 5,
                                life: 800 + Math.random() * 400,
                                t: 0,
                                isWhiteCircling: false
                            });
                        }
                        showNotification('Ball sticks to the wall!', 'info');
                    } else {
                        ball.vx*=-(ball.bounceDamping || 0.75);
                    }
                    impactWave(ball.x, ball.y, 10);
                }
                if(ball.x+ball.r>right){
                    ball.x=right-ball.r;
                    if(powerPinActive) {
                        ball.vx = 0; ball.vy = 0;
                        for(let i = 0; i < 6; i++) {
                            vfx.trails.push({
                                x: ball.x, y: ball.y,
                                vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
                                life: 25, t: 0,
                                color: 'rgba(255, 69, 0, 0.8)', w: 4
                            });
                        }
                        showNotification('Ball pinned to wall!', 'info');
                    } else if (ball.squidGlazed && performance.now() < ball.squidGlazeEndTime) {
                        ball.vx = 0; ball.vy *= 0.3;
                        // Add squid glaze VFX
                        for(let i = 0; i < 8; i++) {
                            vfx.rabiesSquidGlaze.push({
                                x: ball.x + (Math.random() - 0.5) * 20,
                                y: ball.y + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                r: 3 + Math.random() * 5,
                                life: 800 + Math.random() * 400,
                                t: 0,
                                isWhiteCircling: false
                            });
                        }
                        showNotification('Ball sticks to the wall!', 'info');
                    } else {
                        ball.vx*=-(ball.bounceDamping || 0.75);
                    }
                    impactWave(ball.x, ball.y, 10);
                }
                if(ball.y-ball.r<top){
                    ball.y=top+ball.r;
                    if(powerPinActive) {
                        ball.vx = 0; ball.vy = 0;
                        for(let i = 0; i < 6; i++) {
                            vfx.trails.push({
                                x: ball.x, y: ball.y,
                                vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
                                life: 25, t: 0,
                                color: 'rgba(255, 69, 0, 0.8)', w: 4
                            });
                        }
                        showNotification('Ball pinned to wall!', 'info');
                    } else if (ball.squidGlazed && performance.now() < ball.squidGlazeEndTime) {
                        ball.vy = 0; ball.vx *= 0.3;
                        // Add squid glaze VFX
                        for(let i = 0; i < 8; i++) {
                            vfx.rabiesSquidGlaze.push({
                                x: ball.x + (Math.random() - 0.5) * 20,
                                y: ball.y + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                r: 3 + Math.random() * 5,
                                life: 800 + Math.random() * 400,
                                t: 0,
                                isWhiteCircling: false
                            });
                        }
                        showNotification('Ball sticks to the wall!', 'info');
                    } else {
                        ball.vy*=-(ball.bounceDamping || 0.75);
                    }
                    impactWave(ball.x, ball.y, 10);
                }
                if(ball.y+ball.r>bottom){
                    ball.y=bottom-ball.r;
                    if(powerPinActive) {
                        ball.vx = 0; ball.vy = 0;
                        for(let i = 0; i < 6; i++) {
                            vfx.trails.push({
                                x: ball.x, y: ball.y,
                                vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
                                life: 25, t: 0,
                                color: 'rgba(255, 69, 0, 0.8)', w: 4
                            });
                        }
                        showNotification('Ball pinned to wall!', 'info');
                    } else if (ball.squidGlazed && performance.now() < ball.squidGlazeEndTime) {
                        ball.vy = 0; ball.vx *= 0.3;
                        // Add squid glaze VFX
                        for(let i = 0; i < 8; i++) {
                            vfx.rabiesSquidGlaze.push({
                                x: ball.x + (Math.random() - 0.5) * 20,
                                y: ball.y + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                r: 3 + Math.random() * 5,
                                life: 800 + Math.random() * 400,
                                t: 0,
                                isWhiteCircling: false
                            });
                        }
                        showNotification('Ball sticks to the wall!', 'info');
                    } else {
                        ball.vy*=-(ball.bounceDamping || 0.75);
                    }
                    impactWave(ball.x, ball.y, 10);
                }
               
                if(ball.abbyPowerPinActive && now >= ball.abbyPowerPinEndTime) {
                    ball.abbyPowerPinActive = false;
                    showNotification('Power Pin effect ended', 'info');
                }


                const d=Math.hypot(ball.x-player.x, ball.y-player.y);

                const hypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                const abbyDemonDriveLocked = player.abbyDemonDriveActive;
                if (d < player.r + ball.r + 8 && !player.hasBall && !aiPlayer.hasBall &&
                    !player.eddieSymbioteMontageActive && !player.spinning && !player.charging &&
                    !player.telekinising && !player.dashing && !hypnoticLocked && !abbyDemonDriveLocked) {

                    if (aiEnabled) {
                        if (keys['e'] || d < player.r + ball.r + 5) {
                            player.hasBall = true;
                            ball.vx = 0;
                            ball.vy = 0;
                            if (d < player.r + ball.r + 5) {
                                showNotification('Ball collected!', 'success');
                            }
                        }
                    } else {
                        player.hasBall = true;
                        ball.vx = 0;
                        ball.vy = 0;
                    }
                }

                if (currentStyle === 'gojo' && player.gojoLapseBlueActive && player.gojoLapseBlueBall) {
                    const orbitingBall = player.gojoLapseBlueBall;
                    const distToOrbitingBall = Math.hypot(ball.x - orbitingBall.x, ball.y - orbitingBall.y);
                    if (distToOrbitingBall < orbitingBall.r + ball.r) {
                            const orbitHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                            if (!orbitHypnoticLocked) {
                            player.hasBall = true;
                            ball.vx = player.vx;
                            ball.vy = player.vy;
                            const snapDir = Math.atan2(player.y - ball.y, player.x - ball.x);
                            ball.x = player.x + Math.cos(snapDir) * (player.r + ball.r + 4);
                            ball.y = player.y + Math.sin(snapDir) * (player.r + ball.r + 4);

                            for(let i=0; i<10; i++) vfx.gojoLapseBluePullEffect.push(newGojoLapseBluePullParticle(ball.x, ball.y, player.x, player.y));
                            shockwave(ball.x, ball.y, ball.r * 1.5, 'gojo-blue');

                            player.gojoLapseBlueActive = false;
                            player.gojoLapseBlueBall = null;
                        }
                    }
                }


                if (currentStyle === 'robsan' && player.eclipseGraspActive && player.telekinising) {
    const dt_s = dt / 1000;
    const dx = player.x - ball.x;
    const dy = player.y - ball.y;
    const dist = Math.hypot(dx, dy);

    const speed = lerp(24, 8, Math.min(1, dist / 180));
    const moveAmount = speed * dt_s;

    ball.x += (dx / dist) * moveAmount;
    ball.y += (dy / dist) * moveAmount;

    if(Math.random() < 0.3) {
        vfx.robsanVoidPuffs.push(newRobsanVoidPuff(ball.x, ball.y, 'eclipse'));
    }

    if (dist < player.r + ball.r + 4) {
        const eclipseHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
        if (!eclipseHypnoticLocked) {
            player.hasBall = true;
            player.telekinising = false;
            player.eclipseGraspActive = false;
            ball.vx = 0;
            ball.vy = 0;

            shockwave(player.x, player.y, 20, 'eclipse');
            for(let i=0; i<12; i++) {
                vfx.sparks.push(newRobsanParticle(player.x, player.y));
            }
        }
    }
    return;
}

                if (currentStyle === 'zeus' && player.zeusHeavenlyShieldActive) {
                    const distToPlayer = Math.hypot(ball.x - player.x, ball.y - player.y);
                    if (distToPlayer < ZEUS_HEAVENLY_SHIELD_RADIUS + ball.r) {
                        ball.vx *= 0.05;
                        ball.vy *= 0.05;
                    }
                }

                if (currentStyle === 'leonardo' && player.leonardoShieldActive) {
                    const distToPlayer = Math.hypot(ball.x - player.x, ball.y - player.y);
                    if (distToPlayer < LEONARDO_SHIELD_RADIUS + ball.r) {
                        const pullDir = Math.atan2(player.y - ball.y, player.x - ball.x);
                        ball.vx += Math.cos(pullDir) * LEONARDO_SHIELD_PULL_STRENGTH;
                        ball.vy += Math.sin(pullDir) * LEONARDO_SHIELD_PULL_STRENGTH;
                    }
                }
                for (const field of vfx.leonardoPatternField) {
                    const distToField = Math.hypot(ball.x - field.x, ball.y - field.y);
                    if (distToField < field.radius + ball.r) {
                        ball.vx *= 0.95;
                        ball.vy *= 0.95;
                    }
                }
            }
        }


        function shoot(scale){
            if(!player.hasBall) return;
            const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);
            const base=10;
            let power=base*scale;
            
            if (currentStyle === 'lincoln' && player.lincolnGyattShowdownActive) {
                power *= LINCOLN_GYATT_SHOWDOWN_SHOT_MULTIPLIER;
                
                for (let i = 0; i < 20; i++) {
                    const angle = dir + (Math.random() - 0.5) * 0.5;
                    vfx.lincolnGyattParticles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(angle) * (10 + Math.random() * 15),
                        vy: Math.sin(angle) * (10 + Math.random() * 15),
                        life: 1000 + Math.random() * 500,
                        t: 0,
                        size: 6 + Math.random() * 8,
                        hue: 280 + Math.random() * 80
                    });
                }
                showNotification('GYATT POWER SHOT! 5X DAMAGE!', 'success');
            }
            
            ball.vx=Math.cos(dir)*power + player.vx*0.3;
            ball.vy=Math.sin(dir)*power + player.vy*0.3;
            player.hasBall=false;
        }

        function tryKaiser(){
            if(currentStyle !== 'hudson') return;
            const now=performance.now();
            if(now < abilityReadyAt) return;
            if(!player.hasBall) {
                showNotification('hudson impact needs the ball bestie', 'warning');
                return;
            }


            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);
            const launch=22;

            ball.vx = Math.cos(dir)*launch + player.vx*0.25;
            ball.vy = Math.sin(dir)*launch + player.vy*0.25;
            ball.maxSpeed = 100000;
            player.hasBall=false;

            const endTime = now + 450;
            vfx.trail.push({end:endTime, w:16});
            for(let i=0;i<10;i++) vfx.lines.push(newLineBurst(player.x, player.y, dir));
            shockwave(player.x, player.y, 18);
            kaiserSparks(player.x, player.y, dir);

            const newTrails = newHudsonImpactBurst(player.x, player.y, dir);
            vfx.hudsonEmperorDribbleTrail.push(...newTrails);
            vfx.hudsonSpeedLines.push(...newHudsonSpeedLines(player.x, player.y, dir));
            vfx.hudsonEnergyWaves.push(newHudsonEnergyWave(player.x, player.y));

            for(let i = 0; i < 3; i++) {
                setTimeout(() => {
                    if(gameState === 'game') {
                        shockwave(player.x, player.y, 15 + i * 5, 'hudson');
                        vfx.energyResidue.push({
                            x: player.x + (Math.random() - 0.5) * 40,
                            y: player.y + (Math.random() - 0.5) * 40,
                            t: 0, life: 800, r: 3 + Math.random() * 4,
                            color: 'rgba(79, 209, 197,'
                        });
                    }
                }, i * 100);
            }

            const origFric = ball.friction;
            ball.friction = 0.994;
            setTimeout(()=>{ ball.friction = origFric; ball.maxSpeed=18; }, 450);

            abilityReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryHudsonEmperorDribble() {
            if (currentStyle !== 'hudson') return;
            const now = performance.now();
            if (now < hudsonEmperorDribbleReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive || player.hudsonEmperorDribbling) return;

            hudsonEmperorDribbleReadyAt = now + HUDSON_EMPEROR_DRIBBLE_COOLDOWN;
            player.hudsonEmperorDribbling = true;
            player.hudsonEmperorDribbleStartTime = now;
            player.hudsonEmperorDribblePhase = 'left';
            player.hudsonEmperorDribbleStartX = player.x;
            player.hudsonEmperorDribbleStartY = player.y;
            player.hudsonEmperorDribbleMouseDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);

            if (aiEnabled) {
                aiPlayer.isStunned = true;
                aiPlayer.stunEndTime = now + HUDSON_EMPEROR_DRIBBLE_DURATION;
                showNotification('ai got stunned lmao', 'success');
            }

            showNotification('dribbling like an emperor activated', 'success');

            vfx.hudsonEmperorDribbleAura.push({
                x: player.x, y: player.y,
                life: 300, t: 0,
                radius: player.r * 3,
                phase: 'burst'
            });
        }

        function tryRobsanShadowSpiral(){
            if(currentStyle !== 'robsan') return;
            const now=performance.now();
            if(now < shadowSpiralReadyAt) return;
            if(!player.hasBall) {
                showNotification('shadow spiral needs the ball bestie', 'warning');
                return;
            }


            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;


            player.spinning = true;
            player.spinTimer = ROBSAN_SPIN_DURATION;
            player.hasBall = false;

            const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);

            vfx.robsanAura.push({x:player.x, y:player.y, end:now + ROBSAN_SPIN_DURATION * 2, radius:player.r*1.5, t:0, life:ROBSAN_SPIN_DURATION * 2});
            for(let i=0; i<30; i++) {
                const angleOffset = Math.random() * Math.PI * 2;
                const radiusOffset = player.r * (0.5 + Math.random() * 0.5);
                vfx.robsanParticles.push(newRobsanParticle(player.x + Math.cos(angleOffset) * radiusOffset, player.y + Math.sin(angleOffset) * radiusOffset));
            }

            vfx.robsanShadowClones.push(...newRobsanShadowClones(player.x, player.y));
            vfx.robsanVoidRifts.push(newRobsanVoidRift(player.x, player.y));

            vfx.epicExplosions.push({
                x: player.x, y: player.y, t: 0, life: 1500,
                startRadius: 15, endRadius: 120, maxOpacity: 0.9
            });
            vfx.massiveShockwaves.push({
                x: player.x, y: player.y, t: 0, life: 2000,
                startRadius: 20, endRadius: 200, maxOpacity: 0.8
            });
            vfx.particleStorms.push({
                x: player.x, y: player.y, t: 0, life: 3000, intensity: 1.2,
                particles: Array.from({length: 80}, () => ({
                    x: player.x + (Math.random() - 0.5) * 60,
                    y: player.y + (Math.random() - 0.5) * 60,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    r: 2 + Math.random() * 4,
                    color: {r: 68 + Math.random() * 30, g: 10 + Math.random() * 20, b: 107 + Math.random() * 50}
                }))
            });

            for(let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 4;
                const radius = i * 2;
                vfx.robsanParticles.push({
                    x: player.x + Math.cos(angle) * radius,
                    y: player.y + Math.sin(angle) * radius,
                    vx: -Math.sin(angle) * 3,
                    vy: Math.cos(angle) * 3,
                    t: 0, life: 800 + Math.random() * 400,
                    r: 2 + Math.random() * 3,
                    color: 'rgba(68, 10, 107,'
                });
            }

            setTimeout(() => {
                if(gameState !== 'game') return;
                player.spinning = false;
                player.charging = true;
                player.chargeTimer = ROBSAN_CHARGE_DURATION;
                vfx.robsanChargeAura.push({x:player.x, y:player.y, end:performance.now() + ROBSAN_CHARGE_DURATION, radius:player.r*1.2, t:0, life:ROBSAN_CHARGE_DURATION});
            }, ROBSAN_SPIN_DURATION);


            setTimeout(() => {
                if(gameState !== 'game') return;
                player.charging = false;

                const launch = 28;
                ball.vx = Math.cos(dir)*launch + player.vx*0.2;
                ball.vy = Math.sin(dir)*launch + player.vy*0.2;
                ball.maxSpeed = 100000;

                const endTime = performance.now() + 600;
                vfx.shadowTrails.push({end:endTime, w:20});
                shockwave(player.x, player.y, 25, 'robsan');

                for(let i=0; i<5; i++) vfx.robsanGroundRupture.push(newRobsanGroundRupture(player.x, player.y, dir + (Math.random()-0.5)*Math.PI/2));

                vfx.energyNovas.push({
                    x: player.x, y: player.y, t: 0, life: 1200,
                    startRadius: 10, endRadius: 100, maxOpacity: 0.8
                });
                vfx.cosmicRifts.push({
                    x: player.x, y: player.y, t: 0, life: 2500,
                    radius: 60, angle: dir
                });

                const origFric = ball.friction;
                ball.friction = 0.992;
                setTimeout(()=>{ ball.friction = origFric; ball.maxSpeed=18; }, 600);

                player.hasBall = false;

            }, ROBSAN_SPIN_DURATION + ROBSAN_CHARGE_DURATION);

            shadowSpiralReadyAt = now + ABILITY_COOLDOWN;
        }

function tryRobsanEclipseGrasp(){
    if(currentStyle !== 'robsan') return;
    const now = performance.now();
    if(now < eclipseGraspReadyAt) return;
    if(player.hasBall) {
        showNotification('eclipse grasp needs you to not have the ball', 'warning');
        return;
    }

    if (player.spinning || player.charging || player.telekinising || player.dashing ||
        player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
        player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
        player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

    player.telekinising = true;
    player.eclipseGraspActive = true;
    player.hasBall = false;

    vfx.eclipseAura.push({x:player.x, y:player.y, end:now + ECLIPSE_AURA_DURATION * 2, radius:player.r*2, t:0, life:ECLIPSE_AURA_DURATION * 2});
    for(let i=0; i<20; i++) {
        vfx.robsanEclipseWisps.push(newRobsanEclipseWisp(player.x, player.y));
        if(i % 2 === 0) {
            vfx.robsanVoidPuffs.push(newRobsanVoidPuff(player.x, player.y, 'eclipse'));
        }
    }

    const pulseInterval = setInterval(() => {
        if(!player.telekinising || gameState !== 'game') {
            clearInterval(pulseInterval);
            return;
        }
        vfx.robsanVoidPuffs.push(newRobsanVoidPuff(ball.x, ball.y, 'eclipse'));
    }, 100);

    setTimeout(() => {
        clearInterval(pulseInterval);
        if(player.telekinising) {
            player.telekinising = false;
            player.eclipseGraspActive = false;
        }
    }, 3000);

    eclipseGraspReadyAt = now + ABILITY_COOLDOWN;
}
        function tryRobsanVoidDash(){
            if(currentStyle !== 'robsan') return;
            const now = performance.now();
            if(now < voidDashReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.dashing = true;
            player.dashTimer = VOID_DASH_DURATION;

            const dashDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);

            player.vx = Math.cos(dashDir) * VOID_DASH_SPEED;
            player.vy = Math.sin(dashDir) * VOID_DASH_SPEED;

            vfx.voidTrails.push({
                x: player.x, y: player.y,
                end: now + VOID_DASH_DURATION + 100,
                trailColorStart: getComputedStyle(document.documentElement).getPropertyValue('--void-trail-color-start'),
                trailColorEnd: getComputedStyle(document.documentElement).getPropertyValue('--void-trail-color-end'),
                w: player.r * 1.5
            });
            vfx.robsanVoidPuffs.push(newRobsanVoidPuff(player.x, player.y, 'start'));

            vfx.dimensionalTears.push({
                x: player.x, y: player.y, t: 0, life: 800,
                width: 80, height: 15, angle: dashDir
            });
            vfx.epicExplosions.push({
                x: player.x, y: player.y, t: 0, life: 600,
                startRadius: 8, endRadius: 40, maxOpacity: 0.7
            });
            vfx.particleStorms.push({
                x: player.x, y: player.y, t: 0, life: 1000, intensity: 0.8,
                particles: Array.from({length: 40}, () => ({
                    x: player.x + (Math.random() - 0.5) * 30,
                    y: player.y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    r: 1 + Math.random() * 2,
                    color: {r: 30 + Math.random() * 20, g: 27 + Math.random() * 20, b: 75 + Math.random() * 30}
                }))
            });

            setTimeout(() => {
                if(gameState !== 'game') return;
                player.dashing = false;
                player.vx *= 0.2;
                player.vy *= 0.2;
            }, VOID_DASH_DURATION);

            voidDashReadyAt = now + ABILITY_COOLDOWN;
        }


        function tryXDrakeSupernova() {
            if (currentStyle !== 'xdrake') return;
            const now = performance.now();
            if (now < supernovaReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.xdrakeSupernovaDashing = true;
            player.xdrakeSupernovaDashTimer = XDRAKE_SUPERNOVA_DASH_DURATION;

            const dashDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            player.vx = Math.cos(dashDir) * XDRAKE_SUPERNOVA_DASH_SPEED;
            player.vy = Math.sin(dashDir) * XDRAKE_SUPERNOVA_DASH_SPEED;


            vfx.xdrakeSupernovaTrails.push({
                x: player.x, y: player.y,
                end: now + XDRAKE_SUPERNOVA_DASH_DURATION + 100,
                trailColorStart: getComputedStyle(document.documentElement).getPropertyValue('--xdrake-dash-trail-start'),
                trailColorEnd: getComputedStyle(document.documentElement).getPropertyValue('--xdrake-dash-trail-end'),
                w: player.r * 1.8
            });
            shockwave(player.x, player.y, player.r, 'xdrake-supernova');

            vfx.xdrakeSupernovaGroundCrack.push(newXDrakeGroundCrack(player.x, player.y));
            vfx.xdrakeNatureSpirits.push(...newXDrakeNatureSpirits(player.x, player.y));
            vfx.xdrakeTerraforms.push(...newXDrakeTerraform(player.x, player.y, dashDir));

            for(let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                vfx.sparks.push({
                    x: player.x, y: player.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 400 + Math.random() * 300,
                    t: 0, r: 2 + Math.random() * 3,
                    color: 'rgba(34, 197, 94,'
                });
            }

            setTimeout(() => {
                if (gameState !== 'game') return;
                player.xdrakeSupernovaDashing = false;
                player.vx *= 0.2;
                player.vy *= 0.2;
            }, XDRAKE_SUPERNOVA_DASH_DURATION);

            supernovaReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryXDrakeFossilFootwork() {
            if (currentStyle !== 'xdrake') return;
            const now = performance.now();
            if (now < fossilFootworkReadyAt) return;
            if (!player.hasBall) {
                showNotification('fossilised footwork needs the ball bestie', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.xdrakeFossilFootworking = true;
            player.xdrakeFossilFootworkTimer = XDRAKE_FOSSIL_FOOTWORK_DURATION;

            const footworkDir = Math.atan2(mouse.y - player.y, mouse.x - player.x - 0.001);
            player.vx = Math.cos(footworkDir) * XDRAKE_FOSSIL_FOOTWORK_SPEED;
            player.vy = Math.sin(footworkDir) * XDRAKE_FOSSIL_FOOTWORK_SPEED;


            for(let i = 0; i < 8; i++) {
                vfx.xdrakeFootworkDust.push(newXDrakeFootworkParticle(player.x, player.y));
            }
            shockwave(player.x, player.y, player.r * 0.8, 'xdrake-footwork');

            for(let i=0; i<6; i++) vfx.xdrakeFootworkLeaves.push(newXDrakeFootworkLeaf(player.x, player.y, footworkDir));
            impactWave(player.x, player.y, player.r * 0.7);

            setTimeout(() => {
                if (gameState !== 'game') return;
                player.xdrakeFossilFootworking = false;
                player.vx *= 0.3;
                player.vy *= 0.3;
            }, XDRAKE_FOSSIL_FOOTWORK_DURATION);

            fossilFootworkReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryXDrakeAncientApex() {
            if (currentStyle !== 'xdrake') return;
            const now = performance.now();
            if (now < ancientApexReadyAt) return;
            if (!player.hasBall) {
                showNotification('ancient apex needs the ball bestie', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.xdrakeAncientApexCharging = true;
            player.ancientApexChargeTimer = now;


            powerBar.style.opacity = 1;



            ancientApexReadyAt = now + ABILITY_COOLDOWN;
        }

        function xdrakeAncientApexShoot(chargeProgress) {
            if (currentStyle !== 'xdrake' || !player.xdrakeAncientApexCharging) return;
            if (!player.hasBall) {
                player.xdrakeAncientApexCharging = false;
                return;
            }

            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            const launchPower = XDRAKE_ANCIENT_APEX_SHOT_POWER * chargeProgress;

            ball.vx = Math.cos(dir) * launchPower + player.vx * 0.2;
            ball.vy = Math.sin(dir) * launchPower + player.vy * 0.2;
            ball.maxSpeed = 100000;

            player.hasBall = false;
            player.xdrakeAncientApexCharging = false;

            const endTime = performance.now() + 800;
            vfx.xdrakeApexAura.push({
                x: player.x, y: player.y,
                end: endTime,
                radius: player.r * 2,
                t: 0, life: 800
            });
            shockwave(player.x, player.y, 30, 'xdrake-apex');

            for(let i=0; i<10; i++) vfx.xdrakeAncientApexGroundBurst.push(newXDrakeAncientApexGroundBurst(player.x, player.y));

            const origFric = ball.friction;
            ball.friction = 0.99;
            setTimeout(() => { ball.friction = origFric; ball.maxSpeed = 18; }, 800);
            endCharge();
        }


        function tryGojoRed() {
            if (currentStyle !== 'gojo') return;
            const now = performance.now();
            if (now < gojoRedReadyAt) return;
            if (!player.hasBall) {
                showNotification('red needs the ball bestie', 'warning');
                return;
            }


            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.gojoRedCharging = true;
            player.gojoRedChargeStartTime = now;


            powerBar.style.opacity = 1;


            autoTimer = setTimeout(() => {
                if (gameState !== 'game' || !player.gojoRedCharging) return;

                const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);

                ball.vx = Math.cos(dir) * GOJO_RED_SHOT_POWER + player.vx * 0.2;
                ball.vy = Math.sin(dir) * GOJO_RED_SHOT_POWER + player.vy * 0.2;
                ball.maxSpeed = 100000;

                player.hasBall = false;
                player.gojoRedCharging = false;
                player.gojoRedActive = true;

                vfx.gojoRedTrail.push({
                    end: now + 500,
                    w: 18,
                    colorStart: getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-trail-start'),
                    colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-trail-end')
                });
                shockwave(player.x, player.y, player.r, 'gojo-red');

                vfx.gojoRedExplosion.push(newGojoRedExplosion(player.x, player.y));

                const origFric = ball.friction;
                ball.friction = 0.99;
                setTimeout(() => {
                    if (gameState !== 'game') return;
                    ball.friction = origFric;
                    ball.maxSpeed = 18;
                    player.gojoRedActive = false;
                }, 500);
                endCharge();
            }, GOJO_RED_CHARGE_DURATION);

            gojoRedReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryGojoLapseBlue() {
            if (currentStyle !== 'gojo') return;
            const now = performance.now();
            if (now < gojoLapseBlueReadyAt) return;
            if (player.hasBall) {
                showNotification('lapse blue needs you to not have the ball', 'warning');
                return;
            }


            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.gojoLapseBlueActive = true;
            player.gojoLapseBlueBall = {
                x: player.x + GOJO_LAPSE_BLUE_ORBIT_RADIUS,
                y: player.y,
                r: GOJO_LAPSE_BLUE_BALL_RADIUS,
                angle: 0,
                orbitRadius: GOJO_LAPSE_BLUE_ORBIT_RADIUS,
                speed: GOJO_LAPSE_BLUE_ORBIT_SPEED,
                originTime: now,
                lifeTime: ABILITY_COOLDOWN * 0.8
            };


            for(let i=0; i<15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.5 + Math.random() * 1.5;
                const life = 200 + Math.random() * 300;
                vfx.sparks.push({x: player.x, y: player.y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life, t:0, r:2+Math.random()*2, color:'rgba(49, 130, 206,'});
            }
            shockwave(player.x, player.y, player.r * 1.2, 'gojo-blue');

            vfx.gojoInfinityBarriers.push(...newGojoInfinityBarrier(player.x, player.y));
            vfx.gojoDomainExpansions.push(newGojoDomainExpansion(player.x, player.y));

            setTimeout(() => {
                if(gameState !== 'game') return;
                player.gojoLapseBlueActive = false;
                player.gojoLapseBlueBall = null;
            }, player.gojoLapseBlueBall.lifeTime);

            gojoLapseBlueReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryGojoPurple() {
            if (currentStyle !== 'gojo') return;
            const now = performance.now();
            if (now < gojoPurpleReadyAt) return;
            if (!player.hasBall) {
                showNotification('purple needs the ball bestie', 'warning');
                return;
            }


            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.gojoPurpleActive = true;
            player.hasBall = false;

            player.gojoPurpleInitialDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);


            const dir = player.gojoPurpleInitialDir;
            const spreadDist = GOJO_PURPLE_SPREAD_DISTANCE;
            const leftSpreadX = player.x + Math.cos(dir - Math.PI/2) * spreadDist;
            const leftSpreadY = player.y + Math.sin(dir - Math.PI/2) * spreadDist;
            const rightSpreadX = player.x + Math.cos(dir + Math.PI/2) * spreadDist;
            const rightSpreadY = player.y + Math.sin(dir + Math.PI/2) * spreadDist;

            player.gojoPurpleLeftBall = {
                x: leftSpreadX,
                y: leftSpreadY,
                r: GOJO_LAPSE_BLUE_BALL_RADIUS * 0.8,
                vx: 0, vy: 0,
                color: 'var(--gojo-red-primary)'
            };

            player.gojoPurpleRightBall = {
                x: rightSpreadX,
                y: rightSpreadY,
                r: GOJO_LAPSE_BLUE_BALL_RADIUS * 0.8,
                vx: 0, vy: 0,
                color: 'var(--gojo-blue-primary)'
            };
            player.gojoPurpleConverging = true;
            player.gojoPurpleConvergenceStartTime = now;
            player.gojoPurpleShotFired = false;

            gojoPurpleReadyAt = now + ABILITY_COOLDOWN * 2;
        }

        function shootPurpleShot(x, y, initialMouseDir) {
            const dir = initialMouseDir;
            ball.vx = Math.cos(dir) * GOJO_PURPLE_FINAL_SHOT_POWER;
            ball.vy = Math.sin(dir) * GOJO_PURPLE_FINAL_SHOT_POWER;
            ball.maxSpeed = 100000;


            ball.x = x;
            ball.y = y;


            player.hasBall = false;

            vfx.gojoPurpleTrail.push({
                x: x, y: y,
                end: performance.now() + 1000,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--gojo-purple-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--gojo-purple-trail-end'),
                w: 30
            });

            const origFric = ball.friction;
            ball.friction = 0.99;
            setTimeout(() => {
                if (gameState !== 'game') return;
                ball.friction = origFric;
                ball.maxSpeed = 18;
            }, 1000);
        }

        function tryEddieWeAre() {
            if (currentStyle !== 'eddie') return;
            const now = performance.now();
            if (now < eddieWeAreReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;


            player.eddieWeAreActive = true;
            player.eddieWeAreOriginalMaxSpd = player.maxSpd;
            player.maxSpd *= EDDIE_WE_ARE_SPEED_BOOST;
            player.eddieWeAreEndTime = now + EDDIE_WE_ARE_DURATION;

            vfx.eddieWeAreAura.push({
                x: player.x, y: player.y,
                end: player.eddieWeAreEndTime,
                radius: player.r * 1.5,
                t: 0, life: EDDIE_WE_ARE_DURATION
            });
            for(let i=0; i<20; i++) {
                vfx.eddieWeAreParticles.push(newEddieWeAreParticle(player.x, player.y));
            }

            vfx.eddieWeAreRipples.push(newEddieWeAreRipple(player.x, player.y));
            vfx.eddieSymbioteSpikes.push(...newEddieSymbioteSpikes(player.x, player.y));
            vfx.eddieVenomDrops.push(...newEddieVenomDrops(player.x, player.y));

            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                vfx.eddieVenomTendrils.push({
                    startX: player.x,
                    startY: player.y,
                    endX: player.x + Math.cos(angle) * 40,
                    endY: player.y + Math.sin(angle) * 40,
                    t: 0, life: 600,
                    wiggleFreq: 0.2, wiggleAmp: 5
                });
            }

            eddieWeAreReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryEddieVenomStrike() {
            if (currentStyle !== 'eddie') return;
            const now = performance.now();
            if (now < eddieVenomStrikeReadyAt) return;
            if (player.hasBall) {
                showNotification('venom strike needs you to not have the ball', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;


            player.eddieVenomStrikeActive = true;

            vfx.eddieVenomTendrils.push({
                startX: player.x, startY: player.y,
                endX: ball.x, endY: ball.y,
                t: 0, life: 1000,
                wiggleFreq: 0.1, wiggleAmp: 8
            });

            eddieVenomStrikeReadyAt = now + ABILITY_COOLDOWN;
        }

        function startNewSymbioteMontageTeleport() {
            const now = performance.now();
            const minX = margin + player.r;
            const maxX = W - margin - player.r;
            const minY = margin + player.r;
            const maxY = H - margin - player.r;

            const targetX = minX + Math.random() * (maxX - minX);
            const targetY = minY + Math.random() * (maxY - minY);

            player.eddieSymbioteMontageCurrentTeleportTarget = {x: targetX, y: targetY};
            player.eddieSymbioteMontageTeleportStartTime = now;

            const dist = Math.hypot(player.x - targetX, player.y - targetY);
            const teleportDuration = Math.max(100, Math.min(500, dist / EDDIE_SYMBIOTE_MONTAGE_TELEPORT_SPEED * 1000));
            player.eddieSymbioteMontageTeleportEndTime = now + teleportDuration;
            player.eddieSymbioteMontageStartPlayerPos = {x: player.x, y: player.y};
            player.hasBall = true;

            shockwave(player.x, player.y, player.r, 'eddie-montage');
            vfx.eddieTeleportFlicker.push(newEddieTeleportFlicker(player.x, player.y));
        }


        function tryEddieSymbioteMontage() {
            if (currentStyle !== 'eddie') return;
            const now = performance.now();
            if (now < eddieSymbioteMontageReadyAt) return;
            if (!player.hasBall) {
                showNotification('symbiote montage needs the ball bestie', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.eddieSymbioteMontageActive = true;
            player.eddieSymbioteMontagePhase = 'teleporting';
            player.eddieSymbioteMontageTeleportCount = 0;
            player.eddieSymbioteMontageAimStartTime = 0;
            player.eddieSymbioteMontageShotFired = false;

            startNewSymbioteMontageTeleport();

            eddieSymbioteMontageReadyAt = now + ABILITY_COOLDOWN * 2;
        }

        function tryEddieVenomDevastation() {
            if (currentStyle !== 'eddie' || !player.eddieAwakeningActive) return;
            const now = performance.now();
            if (now < eddieWeAreReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.eddieWeAreActive = true;
            player.eddieWeAreOriginalMaxSpd = player.maxSpd;
            player.maxSpd *= EDDIE_WE_ARE_SPEED_BOOST * 2;
            player.eddieWeAreEndTime = now + EDDIE_WE_ARE_DURATION * 2;

            vfx.eddieWeAreAura.push({
                x: player.x, y: player.y,
                end: player.eddieWeAreEndTime,
                radius: player.r * 4,
                t: 0, life: EDDIE_WE_ARE_DURATION * 2,
                awakening: true
            });

            for(let i=0; i<60; i++) {
                vfx.eddieWeAreParticles.push(newEddieWeAreParticle(player.x, player.y));
            }

            for(let i=0; i<5; i++) {
                setTimeout(() => {
                    vfx.eddieWeAreRipples.push(newEddieWeAreRipple(player.x, player.y));
                }, i * 200);
            }

            vfx.eddieSymbioteSpikes.push(...newEddieSymbioteSpikes(player.x, player.y));
            vfx.eddieVenomDrops.push(...newEddieVenomDrops(player.x, player.y));

            for(let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                vfx.eddieVenomTendrils.push({
                    startX: player.x,
                    startY: player.y,
                    endX: player.x + Math.cos(angle) * 80,
                    endY: player.y + Math.sin(angle) * 80,
                    t: 0, life: 1200,
                    wiggleFreq: 0.3, wiggleAmp: 10,
                    awakening: true
                });
            }

            eddieWeAreReadyAt = now + ABILITY_COOLDOWN * 0.5;
        }

        function tryEddieShadowRealm() {
            if (currentStyle !== 'eddie' || !player.eddieAwakeningActive) return;
            const now = performance.now();
            if (now < eddieVenomStrikeReadyAt) return;
            if (player.hasBall) {
                showNotification('shadow realm needs you to not have the ball', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.eddieVenomStrikeActive = true;

            for(let i = 0; i < 8; i++) {
                const offsetX = (Math.random() - 0.5) * 20;
                const offsetY = (Math.random() - 0.5) * 20;
                vfx.eddieVenomTendrils.push({
                    startX: player.x + offsetX, startY: player.y + offsetY,
                    endX: ball.x, endY: ball.y,
                    t: 0, life: 1500,
                    wiggleFreq: 0.2, wiggleAmp: 12,
                    awakening: true
                });
            }

            setTimeout(() => {
                if (gameState !== 'game') return;
                ball.x = W - margin - goalDepth + 5;
                ball.y = H/2;
                ball.vx = 15;
                ball.vy = 0;

                shockwave(ball.x, ball.y, 50, 'eddie-venom');
                for(let i=0; i<30; i++) {
                    vfx.eddieWeAreParticles.push(newEddieWeAreParticle(ball.x, ball.y));
                }
            }, 500);

            eddieVenomStrikeReadyAt = now + ABILITY_COOLDOWN * 0.3;
        }

        function tryRabiesRagebait() {
            if (currentStyle !== 'rabies') return;
            const now = performance.now();
            if (now < rabiesRagebaitReadyAt) {
                const cooldownLeft = Math.ceil((rabiesRagebaitReadyAt - now) / 1000);
                showNotification(`Ragebait cooldown: ${cooldownLeft}s`, 'warning');
                return;
            }
            
            // Ball attraction from long range
            const dist = Math.hypot(ball.x - player.x, ball.y - player.y);
            if (dist > 200) {
                // Long range ball pull
                const pullDir = Math.atan2(player.y - ball.y, player.x - ball.x);
                ball.vx = Math.cos(pullDir) * 25;
                ball.vy = Math.sin(pullDir) * 25;
                
                // Add attraction trail
                for (let i = 0; i < 15; i++) {
                    vfx.rabiesRagebaitTrail.push({
                        x: ball.x + (Math.random() - 0.5) * 20,
                        y: ball.y + (Math.random() - 0.5) * 20,
                        vx: Math.cos(pullDir + (Math.random() - 0.5) * 0.5) * 12,
                        vy: Math.sin(pullDir + (Math.random() - 0.5) * 0.5) * 12,
                        life: 600 + Math.random() * 200,
                        t: 0,
                        color: 'var(--rabies-ragebait-trail-start)',
                        w: 3 + Math.random() * 4
                    });
                }
            }
            
            if (!player.hasBall) {
                showNotification('Ragebait needs the ball!', 'warning');
                return;
            }
            
            // Super fast red shot
            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            const shotPower = 35; // Very fast
            
            ball.vx = Math.cos(dir) * shotPower + player.vx * 0.3;
            ball.vy = Math.sin(dir) * shotPower + player.vy * 0.3;
            ball.maxSpeed = 100000;
            player.hasBall = false;
            
            // Activate 4 curved lines following the ball for 5 seconds
            vfx.rabiesRagebaitBallLines.push({
                t: 0,
                life: 5000, // 5 seconds of ball following lines
                activated: true
            });
            
            // Red trail effect
            for (let i = 0; i < 20; i++) {
                vfx.rabiesRagebaitTrail.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(dir) * (15 + Math.random() * 10) + (Math.random() - 0.5) * 8,
                    vy: Math.sin(dir) * (15 + Math.random() * 10) + (Math.random() - 0.5) * 8,
                    life: 800 + Math.random() * 400,
                    t: 0,
                    color: Math.random() > 0.5 ? 'var(--rabies-ragebait-trail-start)' : 'var(--rabies-ragebait-trail-end)',
                    w: 6 + Math.random() * 8
                });
            }

            // Add lots of red thin spaced lines VFX
            const baseRadius = 40;
            for (let layer = 0; layer < 4; layer++) {
                const radius = baseRadius + layer * 15;
                const linesInLayer = 12 + layer * 6; // More lines in outer layers
                for (let i = 0; i < linesInLayer; i++) {
                    const angle = (i / linesInLayer) * Math.PI * 2;
                    const lineLength = 20 + Math.random() * 15;
                    const startX = player.x + Math.cos(angle) * radius;
                    const startY = player.y + Math.sin(angle) * radius;
                    const endX = startX + Math.cos(angle) * lineLength;
                    const endY = startY + Math.sin(angle) * lineLength;
                    
                    vfx.rabiesRagebaitTrail.push({
                        x: startX,
                        y: startY,
                        vx: Math.cos(angle) * (2 + Math.random() * 3),
                        vy: Math.sin(angle) * (2 + Math.random() * 3),
                        life: 1200 + Math.random() * 600,
                        t: 0,
                        color: 'var(--rabies-ragebait-trail-start)',
                        w: 1 + Math.random() * 2,
                        isThinLine: true,
                        endX: endX,
                        endY: endY,
                        delay: layer * 50 + i * 10 // Stagger appearance
                    });
                }
            }
            
            // Angry vein effects (4 red right angles)
            for (let i = 0; i < 4; i++) {
                const angle = i * (Math.PI / 2) + Math.PI / 4; // 45, 135, 225, 315 degrees
                const baseX = player.x + Math.cos(angle) * 25;
                const baseY = player.y + Math.sin(angle) * 25;
                
                vfx.rabiesRagebaitVeins.push({
                    x: baseX,
                    y: baseY,
                    angle: angle,
                    life: 1000,
                    t: 0,
                    intensity: 0.9,
                    size: 15 + Math.random() * 10
                });
            }
            
            shockwave(player.x, player.y, 22, 'rabies-ragebait');
            showNotification('RAGEBAIT!', 'success');
            rabiesRagebaitReadyAt = now + RABIES_RAGEBAIT_COOLDOWN;
        }

        function tryRabiesSquidGlaze() {
            if (currentStyle !== 'rabies') return;
            const now = performance.now();
            if (now < rabiesSquidGlazeReadyAt) {
                const cooldownLeft = Math.ceil((rabiesSquidGlazeReadyAt - now) / 1000);
                showNotification(`Squid Glaze cooldown: ${cooldownLeft}s`, 'warning');
                return;
            }
            
            if (!player.hasBall) {
                showNotification('Squid Glaze needs the ball!', 'warning');
                return;
            }
            
            // Tentacle effects
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + Math.random() * 0.3;
                const dist = 30 + Math.random() * 25;
                
                vfx.rabiesSquidTentacles.push({
                    x1: player.x,
                    y1: player.y,
                    x2: player.x + Math.cos(angle) * dist,
                    y2: player.y + Math.sin(angle) * dist,
                    life: 1200,
                    t: 0,
                    wobble: Math.random() * 0.5
                });
            }
            
            // Launch ball and make it sticky
            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            const shotPower = 20;
            
            ball.vx = Math.cos(dir) * shotPower + player.vx * 0.3;
            ball.vy = Math.sin(dir) * shotPower + player.vy * 0.3;
            ball.squidGlazed = true;
            ball.squidGlazeEndTime = now + 5000; // 5 seconds
            player.hasBall = false;
            
            // Squid glaze particles
            for (let i = 0; i < 25; i++) {
                vfx.rabiesSquidGlaze.push({
                    x: ball.x + (Math.random() - 0.5) * 30,
                    y: ball.y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    r: 2 + Math.random() * 4,
                    life: 1000 + Math.random() * 500,
                    t: 0
                });
            }
            
            showNotification('SQUID GLAZE! Ball is sticky for 5 seconds!', 'success');
            rabiesSquidGlazeReadyAt = now + RABIES_SQUID_GLAZE_COOLDOWN;
        }

        function tryRabiesStealBallrot() {
            if (currentStyle !== 'rabies') return;
            const now = performance.now();
            if (now < rabiesStealBallrotReadyAt) {
                const cooldownLeft = Math.ceil((rabiesStealBallrotReadyAt - now) / 1000);
                showNotification(`Steal a Ballrot cooldown: ${cooldownLeft}s`, 'warning');
                return;
            }
            
            if (player.hasBall) {
                showNotification('You already have the ball!', 'info');
                return;
            }
            
            // Create extending tentacles that grow toward the ball
            const dist = Math.hypot(ball.x - player.x, ball.y - player.y);
            const tentacleDir = Math.atan2(ball.y - player.y, ball.x - player.x);
            const extensionDuration = 800; // Time to extend to ball
            
            for (let i = 0; i < 6; i++) {
                const angleOffset = (i - 2.5) * 0.4; // Spread tentacles
                const angle = tentacleDir + angleOffset;
                const segmentCount = Math.max(4, Math.ceil(dist / 15));
                
                vfx.rabiesStealTentacles.push({
                    x: player.x + Math.cos(angle) * 15,
                    y: player.y + Math.sin(angle) * 15,
                    targetX: ball.x + Math.cos(angle) * 5, // Initial target (will be updated)
                    targetY: ball.y + Math.sin(angle) * 5,
                    originalAngleOffset: angleOffset, // Store the original offset for tracking
                    life: extensionDuration + 1000, // Total life
                    t: 0,
                    width: 1.5 + Math.random() * 1.5,
                    segments: segmentCount,
                    grabbing: true,
                    isExtending: true, // New flag for extension phase
                    extensionDuration: extensionDuration,
                    isSquiggly: true,
                    squigglePhase: i * Math.PI / 3,
                    hasReachedBall: false
                });
            }
            
            // After tentacles extend, create liquid circle effect and pull ball back
            setTimeout(() => {
                // Use ball's CURRENT position, not original position
                const currentBallX = ball.x;
                const currentBallY = ball.y;
                
                // Create white liquid circle effect around ball's current position
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 / 20) * i;
                    const radius = ball.r + 5 + Math.random() * 10;
                    vfx.rabiesStealTentacles.push({
                        x: currentBallX + Math.cos(angle) * radius,
                        y: currentBallY + Math.sin(angle) * radius,
                        targetX: currentBallX,
                        targetY: currentBallY,
                        life: 800,
                        t: 0,
                        width: 3 + Math.random() * 4,
                        segments: 1,
                        grabbing: false,
                        isLiquidCircle: true, // New flag for liquid effect
                        liquidRadius: radius,
                        liquidPhase: i * (Math.PI / 10),
                        contractionSpeed: 0.02 + Math.random() * 0.01
                    });
                }
                
                // Add extra liquid particles for more fluid effect
                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = ball.r + Math.random() * 25;
                    vfx.rabiesStealTentacles.push({
                        x: currentBallX + Math.cos(angle) * radius,
                        y: currentBallY + Math.sin(angle) * radius,
                        targetX: currentBallX,
                        targetY: currentBallY,
                        life: 600 + Math.random() * 400,
                        t: 0,
                        width: 2 + Math.random() * 3,
                        segments: 1,
                        grabbing: false,
                        isLiquidParticle: true, // New flag for liquid particles
                        liquidFlowSpeed: 0.03 + Math.random() * 0.02
                    });
                }
                
                // Start ball tween back to player with liquid trail
                ball.tweenToPlayer = true;
                ball.tweenStartX = currentBallX;  // Use current position
                ball.tweenStartY = currentBallY;  // Use current position
                ball.tweenTargetX = player.x;
                ball.tweenTargetY = player.y;
                ball.tweenStartTime = performance.now();
                ball.tweenDuration = 700; // Smooth return
                
                // Create liquid trail as ball moves back
                const trailInterval = setInterval(() => {
                    if (!ball.tweenToPlayer) {
                        clearInterval(trailInterval);
                        return;
                    }
                    
                    for (let i = 0; i < 3; i++) {
                        const spread = 8 + Math.random() * 12;
                        vfx.rabiesStealTentacles.push({
                            x: ball.x + (Math.random() - 0.5) * spread,
                            y: ball.y + (Math.random() - 0.5) * spread,
                            targetX: ball.x,
                            targetY: ball.y,
                            life: 400 + Math.random() * 300,
                            t: 0,
                            width: 2 + Math.random() * 2,
                            segments: 1,
                            grabbing: false,
                            isLiquidTrail: true // New flag for trailing liquid
                        });
                    }
                }, 50);
                
                // Give player the ball after tween completes
                setTimeout(() => {
                    player.hasBall = true;
                    ball.vx = 0;
                    ball.vy = 0;
                    ball.tweenToPlayer = false;
                    showNotification('STOLEN WITH LIQUID POWER!', 'success');
                }, 700);
                
            }, extensionDuration); // Wait for tentacles to reach ball
            
            showNotification('STEAL A BALLROT! Tentacles extending...', 'info');
            rabiesStealBallrotReadyAt = now + RABIES_STEAL_BALLROT_COOLDOWN;
        }

        function tryRabiesPookiePower() {
            if (currentStyle !== 'rabies') return;
            const now = performance.now();
            if (now < rabiesPookiePowerReadyAt) {
                const cooldownLeft = Math.ceil((rabiesPookiePowerReadyAt - now) / 1000);
                showNotification(`Pookie Power cooldown: ${cooldownLeft}s`, 'warning');
                return;
            }
            
            if (!player.hasBall) {
                showNotification('Pookie Power needs the ball!', 'warning');
                return;
            }
            
            // Set pookie power active state to prevent charging/movement restrictions
            player.rabiesPookiePowerActive = true;
            player.rabiesPookiePowerEndTime = now + 2500; // Active during the 2.5 second charge time
            
            // Spawn 3 pfps behind player with actual images (BIGGER!)
            for (let i = 0; i < 3; i++) {
                const angle = Math.PI + (i - 1) * 0.8; // Behind player, spread out
                vfx.rabiesPookiePowerPfps.push({
                    x: player.x + Math.cos(angle) * (50 + i * 20),
                    y: player.y + Math.sin(angle) * (50 + i * 20),
                    image: pookieImageList[i],
                    life: 3000, // Extended life to stay visible longer
                    t: 0,
                    scale: 1.5 + i * 0.2, // Much bigger images!
                    energy: 1.0,
                    pulsePhase: i * Math.PI * 0.5 // Different pulse timing
                });
            }
            
            // MASSIVE enhanced power aura with way more particles
            for (let i = 0; i < 80; i++) { // Increased from 50 to 80
                const distance = 60 + Math.random() * 100; // Bigger spread
                const angle = Math.random() * Math.PI * 2;
                vfx.rabiesPookiePowerAura.push({
                    x: player.x + Math.cos(angle) * distance,
                    y: player.y + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * (8 + Math.random() * 12), // Faster movement
                    vy: Math.sin(angle) * (8 + Math.random() * 12),
                    life: 2200 + Math.random() * 800,
                    t: 0,
                    color: Math.random() > 0.5 ? 'var(--rabies-pookie-power-aura)' : 'var(--rabies-pookie-power-energy)',
                    size: 12 + Math.random() * 18, // Bigger particles
                    isPookieAura: true,
                    intensity: 0.8 + Math.random() * 0.4
                });
            }

            // Add spiral energy rings around each PFP - ENHANCED
            for (let pfpIndex = 0; pfpIndex < 3; pfpIndex++) {
                const angle = Math.PI + (pfpIndex - 1) * 0.8;
                const pfpX = player.x + Math.cos(angle) * (50 + pfpIndex * 20);
                const pfpY = player.y + Math.sin(angle) * (50 + pfpIndex * 20);
                
                // More rings with more particles
                for (let ring = 0; ring < 5; ring++) { // Increased from 3 to 5 rings
                    const ringRadius = 25 + ring * 12;
                    const particlesInRing = 12; // Increased from 8 to 12
                    for (let p = 0; p < particlesInRing; p++) {
                        const ringAngle = (p / particlesInRing) * Math.PI * 2;
                        vfx.rabiesPookiePowerAura.push({
                            x: pfpX + Math.cos(ringAngle) * ringRadius,
                            y: pfpY + Math.sin(ringAngle) * ringRadius,
                            vx: Math.cos(ringAngle) * (4 + ring * 1.5),
                            vy: Math.sin(ringAngle) * (4 + ring * 1.5),
                            life: 1400 + ring * 250,
                            t: 0,
                            color: 'var(--rabies-pookie-power-energy)',
                            size: 5 + ring * 2.5,
                            isRingVfx: true,
                            ringIndex: ring,
                            delay: pfpIndex * 150 + ring * 80, // Staggered appearance
                            rotation: Math.random() * Math.PI * 2
                        });
                    }
                }
            }
            
            // Add POWER LIGHTNING between PFPs and player
            for (let pfpIndex = 0; pfpIndex < 3; pfpIndex++) {
                const angle = Math.PI + (pfpIndex - 1) * 0.8;
                const pfpX = player.x + Math.cos(angle) * (50 + pfpIndex * 20);
                const pfpY = player.y + Math.sin(angle) * (50 + pfpIndex * 20);
                
                for (let bolt = 0; bolt < 8; bolt++) {
                    const progress = (bolt + 1) / 9;
                    const lightningX = player.x + (pfpX - player.x) * progress;
                    const lightningY = player.y + (pfpY - player.y) * progress;
                    
                    vfx.rabiesPookiePowerAura.push({
                        x: lightningX + (Math.random() - 0.5) * 15,
                        y: lightningY + (Math.random() - 0.5) * 15,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        life: 800 + Math.random() * 400,
                        t: 0,
                        color: 'rgba(255, 255, 255, 0.9)',
                        size: 3 + Math.random() * 4,
                        isLightning: true,
                        intensity: 0.9 + Math.random() * 0.3,
                        delay: pfpIndex * 100 + bolt * 50
                    });
                }
            }
            
            // Add ENERGY WAVES emanating from player
            for (let wave = 0; wave < 4; wave++) {
                const waveDelay = wave * 300;
                setTimeout(() => {
                    for (let i = 0; i < 20; i++) {
                        const waveAngle = (i / 20) * Math.PI * 2;
                        const waveDistance = 30 + wave * 15;
                        vfx.rabiesPookiePowerAura.push({
                            x: player.x + Math.cos(waveAngle) * waveDistance,
                            y: player.y + Math.sin(waveAngle) * waveDistance,
                            vx: Math.cos(waveAngle) * (15 + wave * 3),
                            vy: Math.sin(waveAngle) * (15 + wave * 3),
                            life: 1000 + Math.random() * 500,
                            t: 0,
                            color: 'var(--rabies-pookie-power-energy)',
                            size: 8 + wave * 3,
                            isEnergyWave: true,
                            waveIndex: wave,
                            intensity: 1.0
                        });
                    }
                }, waveDelay);
            }
            
            // Add BALL ENERGY CHARGING effect
            for (let i = 0; i < 30; i++) {
                const chargeAngle = Math.random() * Math.PI * 2;
                const chargeRadius = 15 + Math.random() * 10;
                vfx.rabiesPookiePowerAura.push({
                    x: ball.x + Math.cos(chargeAngle) * chargeRadius,
                    y: ball.y + Math.sin(chargeAngle) * chargeRadius,
                    vx: Math.cos(chargeAngle) * -2, // Pull toward ball
                    vy: Math.sin(chargeAngle) * -2,
                    life: 1800 + Math.random() * 400,
                    t: 0,
                    color: 'rgba(255, 255, 255, 0.8)',
                    size: 4 + Math.random() * 6,
                    isBallCharge: true,
                    intensity: 0.9
                });
            }
            
            // POOKIE POWER SHOT after 2 seconds (while pookies are still there!)
            setTimeout(() => {
                if (player.hasBall) {
                    const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                    const shotPower = 60; // Even more powerful!
                    
                    // Add MASSIVE shot VFX burst
                    for (let i = 0; i < 40; i++) {
                        const burstAngle = dir + (Math.random() - 0.5) * Math.PI * 0.5;
                        const burstSpeed = 20 + Math.random() * 25;
                        vfx.rabiesPookiePowerAura.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(burstAngle) * burstSpeed,
                            vy: Math.sin(burstAngle) * burstSpeed,
                            life: 600 + Math.random() * 400,
                            t: 0,
                            color: 'rgba(255, 255, 255, 1.0)',
                            size: 8 + Math.random() * 12,
                            isShotBurst: true,
                            intensity: 1.2
                        });
                    }
                    
                    ball.vx = Math.cos(dir) * shotPower + player.vx * 0.3;
                    ball.vy = Math.sin(dir) * shotPower + player.vy * 0.3;
                    ball.maxSpeed = 100000;
                    player.hasBall = false;
                    
                    showNotification('POOKIE POWER MEGA SHOT!', 'success');
                }
            }, 2000); // Changed from 3000ms to 2000ms (2 seconds)
            
            showNotification('POOKIE POWER! Charging mega shot...', 'info');
            rabiesPookiePowerReadyAt = now + RABIES_POOKIE_POWER_COOLDOWN;
        }

        function try67KidMayhem() {
            const now = performance.now();
            if (currentStyle !== '67kid') return;

            if (now < sixtySevenKidMayhemReadyAt) {
                const cooldownLeft = Math.ceil((sixtySevenKidMayhemReadyAt - now) / 1000);
                showNotification(`67 Mayhem on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('67 kid needs the ball for 67 Mayhem!', 'warning');
                return;
            }

            sixtySevenKidMayhemReadyAt = now + SIXTY_SEVEN_KID_MAYHEM_COOLDOWN;
            
            player._frozenFor67Mayhem = true;
            player._67MayhemStartTime = now;
            player._67MayhemPhase = 'text_spawning';
            
            player._67MayhemOriginalX = player.x;
            player._67MayhemOriginalY = player.y;
            
            for (let i = 0; i < 80; i++) {
                vfx.sixtySevenKidTextClones.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: SIXTY_SEVEN_KID_MAYHEM_67_DISPLAY_DURATION,
                    t: 0,
                    text: '67',
                    size: 0.5 + Math.random() * 0.8,
                    color: Math.random() > 0.5 ? '#00bcd4' : '#2196f3',
                    opacity: 0.9 + Math.random() * 0.1,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02
                });
            }
            
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const distance = 50 + Math.random() * 30;
                vfx.sixtySevenKidMayhemAura.push({
                    x: player.x + Math.cos(angle) * distance,
                    y: player.y + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    life: SIXTY_SEVEN_KID_MAYHEM_67_DISPLAY_DURATION,
                    t: 0,
                    radius: 20 + Math.random() * 15,
                    intensity: 0.7 + Math.random() * 0.3
                });
            }
            
            setTimeout(() => {
                if (gameState !== 'game' || currentStyle !== '67kid') return;
                
                player._67MayhemPhase = 'blackout';
                
                vfx.sixtySevenKidBlackoutOverlay.push({
                    life: SIXTY_SEVEN_KID_MAYHEM_BLACKOUT_DURATION,
                    t: 0,
                    opacity: 1.0
                });
                
                vfx.sixtySevenKidTextClones = [];
                
                setTimeout(() => {
                    if (gameState !== 'game' || currentStyle !== '67kid') return;
                    
                    ball.x = W - margin - goalDepth + 5;
                    ball.y = H / 2;
                    ball.vx = 0;
                    ball.vy = 0;
                    player.hasBall = false;
                    
                    vfx.sixtySevenKidBlackoutOverlay = [];
                    
                    showNotification('AUTO GOAL!', 'success');
                    
                    setTimeout(() => {
                        player._frozenFor67Mayhem = false;
                        player._67MayhemPhase = '';
                    }, 200);
                    
                }, SIXTY_SEVEN_KID_MAYHEM_BLACKOUT_DURATION);
                
            }, SIXTY_SEVEN_KID_MAYHEM_67_DISPLAY_DURATION);
            
            showNotification('67 MAYHEM ACTIVATED!', 'success');
        }

        function tryWallyRocketBoost() {
            const now = performance.now();
            if (now < wallyRocketBoostReadyAt) {
                const cooldownLeft = Math.ceil((wallyRocketBoostReadyAt - now) / 1000);
                showNotification(`Rocket Boost on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            wallyRocketBoostReadyAt = now + WALLY_ROCKET_BOOST_COOLDOWN;
            player.wallyRocketBoostActive = true;
            player.wallyRocketBoostEndTime = now + WALLY_ROCKET_BOOST_DURATION;

            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const distance = Math.hypot(dx, dy);
            
            if (distance > 0) {
                const moveDistance = 200;
                const dirX = dx / distance;
                const dirY = dy / distance;
                
                player.wallyRocketBoostStartX = player.x;
                player.wallyRocketBoostStartY = player.y;
                player.wallyRocketBoostTargetX = player.x + (dirX * moveDistance);
                player.wallyRocketBoostTargetY = player.y + (dirY * moveDistance);
                
                player.wallyRocketBoostTargetX = Math.max(player.r, Math.min(W - player.r, player.wallyRocketBoostTargetX));
                player.wallyRocketBoostTargetY = Math.max(player.r, Math.min(H - player.r, player.wallyRocketBoostTargetY));

                for (let i = 0; i < 20; i++) {
                    const angle = Math.atan2(dy, dx) + Math.PI + (Math.random() - 0.5) * 0.5;
                    const speed = 8 + Math.random() * 6;
                    vfx.wallyRocketTrail.push({
                        x: player.x + (Math.random() - 0.5) * 20,
                        y: player.y + (Math.random() - 0.5) * 20,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 400 + Math.random() * 200,
                        t: 0,
                        size: 4 + Math.random() * 6,
                        hue: 180 + Math.random() * 40,
                        intensity: 0.8 + Math.random() * 0.2
                    });
                }
            }

            showNotification('ROCKET BOOST!', 'success');
        }

        function tryWallySpeedForce() {
            const now = performance.now();
            if (now < wallySpeedForceReadyAt) {
                const cooldownLeft = Math.ceil((wallySpeedForceReadyAt - now) / 1000);
                showNotification(`Speed Force on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            wallySpeedForceReadyAt = now + WALLY_SPEED_FORCE_COOLDOWN;
            player.wallySpeedForceActive = true;
            player.wallySpeedForceEndTime = now + WALLY_SPEED_FORCE_DURATION;

            for (let i = 0; i < 40; i++) {
                const angle = (Math.PI * 2 * i) / 40;
                const radius = WALLY_SPEED_FORCE_RANGE;
                vfx.wallySpeedForceDome.push({
                    x: player.x + Math.cos(angle) * radius,
                    y: player.y + Math.sin(angle) * radius,
                    angle: angle,
                    life: 800,
                    t: 0,
                    size: 8,
                    hue: 180,
                    intensity: 0.6,
                    radius: radius
                });
            }

            showNotification('SPEED FORCE ACTIVATED!', 'success');
        }

        function tryWallyFlashyLightning() {
            const now = performance.now();
            if (now < wallyFlashyLightningReadyAt) {
                const cooldownLeft = Math.ceil((wallyFlashyLightningReadyAt - now) / 1000);
                showNotification(`Flashy Lightning on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            wallyFlashyLightningReadyAt = now + WALLY_FLASHY_LIGHTNING_COOLDOWN;
            player.wallyFlashyLightningActive = true;
            player.wallyFlashyLightningEndTime = now + WALLY_FLASHY_LIGHTNING_DURATION;
            player.wallyFlashyLightningOriginalMaxSpd = player.maxSpd;
            player.maxSpd *= WALLY_FLASHY_LIGHTNING_SPEED_BOOST;

            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const radius = player.r * 3;
                vfx.wallyLightningAura.push({
                    x: player.x + Math.cos(angle) * radius,
                    y: player.y + Math.sin(angle) * radius,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    life: 300 + Math.random() * 200,
                    t: 0,
                    size: 3 + Math.random() * 4,
                    hue: 180 + Math.random() * 40,
                    intensity: 0.9 + Math.random() * 0.1,
                    spark: true
                });
            }

            for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 60;
                vfx.wallyLightningBolts.push({
                    x: player.x,
                    y: player.y,
                    targetX: player.x + Math.cos(angle) * distance,
                    targetY: player.y + Math.sin(angle) * distance,
                    life: 200 + Math.random() * 100,
                    t: 0,
                    intensity: 0.8 + Math.random() * 0.2,
                    width: 2 + Math.random() * 3,
                    segments: 5 + Math.floor(Math.random() * 8)
                });
            }

            showNotification('FLASHY LIGHTNING!', 'success');
        }

        function tryZeusLightningBolt() {
            if (currentStyle !== 'zeus') return;
            const now = performance.now();
            if (now < zeusLightningReadyAt) return;
            if (!player.hasBall) {
                showNotification('lightning bolt needs the ball bestie', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusHeavenlyShieldActive || player.zeusOlympusFuryActive || player.asherAutoGoalActive) return;

            player.zeusLightningCharging = true;
            player.zeusLightningChargeStartTime = now;
            powerBar.style.opacity = 1;

            autoTimer = setTimeout(() => {
                if (gameState !== 'game' || !player.zeusLightningCharging) return;
                zeusLightningShoot();
                player.zeusLightningCharging = false;
                vfx.zeusLightningChargeEffect = [];
                endCharge();
            }, ZEUS_LIGHTNING_CHARGE_DURATION);

            zeusLightningReadyAt = now + ABILITY_COOLDOWN;
        }

        function zeusLightningShoot() {
            if (currentStyle !== 'zeus' || !player.zeusLightningCharging) return;
            if (!player.hasBall) {
                player.zeusLightningCharging = false;
                return;
            }

            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.vx = Math.cos(dir) * ZEUS_LIGHTNING_SHOT_POWER + player.vx * 0.2;
            ball.vy = Math.sin(dir) * ZEUS_LIGHTNING_SHOT_POWER + player.vy * 0.2;
            ball.maxSpeed = 100000;
            player.hasBall = false;
            player.zeusLightningActive = true;

            vfx.zeusLightningTrail.push({
                end: performance.now() + 400,
                w: 18,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--zeus-lightning-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--zeus-lightning-trail-end')
            });
            shockwave(player.x, player.y, player.r, 'zeus-lightning');

            for (let i = 0; i < 15; i++) {
                vfx.zeusLightningParticles.push(newZeusLightningParticle(player.x, player.y, dir));
            }

            vfx.zeusThunderClouds.push(...newZeusThunderClouds(player.x, player.y));
            vfx.zeusLightningBolts.push(...newZeusLightningBolts(player.x, player.y));

            for(let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 60;
                vfx.zeusLightningParticles.push({
                    x: player.x + Math.cos(angle) * distance,
                    y: player.y + Math.sin(angle) * distance,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 300 + Math.random() * 200,
                    t: 0, r: 1 + Math.random() * 2,
                    color: 'rgba(255, 255, 255,'
                });
            }
            vfx.zeusLightningChargeEffect = [];

            const origFric = ball.friction;
            ball.friction = 0.99;
            setTimeout(() => {
                if (gameState !== 'game') return;
                ball.friction = origFric;
                ball.maxSpeed = 18;
                player.zeusLightningActive = false;
            }, 400);

            player.zeusLightningCharging = false;
            endCharge();
        }

        function tryZeusHeavenlyShield() {
            if (currentStyle !== 'zeus') return;
            const now = performance.now();
            if (now < zeusHeavenlyShieldReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.asherAutoGoalActive) return;

            player.zeusHeavenlyShieldActive = true;
            player.zeusHeavenlyShieldEndTime = now + ZEUS_HEAVENLY_SHIELD_DURATION;
            player.zeusHeavenlyShieldRadius = ZEUS_HEAVENLY_SHIELD_RADIUS;

            shockwave(player.x, player.y, player.r * 1.5, 'zeus-shield');
            vfx.zeusHeavenlyShieldAura.push({
                x: player.x, y: player.y,
                end: player.zeusHeavenlyShieldEndTime,
                radius: ZEUS_HEAVENLY_SHIELD_RADIUS,
                t: 0, life: ZEUS_HEAVENLY_SHIELD_DURATION
            });
            for(let i=0; i<10; i++) vfx.zeusHeavenlyShieldWaves.push(newZeusShieldWave(player.x, player.y));

            zeusHeavenlyShieldReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryZeusOlympusFury() {
            if (currentStyle !== 'zeus') return;
            const now = performance.now();
            if (now < zeusOlympusFuryReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            player.zeusOlympusFuryActive = true;
            player.zeusOlympusFuryPhase = 'pulling';
            player.zeusOlympusFuryPullStartTime = now;
            player.zeusOlympusFuryAimStartTime = 0;
            player.zeusOlympusFuryShotFired = false;
            player.zeusOlympusFuryOrigHasBall = player.hasBall;

            if (player.hasBall) {
                player.zeusOlympusFuryPhase = 'aiming';
                player.zeusOlympusFuryAimStartTime = now;
                vfx.zeusOlympusFuryAura.push({
                    x: player.x, y: player.y,
                    end: now + ZEUS_OLYMPUS_FURY_AIM_DURATION,
                    radius: player.r * 2.5,
                    t: 0, life: ZEUS_OLYMPUS_FURY_AIM_DURATION
                });
            } else {
                shockwave(player.x, player.y, player.r * 1.5, 'zeus-olympus-pull');
            }

            zeusOlympusFuryReadyAt = now + ABILITY_COOLDOWN * 2;
        }

        function zeusOlympusFuryShoot() {
            if (currentStyle !== 'zeus' || !player.zeusOlympusFuryActive || player.zeusOlympusFuryPhase !== 'aiming') return;
            if (!player.hasBall) {
                player.zeusOlympusFuryActive = false;
                return;
            }
            if (player.zeusOlympusFuryShotFired) return;

            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.vx = Math.cos(dir) * ZEUS_OLYMPUS_FURY_SHOT_POWER + player.vx * 0.1;
            ball.vy = Math.sin(dir) * ZEUS_OLYMPUS_FURY_SHOT_POWER + player.vy * 0.1;
            ball.maxSpeed = 100000;
            player.hasBall = false;
            player.zeusOlympusFuryShotFired = true;

            vfx.zeusOlympusFuryBallTrail.push({
                end: performance.now() + 800,
                w: 30,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--zeus-olympus-ball-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--zeus-olympus-ball-trail-end')
            });
            shockwave(player.x, player.y, player.r * 2, 'zeus-olympus-shot');

            vfx.zeusGroundScorches.push(newZeusGroundScorch(ball.x, ball.y));


            const origFric = ball.friction;
            ball.friction = 0.99;
            setTimeout(() => {
                if (gameState !== 'game') return;
                ball.friction = origFric;
                ball.maxSpeed = 18;
            }, 800);

            player.zeusOlympusFuryActive = false;
            player.zeusOlympusFuryPhase = '';
            player.zeusOlympusFuryPullStartTime = 0;
            player.zeusOlympusFuryAimStartTime = 0;
            player.zeusOlympusFuryShotFired = false;
            player.zeusOlympusFuryOrigHasBall = false;
            endCharge();
        }

        function tryIgnisFireBreath() {
            if (currentStyle !== 'ignis') return;
            const now = performance.now();
            if (now < ignisFireBreathReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive ||
                player.ignisBlazeDashing || player.ignisPhoenixBurstCharging) return;

            player.ignisFireBreathActive = true;
            player.ignisFireBreathStartTime = now;
            player.ignisFireBreathDirection = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            player.ignisFireBreathExtended = false;

            for (let i = 0; i < 20; i++) {
                const angle = player.ignisFireBreathDirection + (Math.random() - 0.5) * IGNIS_FIRE_BREATH_CONE_ANGLE;
                const distance = IGNIS_FIRE_BREATH_BASE_RANGE * (0.5 + Math.random() * 0.5);
                const x = player.x + Math.cos(angle) * distance;
                const y = player.y + Math.sin(angle) * distance;
                
                vfx.ignisFireBreathParticles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    life: 1000 + Math.random() * 500,
                    t: 0,
                    size: 3 + Math.random() * 4
                });
            }

            for (let i = 0; i < 5; i++) {
                const angle = player.ignisFireBreathDirection + (Math.random() - 0.5) * IGNIS_FIRE_BREATH_CONE_ANGLE;
                const endX = player.x + Math.cos(angle) * IGNIS_FIRE_BREATH_BASE_RANGE;
                const endY = player.y + Math.sin(angle) * IGNIS_FIRE_BREATH_BASE_RANGE;
                
                vfx.ignisFireBreathLines.push({
                    startX: player.x,
                    startY: player.y,
                    endX: endX,
                    endY: endY,
                    life: 400 + Math.random() * 300,
                    t: 0,
                    thickness: 2 + Math.random() * 3
                });
            }

            setTimeout(() => checkIgnisFireBreathBallCollision(), 100);

            ignisFireBreathReadyAt = now + ABILITY_COOLDOWN;
        }

        function checkIgnisFireBreathBallCollision() {
            if (!player.ignisFireBreathActive) return;
            
            const playerToBall = Math.atan2(ball.y - player.y, ball.x - player.x);
            const angleDiff = Math.abs(playerToBall - player.ignisFireBreathDirection);
            const normalizedAngleDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);
            const distance = Math.hypot(ball.x - player.x, ball.y - player.y);
            const maxRange = player.ignisFireBreathExtended ? IGNIS_FIRE_BREATH_EXTENDED_RANGE : IGNIS_FIRE_BREATH_BASE_RANGE;

            if (normalizedAngleDiff <= IGNIS_FIRE_BREATH_CONE_ANGLE / 2 && distance <= maxRange) {
                if (!player.hasBall) {
                    player.hasBall = true;
                    ball.vx = 0;
                    ball.vy = 0;
                    showNotification('fire claimed the ball!', 'success');
                }
            }

            if (aiEnabled && aiPlayer) {
                const playerToAI = Math.atan2(aiPlayer.y - player.y, aiPlayer.x - player.x);
                const aiAngleDiff = Math.abs(playerToAI - player.ignisFireBreathDirection);
                const normalizedAIAngleDiff = Math.min(aiAngleDiff, Math.PI * 2 - aiAngleDiff);
                const aiDistance = Math.hypot(aiPlayer.x - player.x, aiPlayer.y - player.y);

                if (normalizedAIAngleDiff <= IGNIS_FIRE_BREATH_CONE_ANGLE / 2 && aiDistance <= maxRange) {
                    aiPlayer.ignisStunned = true;
                    aiPlayer.ignisStunEndTime = performance.now() + IGNIS_FIRE_BREATH_STUN_DURATION;
                    showNotification('AI stunned by fire!', 'success');
                }
            }
        }

        function tryIgnisBlazeDash() {
            if (currentStyle !== 'ignis') return;
            const now = performance.now();
            if (now < ignisBlazeDashReadyAt) return;

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive ||
                player.ignisFireBreathActive || player.ignisPhoenixBurstCharging) return;

            player.ignisBlazeDashing = true;
            player.ignisBlazeDashStartTime = now;
            player.ignisBlazeDashDirection = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            
            const ballDistance = Math.hypot(ball.x - player.x, ball.y - player.y);
            if (ballDistance < 60) {
                const ballDir = Math.atan2(ball.y - player.y, ball.x - player.x);
                ball.vx += Math.cos(ballDir) * IGNIS_BLAZE_DASH_KNOCKBACK_FORCE;
                ball.vy += Math.sin(ballDir) * IGNIS_BLAZE_DASH_KNOCKBACK_FORCE;
                showNotification('blaze dash knockback!', 'info');
            }

            vfx.ignisBlazeDashTrail.push({
                end: now + 800,
                x: player.x,
                y: player.y,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--ignis-blaze-dash-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--ignis-blaze-dash-trail-end')
            });

            ignisBlazeDashReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryIgnisPhoenixBurst() {
            if (currentStyle !== 'ignis') return;
            const now = performance.now();
            if (now < ignisPhoenixBurstReadyAt) return;
            if (!player.hasBall) {
                showNotification('phoenix burst needs the ball bestie', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive ||
                player.ignisFireBreathActive || player.ignisBlazeDashing) return;

            player.ignisPhoenixBurstCharging = true;
            player.ignisPhoenixBurstChargeStartTime = now;
            powerBar.style.opacity = 1;

            autoTimer = setTimeout(() => {
                if (gameState !== 'game' || !player.ignisPhoenixBurstCharging) return;
                ignisPhoenixBurstRelease();
            }, IGNIS_PHOENIX_BURST_CHARGE_DURATION);

            ignisPhoenixBurstReadyAt = now + ABILITY_COOLDOWN * 2;
        }

        function ignisPhoenixBurstRelease() {
            if (currentStyle !== 'ignis' || !player.ignisPhoenixBurstCharging) return;
            if (!player.hasBall) {
                player.ignisPhoenixBurstCharging = false;
                return;
            }

            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.vx = Math.cos(dir) * IGNIS_PHOENIX_BURST_SHOT_POWER + player.vx * 0.1;
            ball.vy = Math.sin(dir) * IGNIS_PHOENIX_BURST_SHOT_POWER + player.vy * 0.1;
            ball.maxSpeed = 100000;
            player.hasBall = false;

            for (let i = 0; i < 50; i++) {
                const angle = (Math.PI * 2 * i) / 50;
                const distance = IGNIS_PHOENIX_BURST_EXPLOSION_RADIUS * (0.5 + Math.random() * 0.5);
                vfx.ignisPhoenixBurstParticles.push({
                    x: player.x + Math.cos(angle) * distance,
                    y: player.y + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    life: 1500,
                    t: 0,
                    size: 5 + Math.random() * 8
                });
            }

            shockwave(player.x, player.y, IGNIS_PHOENIX_BURST_EXPLOSION_RADIUS, 'ignis-phoenix');

            const origFric = ball.friction;
            ball.friction = 0.99;
            setTimeout(() => {
                if (gameState !== 'game') return;
                ball.friction = origFric;
                ball.maxSpeed = 18;
            }, 1000);

            player.ignisPhoenixBurstCharging = false;
            endCharge();
        }

function tryAsherAutoGoal() {
            if (currentStyle !== 'asher') return;
            const now = performance.now();
            if (now < asherAutoGoalReadyAt) return;
            if (!player.hasBall) {
                showNotification('starfall shot needs the ball bestie', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive) return;

            player.asherStarfallCharging = true;
            player.asherStarfallChargeStartTime = now;
            player.hasBall = false;

            shockwave(player.x, player.y, player.r * 1.5, 'asher');

            setTimeout(() => {
                if (gameState !== 'game' || !player.asherStarfallCharging) return;

                player.asherStarfallCharging = false;
                player.asherAutoGoalActive = true;

                const dir = Math.atan2((H / 2) - ball.y, (W - margin) - ball.x);
                ball.vx = Math.cos(dir) * ASHER_HOMING_SHOT_POWER;
                ball.vy = Math.sin(dir) * ASHER_HOMING_SHOT_POWER;
                ball.maxSpeed = ASHER_HOMING_SHOT_POWER * 1.5;

                ball.isHoming = true;
                ball.homingTargetX = W - margin - (goalDepth / 2);
                ball.homingTargetY = H / 2;
                ball.homingEndTime = performance.now() + ASHER_HOMING_SHOT_DURATION;

                vfx.asherStarTrail.push({
                    end: ball.homingEndTime,
                    w: 18,
                    colorStart: getComputedStyle(document.documentElement).getPropertyValue('--asher-star-trail-start'),
                    colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--asher-star-trail-end')
                });

                const origFric = ball.friction;
                ball.friction = 0.998;
                setTimeout(() => {
                    if (gameState !== 'game') return;
                    ball.friction = origFric;
                    ball.maxSpeed = 18;
                    ball.isHoming = false;
                    player.asherAutoGoalActive = false;
                }, ASHER_HOMING_SHOT_DURATION);

            }, ASHER_STARFALL_CHARGE_DURATION);

            asherAutoGoalReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryAsherBallTeleport() {
            if (currentStyle !== 'asher') return;
            const now = performance.now();
            if (now < asherBallTeleportReadyAt) return;
            if (player.hasBall) {
                showNotification('celestial pull cant be used while you have the ball', 'warning');
                return;
            }

            if (player.spinning || player.charging || player.telekinising || player.dashing ||
                player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

            for (let i = 0; i < 20; i++) {
                vfx.asherTeleportBurst.push(newAsherTeleportParticle(ball.x, ball.y));
            }
            shockwave(ball.x, ball.y, ball.r * 2, 'asher');

            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.x = player.x + Math.cos(dir) * (player.r + ball.r + 4);
            ball.y = player.y + Math.sin(dir) * (player.r + ball.r + 4);
            ball.vx = 0;
            ball.vy = 0;
            player.hasBall = true;

            for (let i = 0; i < 15; i++) {
                vfx.asherArrivalGlimmer.push(newAsherArrivalParticle(ball.x, ball.y));
            }
            shockwave(player.x, player.y, player.r, 'asher');

            asherBallTeleportReadyAt = now + ABILITY_COOLDOWN;
        }


        function tryLeonardoFocusShot() {
            if (currentStyle !== 'leonardo') return;
            const now = performance.now();
            if (now < leonardoFocusShotReadyAt) return;
            if (!player.hasBall) {
                showNotification('focus shot needs the ball bestie', 'warning');
                return;
            }

            if (player.leonardoShieldActive || player.leonardoDashing) return;

            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.vx = Math.cos(dir) * LEONARDO_FOCUS_SHOT_POWER + player.vx * 0.25;
            ball.vy = Math.sin(dir) * LEONARDO_FOCUS_SHOT_POWER + player.vy * 0.25;
            ball.maxSpeed = 100000;
            player.hasBall = false;
            player.leonardoFocusShotActive = true;

            vfx.leonardoFocusText.push({
                x: player.x, y: player.y,
                end: now + 1000,
                t: 0, life: 1000
            });

            for (let i = 0; i < 25; i++) {
                vfx.leonardoFocusParticles.push(newLeonardoFocusParticle(player.x, player.y, dir));
            }

            vfx.flashes.push({
                x: player.x, y: player.y,
                t: 0, life: 400,
                radius: 80,
                color: 'rgba(165, 243, 252, 0.8)'
            });

            vfx.leonardoFocusTrail.push({
                end: performance.now() + 600,
                w: 22,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-focus-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-focus-trail-end')
            });


        Trycaption("AUTISM ATTACK!", "Zoom");
            shockwave(player.x, player.y, 20, 'leonardo');

            const origFric = ball.friction;
            ball.friction = 0.993;
            setTimeout(() => {
                ball.friction = origFric;
                ball.maxSpeed = 18;
                player.leonardoFocusShotActive = false;
            }, 600);

            leonardoFocusShotReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryLeonardoSensoryShield() {
            if (currentStyle !== 'leonardo') return;
            const now = performance.now();
            if (now < leonardoShieldReadyAt) return;

            if (player.leonardoFocusShotActive || player.leonardoDashing) return;

            player.leonardoShieldActive = true;
            player.leonardoShieldEndTime = now + LEONARDO_SHIELD_DURATION;

            vfx.leonardoShieldAura.push({
                x: player.x, y: player.y,
                end: player.leonardoShieldEndTime,
                radius: LEONARDO_SHIELD_RADIUS,
                t: 0, life: LEONARDO_SHIELD_DURATION
            });

            for (let i = 0; i < 20; i++) {
                vfx.leonardoShieldParticles.push(newLeonardoShieldParticle(player.x, player.y));
            }

            shockwave(player.x, player.y, player.r * 1.2, 'leonardo');

            leonardoShieldReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryLeonardoPatternWeave() {
            if (currentStyle !== 'leonardo') return;
            const now = performance.now();
            if (now < leonardoDashReadyAt) return;

            if (player.leonardoFocusShotActive || player.leonardoShieldActive) return;

            player.leonardoDashing = true;
            player.leonardoDashTimer = LEONARDO_DASH_DURATION;

            const dashDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            player.vx = Math.cos(dashDir) * LEONARDO_DASH_SPEED;
            player.vy = Math.sin(dashDir) * LEONARDO_DASH_SPEED;

            player.leonardoDashEndX = player.x + Math.cos(dashDir) * LEONARDO_DASH_SPEED * (LEONARDO_DASH_DURATION / 16.67);
            player.leonardoDashEndY = player.y + Math.sin(dashDir) * LEONARDO_DASH_SPEED * (LEONARDO_DASH_DURATION / 16.67);

            vfx.leonardoDashTrail.push({
                end: now + LEONARDO_DASH_DURATION + 150,
                w: player.r * 1.6,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-trail-end')
            });

            for (let i = 0; i < 15; i++) {
                vfx.leonardoDashParticles.push(newLeonardoDashParticle(player.x, player.y, dashDir));
            }

            setTimeout(() => {
                if (gameState !== 'game') return;
                player.leonardoDashing = false;
                player.vx *= 0.2;
                player.vy *= 0.2;
                vfx.leonardoPatternField.push({
                    x: player.x, y: player.y,
                    t: 0, life: LEONARDO_PATTERN_FIELD_DURATION,
                    radius: player.r * 3
                });
            }, LEONARDO_DASH_DURATION);

            leonardoDashReadyAt = now + ABILITY_COOLDOWN;
        }

function tryAngusPowerBurst() {
if (currentStyle !== 'angus') return;
const now = performance.now();

if (player.angusBurstUsesLeft <= 0) {
showNotification('power burst uses exhausted', 'warning');
return;
}

if (!player.hasBall) {
showNotification('power burst needs the ball bestie', 'warning');
return;
}

if (player.angusCharging) return;

player.angusCharging = true;
player.angusChargeStartTime = now;
TrySubtitle("AHH ITS COMING OUT");

const chargeInterval = setInterval(() => {
if (!player.angusCharging) {
clearInterval(chargeInterval);
return;
}

for (let i = 0; i < 5; i++) {
vfx.angusChargeParticles.push(newAngusChargeParticle(player.x, player.y));
}

vfx.angusPuddles = vfx.angusPuddles || [];
vfx.angusPuddles.push({
x: player.x,
y: player.y + 10,
t: 0,
life: ANGUS_CHARGE_DURATION,
radius: 40,
alpha: 0.3
});

}, 50);

setTimeout(() => {
if (!player.angusCharging || !player.hasBall) return;

player.angusCharging = false;
player.angusBurstUsesLeft--;

vfx.angusBurstVFX.push({
x: player.x, y: player.y,
t: 0, life: 800,
radius: 100
});

for (let i = 0; i < 40; i++) {
vfx.angusChargeParticles.push(newAngusBurstParticle(player.x, player.y));
}
TrySubtitle("oh.. it already did, jacob pls dont make it happen again");

const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
ball.vx = Math.cos(dir) * ANGUS_BURST_POWER + player.vx * 0.1;
ball.vy = Math.sin(dir) * ANGUS_BURST_POWER + player.vy * 0.1;
ball.maxSpeed = 100000;
player.hasBall = false;


shockwave(player.x, player.y, 40, 'angus');


setTimeout(() => {
ball.maxSpeed = 18;
}, 1000);

clearInterval(chargeInterval);
}, ANGUS_CHARGE_DURATION);
}


        function tryAngusTimeStop() {
            if (currentStyle !== 'angus') return;
            const now = performance.now();
            if (now < angusTimeStopReadyAt) return;

            player.angusTimeStopActive = true;
            player.angusTimeStopEndTime = now + ANGUS_TIME_STOP_DURATION;

            vfx.angusTimeStopField.push({
                x: player.x, y: player.y,
                t: 0, life: ANGUS_TIME_STOP_DURATION,
                radius: 200
            });

            const originalBallVx = ball.vx;
            const originalBallVy = ball.vy;
            ball.vx = 0;
            ball.vy = 0;

            setTimeout(() => {
                player.angusTimeStopActive = false;
                ball.vx = originalBallVx * 0.3;
                ball.vy = originalBallVy * 0.3;
            }, ANGUS_TIME_STOP_DURATION);

            angusTimeStopReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryAngusShadowTeleport() {
            if (currentStyle !== 'angus') return;
            const now = performance.now();
            if (now < angusTeleportReadyAt) return;

            const teleportDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            const newX = player.x + Math.cos(teleportDir) * ANGUS_TELEPORT_RANGE;
            const newY = player.y + Math.sin(teleportDir) * ANGUS_TELEPORT_RANGE;

            const clampedX = clamp(newX, player.r + margin, W - player.r - margin);
            const clampedY = clamp(newY, player.r + margin, H - player.r - margin);

            vfx.angusTeleportTrail.push({
                startX: player.x, startY: player.y,
                endX: clampedX, endY: clampedY,
                t: 0, life: 600
            });

            player.x = clampedX;
            player.y = clampedY;

            shockwave(player.x, player.y, player.r * 1.5, 'angus');

            angusTeleportReadyAt = now + ABILITY_COOLDOWN;
        }


        function kaiserSparks(x,y,dir){
            for(let i=0;i<42;i++){
                const a = dir + (Math.random()*0.6-0.3);
                const sp = 4+Math.random()*6;
                const life = 300+Math.random()*500;
                vfx.sparks.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life, t:0, r:2+Math.random()*2, color:'rgba(96,165,250,'});
            }
        }
        function newRobsanParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 2;
            const life = 200 + Math.random() * 400;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 3, color: 'rgba(68, 10, 107,' };
        }
        function newXDrakeFootworkParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.2 + Math.random() * 1.5;
            const life = 150 + Math.random() * 250;
            const size = 2 + Math.random() * 4;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: size, color: 'rgba(109, 75, 46,' };
        }

        function newEddieWeAreParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.1 + Math.random() * 0.8;
            const life = 500 + Math.random() * 500;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 3, color: 'rgba(20, 20, 20,' };
        }

        function newBlackPuddle(x, y) {
            return {x, y, t: 0, life: PUDDLE_DURATION, r: player.r * 1.2, color: 'rgba(0,0,0,'};
        }

        function newZeusLightningParticle(x, y, dir) {
            const angle = dir + (Math.random() * 0.8 - 0.4);
            const speed = 2 + Math.random() * 5;
            const life = 200 + Math.random() * 300;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(255, 255, 255,' };
        }

        function newZeusLightningChargeParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 1.5;
            const life = 150 + Math.random() * 250;
            const offsetRadius = player.r * (0.5 + Math.random() * 0.5);
            return {
                x: x + Math.cos(angle) * offsetRadius,
                y: y + Math.sin(angle) * offsetRadius,
                vx: Math.cos(angle) * speed * 0.5,
                vy: Math.sin(angle) * speed * 0.5,
                life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(59, 130, 246,'
            };
        }

        function newZeusShieldWave(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 2;
            const life = 300 + Math.random() * 400;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 3, color: 'rgba(59, 130, 246,' };
        }

        function newZeusOlympusFuryPullLine(playerX, playerY, ballX, ballY) {
            const angle = Math.atan2(ballY - playerY, ballX - playerX);
            const startX = playerX + Math.cos(angle) * player.r;
            const startY = playerY + Math.sin(angle) * player.r;
            const endX = ballX - Math.cos(angle) * ball.r;
            const endY = ballY - Math.sin(angle) * ball.r;
            return {
                startX, startY, endX, endY,
                t: 0, life: 200 + Math.random() * 100,
                thickness: 2 + Math.random() * 2,
                color: `rgba(255, 255, 255,`
            };
        }

        function newZeusGroundScorch(x, y) {
            return {
                x, y,
                t: 0, life: 1200 + Math.random() * 500,
                r: 10 + Math.random() * 10,
                startColor: 'rgba(253, 224, 71,',
                endColor: 'rgba(59, 130, 246,'
            };
        }

        function newAsherTeleportParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 3 + Math.random() * 6;
            const life = 300 + Math.random() * 400;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(233, 213, 255,' };
        }

        function newAsherArrivalParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 2;
            const life = 250 + Math.random() * 300;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 2, color: 'rgba(209, 213, 219,' };
        }

        function newHudsonSpeedLines(x, y, dir) {
            const lines = [];
            for(let i = 0; i < 8; i++) {
                lines.push({
                    x: x + (Math.random() - 0.5) * 60,
                    y: y + (Math.random() - 0.5) * 60,
                    dir: dir + (Math.random() - 0.5) * 0.3,
                    length: 40 + Math.random() * 30,
                    t: 0, life: 300 + Math.random() * 200,
                    color: 'rgba(79, 209, 197,'
                });
            }
            return lines;
        }

        function newHudsonEnergyWave(x, y) {
            return {
                x, y, t: 0, life: 800,
                initialRadius: 5, maxRadius: 80,
                color: 'rgba(79, 209, 197,'
            };
        }

        function newHudsonEmperorTrail(x, y, phase) {
            const color = phase === 'left' ?
                getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-pink') :
                getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-blue');

            return {
                x, y,
                life: 400, t: 0,
                width: 12,
                color: color,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2
            };
        }

        function newHudsonEmperorParticle(x, y, phase) {
            const color = phase === 'left' ?
                'rgba(233, 30, 99, 0.8)' :
                'rgba(63, 81, 181, 0.8)';

            return {
                x: x + (Math.random() - 0.5) * 30,
                y: y + (Math.random() - 0.5) * 30,
                life: 600, t: 0,
                r: 3 + Math.random() * 4,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                color: color
            };
        }

        function newHudsonEmperorAura(x, y) {
            return {
                x, y,
                life: 500, t: 0,
                radius: 25 + Math.random() * 15,
                phase: 'normal'
            };
        }

        function newLeonardoFocusParticle(x, y, dir) {
            const angle = dir + (Math.random() - 0.5) * 0.4;
            const speed = 3 + Math.random() * 8;
            const life = 400 + Math.random() * 300;
            return {
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life, t: 0, r: 1 + Math.random() * 3,
                color: 'rgba(165, 243, 252,'
            };
        }

        function newLeonardoShieldParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 2;
            const life = 300 + Math.random() * 400;
            return {
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life, t: 0, r: 2 + Math.random() * 2,
                color: 'rgba(6, 182, 212,'
            };
        }

        function newLeonardoDashParticle(x, y, dir) {
            const angle = dir + (Math.random() - 0.5) * 1.2;
            const speed = 2 + Math.random() * 5;
            const life = 250 + Math.random() * 200;
            return {
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life, t: 0, r: 1 + Math.random() * 2,
                color: 'rgba(165, 243, 252,'
            };
        }

        function newAngusChargeParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 2;
            const life = 400 + Math.random() * 300;
            const offsetRadius = player.r * (1 + Math.random() * 2);
            return {
                x: x + Math.cos(angle) * offsetRadius,
                y: y + Math.sin(angle) * offsetRadius,
                vx: Math.cos(angle) * speed * 0.5,
                vy: Math.sin(angle) * speed * 0.5,
                life, t: 0, r: 2 + Math.random() * 3,
                color: 'rgba(255, 255, 255,'
            };
        }

        function newAngusBurstParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 3 + Math.random() * 8;
            const life = 500 + Math.random() * 400;
            return {
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life, t: 0, r: 2 + Math.random() * 4,
                color: 'rgba(255, 255, 255,'
            };
        }

        function newRobsanShadowClones(x, y) {
            const clones = [];
            for(let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                clones.push({
                    x: x + Math.cos(angle) * 25,
                    y: y + Math.sin(angle) * 25,
                    t: 0, life: 600 + Math.random() * 300,
                    r: player.r * 0.8,
                    opacity: 0.7
                });
            }
            return clones;
        }

        function newRobsanVoidRift(x, y) {
            return {
                x, y, t: 0, life: 1000,
                width: 3, maxWidth: 15,
                height: 40, color: 'rgba(0, 0, 0,'
            };
        }

        function newXDrakeNatureSpirits(x, y) {
            const spirits = [];
            for(let i = 0; i < 6; i++) {
                const angle = Math.random() * Math.PI * 2;
                spirits.push({
                    x: x + Math.cos(angle) * 20,
                    y: y + Math.sin(angle) * 20,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    t: 0, life: 800 + Math.random() * 400,
                    r: 2 + Math.random() * 3,
                    color: 'rgba(34, 197, 94,'
                });
            }
            return spirits;
        }

        function newXDrakeTerraform(x, y, dir) {
            const formations = [];
            for(let i = 0; i < 4; i++) {
                formations.push({
                    x: x + Math.cos(dir + i * 0.5) * (20 + i * 15),
                    y: y + Math.sin(dir + i * 0.5) * (20 + i * 15),
                    t: 0, life: 600 + i * 200,
                    height: 5 + i * 3,
                    color: 'rgba(109, 75, 46,'
                });
            }
            return formations;
        }

        function newGojoInfinityBarrier(x, y) {
            const barriers = [];
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                barriers.push({
                    x: x + Math.cos(angle) * 30,
                    y: y + Math.sin(angle) * 30,
                    angle: angle,
                    t: 0, life: 1200,
                    length: 20,
                    color: 'rgba(99, 102, 241,'
                });
            }
            return barriers;
        }

        function newGojoDomainExpansion(x, y) {
            return {
                x, y, t: 0, life: 2000,
                initialRadius: 10, maxRadius: 150,
                intensity: 1, color: 'rgba(99, 102, 241,'
            };
        }

        function newEddieSymbioteSpikes(x, y) {
            const spikes = [];
            for(let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                spikes.push({
                    x: x + Math.cos(angle) * 15,
                    y: y + Math.sin(angle) * 15,
                    dir: angle,
                    t: 0, life: 400 + Math.random() * 300,
                    length: 15 + Math.random() * 10,
                    color: 'rgba(0, 0, 0,'
                });
            }
            return spikes;
        }

        function newEddieVenomDrops(x, y) {
            const drops = [];
            for(let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                drops.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y + (Math.random() - 0.5) * 40,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    t: 0, life: 800 + Math.random() * 400,
                    r: 2 + Math.random() * 3,
                    color: 'rgba(100, 0, 150,'
                });
            }
            return drops;
        }

        function newZeusThunderClouds(x, y) {
            const clouds = [];
            for(let i = 0; i < 3; i++) {
                clouds.push({
                    x: x + (Math.random() - 0.5) * 100,
                    y: y - 30 - i * 20,
                    t: 0, life: 1500 + Math.random() * 500,
                    r: 15 + Math.random() * 10,
                    opacity: 0.6,
                    color: 'rgba(75, 85, 99,'
                });
            }
            return clouds;
        }

        function newZeusLightningBolts(x, y) {
            const bolts = [];
            for(let i = 0; i < 5; i++) {
                const segments = [];
                let currentX = x;
                let currentY = y - 50;

                for(let j = 0; j < 8; j++) {
                    const nextX = currentX + (Math.random() - 0.5) * 20;
                    const nextY = currentY + 15;
                    segments.push({x: currentX, y: currentY, x2: nextX, y2: nextY});
                    currentX = nextX;
                    currentY = nextY;
                }

                bolts.push({
                    segments: segments,
                    t: 0, life: 200 + Math.random() * 200,
                    thickness: 2 + Math.random() * 3,
                    color: 'rgba(255, 255, 255,'
                });
            }
            return bolts;
        }

        function newHudsonImpactBurst(x, y, dir) {
            const trails = [];
            for(let i = 0; i < 12; i++) {
                const angle = dir + (Math.random() - 0.5) * 0.8;
                const phase = Math.random() > 0.5 ? 'left' : 'right';
                const color = phase === 'left' ?
                    getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-pink') :
                    getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-blue');

                trails.push({
                    x: x + Math.cos(angle) * (5 + Math.random() * 15),
                    y: y + Math.sin(angle) * (5 + Math.random() * 15),
                    life: 400, t: 0,
                    width: 12,
                    color: color,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3
                });
            }
            return trails;
        }

        function newRobsanGroundRupture(x, y, dir) {
            return {
                x, y,
                dir,
                t: 0, life: 500,
                length: 10 + Math.random() * 20,
                width: 2 + Math.random() * 3,
                color: 'rgba(20, 0, 40,'
            };
        }

        function newRobsanEclipseWisp(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.1 + Math.random() * 0.5;
            const life = 300 + Math.random() * 200;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(30, 0, 50,' };
        }

        function newRobsanVoidPuff(x, y, type) {
            const life = 200 + Math.random() * 100;
            const r = player.r * (0.5 + Math.random() * 0.3);
            return { x, y, t: 0, life, r, type, color: 'rgba(0, 0, 0,' };
        }

        function newXDrakeGroundCrack(x, y) {
            return {
                x, y,
                t: 0, life: 800 + Math.random() * 200,
                size: 15 + Math.random() * 10,
                color: 'rgba(5, 150, 105,'
            };
        }

        function newXDrakeFootworkLeaf(x, y, dir) {
            const angle = dir + (Math.random() * 0.8 - 0.4);
            const speed = 1 + Math.random() * 2;
            const life = 250 + Math.random() * 150;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 2, color: 'rgba(16, 185, 129,' };
        }

        function newXDrakeAncientApexGroundBurst(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 3;
            const life = 400 + Math.random() * 200;
            return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 3 + Math.random() * 4, color: 'rgba(100, 200, 100,' };
        }

        function newGojoRedExplosion(x, y) {
            return {
                x, y,
                t: 0, life: 300,
                radius: player.r * 1.5,
                color: 'rgba(229, 62, 62,'
            };
        }

        function newGojoLapseBluePullParticle(startX, startY, endX, endY) {
            const dir = Math.atan2(endY - startY, endX - startX);
            const speed = 2 + Math.random() * 3;
            const life = 200 + Math.random() * 100;
            return {
                x: startX, y: startY,
                vx: Math.cos(dir) * speed * (0.8 + Math.random() * 0.4),
                vy: Math.sin(dir) * speed * (0.8 + Math.random() * 0.4),
                life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(49, 130, 206,'
            };
        }

        function newGojoPurpleArc(x, y, initialAngle) {
            return {
                x, y,
                initialAngle,
                t: 0, life: 600 + Math.random() * 200,
                radius: 10 + Math.random() * 20,
                color: 'rgba(128, 90, 213,'
            };
        }

        function newEddieWeAreRipple(x, y) {
            return {
                x, y,
                t: 0, life: 700 + Math.random() * 300,
                initialRadius: player.r * 1.5,
                maxRadius: player.r * 3,
                color: 'rgba(20, 20, 20,'
            };
        }

        function newEddieVenomBallSwirlParticle(x, y, dir) {
            const angleOffset = (Math.random() - 0.5) * Math.PI / 4;
            const speed = 0.5 + Math.random() * 1.5;
            const life = 150 + Math.random() * 100;
            return {
                x, y,
                vx: Math.cos(dir + angleOffset) * speed,
                vy: Math.sin(dir + angleOffset) * speed,
                life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(100, 0, 150,'
            };
        }

        function newEddieTeleportFlicker(x, y) {
            return {
                x, y,
                t: 0, life: 100,
                radius: player.r * 1.5,
                color: 'rgba(0, 0, 0,'
            };
        }


        function shockwave(x,y,r0, style='hudson'){

            let strokeColor1 = 'rgba(96,165,250,';
            let strokeColor2 = 'rgba(244,114,182,';

            if (style === 'robsan') {
                strokeColor1 = 'var(--robsan-dark-primary)';
                strokeColor2 = 'var(--robsan-dark-secondary)';
            } else if (style === 'eclipse') {
                strokeColor1 = 'var(--eclipse-line-color)';
                strokeColor2 = 'var(--eclipse-line-glow)';
            } else if (style === 'xdrake-supernova') {
                strokeColor1 = 'var(--xdrake-green-primary)';
                strokeColor2 = 'var(--xdrake-green-secondary)';
            } else if (style === 'xdrake-footwork') {
                strokeColor1 = 'var(--xdrake-footwork-color)';
                strokeColor2 = 'var(--xdrake-green-secondary)';
            } else if (style === 'xdrake-apex') {
                strokeColor1 = 'var(--xdrake-apex-aura-start)';
                strokeColor2 = 'var(--xdrake-apex-aura-end)';
            } else if (style === 'gojo-red') {
                strokeColor1 = 'var(--gojo-red-primary)';
                strokeColor2 = 'var(--gojo-red-secondary)';
            } else if (style === 'gojo-blue') {
                strokeColor1 = 'var(--gojo-blue-primary)';
                strokeColor2 = 'var(--gojo-blue-secondary)';
            } else if (style === 'gojo-purple') {
                strokeColor1 = 'var(--gojo-purple-primary)';
                strokeColor2 = 'var(--gojo-purple-secondary)';
            } else if (style === 'eddie-we-are') {
                strokeColor1 = 'var(--eddie-primary)';
                strokeColor2 = 'var(--eddie-secondary)';
            } else if (style === 'eddie-venom') {
                strokeColor1 = 'var(--eddie-venom-strike-trail-start)';
                strokeColor2 = 'var(--eddie-venom-strike-trail-end)';
            } else if (style === 'eddie-montage') {
                strokeColor1 = getComputedStyle(document.documentElement).getPropertyValue('--eddie-symbiote-montage-trail').trim();
                strokeColor2 = 'var(--eddie-primary)';
            } else if (style === 'zeus-lightning') {
                strokeColor1 = 'var(--zeus-lightning-trail-start)';
                strokeColor2 = 'var(--zeus-lightning-trail-end)';
            } else if (style === 'zeus-shield') {
                strokeColor1 = 'var(--zeus-primary)';
                strokeColor2 = 'var(--zeus-shield-glow)';
            } else if (style === 'zeus-olympus-pull') {
                strokeColor1 = 'var(--zeus-olympus-aura-start)';
                strokeColor2 = 'var(--zeus-secondary)';
            } else if (style === 'zeus-olympus-shot') {
                strokeColor1 = 'var(--zeus-olympus-ball-trail-start)';
                strokeColor2 = 'var(--zeus-olympus-aura-end)';
            } else if (style === 'asher') {
                strokeColor1 = 'var(--asher-primary)';
                strokeColor2 = 'var(--asher-secondary)';
            } else if (style === 'angus') {
                strokeColor1 = 'var(--angus-primary)';
                strokeColor2 = 'var(--angus-secondary)';
            }

            const rootStyle = getComputedStyle(document.documentElement);
            if (strokeColor1.startsWith('var(')) {
                strokeColor1 = rootStyle.getPropertyValue(strokeColor1.match(/var\(([^)]+)\)/)[1]).trim();
            }
            if (strokeColor2.startsWith('var(')) {
                strokeColor2 = rootStyle.getPropertyValue(strokeColor2.match(/var\(([^)]+)\)/)[1]).trim();
            }
            vfx.shockwaves.push({x,y,r:r0, t:0, life:420, color1:strokeColor1, color2:strokeColor2});
        }
        function impactWave(x,y,r0){ vfx.shockwaves.push({x,y,r:r0, t:0, life:260, color1:'rgba(96,165,250,', color2:'rgba(244,114,182,'}); }
        function newLineBurst(x,y,dir){
            const spread=(Math.random()*0.6-0.3);
            const a=dir+spread; return {x,y,a,len:40+Math.random()*80, t:0, life:300+Math.random()*300};
        }

        function updateAI(dt) {
            if (!aiEnabled) return;

            const now = performance.now();

            if (now - aiPlayer.lastThinkTime > aiPlayer.thinkInterval) {
                aiPlayer.lastThinkTime = now;
                aiThink();
            }

            aiMove(dt);

            aiShoot(dt);

            aiPlayer.vx *= aiPlayer.drag;
            aiPlayer.vy *= aiPlayer.drag;
            aiPlayer.x += aiPlayer.vx;
            aiPlayer.y += aiPlayer.vy;

            aiPlayer.x = Math.max(aiPlayer.r, Math.min(W - aiPlayer.r, aiPlayer.x));
            aiPlayer.y = Math.max(aiPlayer.r, Math.min(H - aiPlayer.r, aiPlayer.y));

            if (aiPlayer.isStunned && now > aiPlayer.stunEndTime) {
                aiPlayer.isStunned = false;
            }

            const dx = ball.x - aiPlayer.x;
            const dy = ball.y - aiPlayer.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const playerDistToBall = Math.sqrt((ball.x - player.x)**2 + (ball.y - player.y)**2);

            if (aiPlayer.state === 'shoot' && !aiPlayer.hasBall && !player.hasBall && !aiPlayer.isStunned) {
                const aiHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                const korbinBallProtected = ball.korbinBigBackProtected && player.korbinBigBackPowerActive;
                if (!aiHypnoticLocked && !korbinBallProtected && dist < 120) {
                    aiPlayer.hasBall = true;
                    ball.vx = 0;
                    ball.vy = 0;
                    showNotification('AI grabs ball for shot!', 'warning');
                }
            }
            else if (dist < aiPlayer.r + ball.r + 6 && !aiPlayer.isStunned) {
                const aiHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                const korbinBallProtected = ball.korbinBigBackProtected && player.korbinBigBackPowerActive;
                if (aiHypnoticLocked || korbinBallProtected) return;

                if (!aiPlayer.hasBall && !player.hasBall) {
                    if (playerDistToBall < player.r + ball.r + 25) {
                        return;
                    }

                    const playerDist = Math.sqrt((player.x - aiPlayer.x)**2 + (player.y - aiPlayer.y)**2);
                    if (player.isDribbling && playerDist < 50) {
                        aiPlayer.isStunned = true;
                        aiPlayer.stunEndTime = now + 500;
                        aiPlayer.lastBallPickupAttempt = now;
                        showNotification('ai got stunned for trying to steal while youre dribbling lol', 'success');
                    } else {
                        aiPlayer.hasBall = true;
                        ball.vx = 0;
                        ball.vy = 0;
                    }
                }
            }

            if (aiPlayer.hasBall) {
                let faceDir = 0;
                if (Math.abs(aiPlayer.vx) > 0.1 || Math.abs(aiPlayer.vy) > 0.1) {
                    faceDir = Math.atan2(aiPlayer.vy, aiPlayer.vx);
                } else {
                    const goalX = margin;
                    const goalY = H/2;
                    faceDir = Math.atan2(goalY - aiPlayer.y, goalX - aiPlayer.x);
                }

                ball.x = aiPlayer.x + Math.cos(faceDir) * (aiPlayer.r + ball.r + 3);
                ball.y = aiPlayer.y + Math.sin(faceDir) * (aiPlayer.r + ball.r + 3);
                ball.vx = aiPlayer.vx;
                ball.vy = aiPlayer.vy;
            }
        }

        function aiThink() {
            if (aiPlayer.isStunned) return;

            const now = performance.now();
            const distToBall = Math.sqrt((ball.x - aiPlayer.x)**2 + (ball.y - aiPlayer.y)**2);
            const distToPlayer = Math.sqrt((player.x - aiPlayer.x)**2 + (player.y - aiPlayer.y)**2);
            const goalX = margin;
            const goalY = H/2;

            const distToGoal = Math.sqrt((goalX - aiPlayer.x)**2 + (goalY - aiPlayer.y)**2);
            const timeSinceLastShot = now - (aiPlayer.lastShotTime || 0);
            
            const shouldShootAggressively = timeSinceLastShot > 800 && distToGoal < 400;
            
            if (aiPlayer.hasBall) {
                aiPlayer.state = 'shoot';
            } else if (shouldShootAggressively && !player.hasBall && Math.random() < 0.7) {
                aiPlayer.state = 'shoot';
                if (distToBall < 80) {
                    const shootHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                    const korbinBallProtected = ball.korbinBigBackProtected && player.korbinBigBackPowerActive;
                    if (!shootHypnoticLocked && !korbinBallProtected) {
                        aiPlayer.hasBall = true;
                        ball.vx = 0;
                        ball.vy = 0;
                    }
                }
            } else if (player.hasBall) {
                const distToPlayer = Math.sqrt((player.x - aiPlayer.x)**2 + (player.y - aiPlayer.y)**2);

                if (distToPlayer < 50 && Math.random() < 0.8) {
                    const timeSinceStolen = now - (aiPlayer.lastStolenFromTime || 0);
                    const korbinBallProtected = ball.korbinBigBackProtected && player.korbinBigBackPowerActive;
                    if (timeSinceStolen > 1000 && !korbinBallProtected) {
                        player.hasBall = false;
                        aiPlayer.hasBall = true;
                        ball.vx = 0;
                        ball.vy = 0;
                        aiPlayer.lastStolenFromTime = now;
                        showNotification('AI stole the ball!', 'warning');
                        aiPlayer.state = 'shoot';
                    }
                } else if (distToPlayer > 70) {
                    aiPlayer.state = 'chase';
                    aiPlayer.targetX = player.x;
                    aiPlayer.targetY = player.y;
                } else {
                    aiPlayer.state = 'defend';
                    aiPlayer.targetX = aiPlayer.defensiveX;
                    aiPlayer.targetY = player.y;
                }
            } else {
                if (shouldShootAggressively && distToBall < 60 && Math.random() < 0.5) {
                    aiPlayer.state = 'shoot';
                } else if (distToBall < distToPlayer * 1.5 || Math.random() < 0.6) {
                    aiPlayer.state = 'chase';
                    aiPlayer.targetX = ball.x;
                    aiPlayer.targetY = ball.y;
                } else {
                    aiPlayer.state = 'defend';
                    aiPlayer.targetX = aiPlayer.defensiveX;
                    aiPlayer.targetY = ball.y;
                }
            }
        }

        function aiMove(dt) {
            if (aiPlayer.state === 'shoot' || aiPlayer.isStunned) return;

            const dx = aiPlayer.targetX - aiPlayer.x;
            const dy = aiPlayer.targetY - aiPlayer.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist > 5) {
                const moveX = (dx / dist) * aiPlayer.accel;
                const moveY = (dy / dist) * aiPlayer.accel;

                aiPlayer.vx += moveX;
                aiPlayer.vy += moveY;

                const speed = Math.sqrt(aiPlayer.vx*aiPlayer.vx + aiPlayer.vy*aiPlayer.vy);
                if (speed > aiPlayer.maxSpd) {
                    aiPlayer.vx = (aiPlayer.vx / speed) * aiPlayer.maxSpd;
                    aiPlayer.vy = (aiPlayer.vy / speed) * aiPlayer.maxSpd;
                }
            }
        }

        function aiShoot(dt) {
            const now = performance.now();

            if (aiPlayer.state === 'shoot') {

                if (!aiPlayer.hasBall && !player.hasBall) {
                    const shootHypnoticLocked = player.sajaJinHypnoticShotActive || (performance.now() < (player.sajaJinHypnoticLockUntil || 0));
                    const korbinBallProtected = ball.korbinBigBackProtected && player.korbinBigBackPowerActive;
                    if (!shootHypnoticLocked && !korbinBallProtected) {
                        const ballDist = Math.sqrt((ball.x - aiPlayer.x)**2 + (ball.y - aiPlayer.y)**2);
                        if (ballDist < 120) {
                            aiPlayer.hasBall = true;
                            ball.vx = 0;
                            ball.vy = 0;
                        }
                    }
                }

                const ballDist = Math.sqrt((ball.x - aiPlayer.x)**2 + (ball.y - aiPlayer.y)**2);
                const canShootWithoutBall = ballDist < 50 && !player.hasBall;
                
                if (!aiPlayer.shootCharging && (aiPlayer.hasBall || canShootWithoutBall)) {
                    aiPlayer.shootCharging = true;
                    aiPlayer.shootStartTime = now;
                    aiPlayer.shootPower = 0;
                } else if (aiPlayer.shootCharging) {
                    const chargeTime = now - aiPlayer.shootStartTime;

                    const maxChargeTime = 5 + Math.random() * 10;

                    aiPlayer.shootPower = Math.min(chargeTime / maxChargeTime, 0.98 + aiPlayer.skill * 0.02);

                    if (chargeTime > 3 || aiPlayer.shootPower > 0.001) {
                        const goalX = margin;
                        const goalY = H/2;
                        let targetX = goalX;
                        let targetY = goalY;

                        const accuracy = aiPlayer.skill * 90;
                        const accuracyVariation = 50 - accuracy;
                        targetX += (Math.random() - 0.5) * accuracyVariation;
                        targetY += (Math.random() - 0.5) * accuracyVariation * 0.5;

                        const shotDir = Math.atan2(targetY - aiPlayer.y, targetX - aiPlayer.x);
                        const power = 18 + aiPlayer.shootPower * 25;

                        if (!aiPlayer.hasBall && canShootWithoutBall) {
                            ball.vx += Math.cos(shotDir) * power * 0.8;
                            ball.vy += Math.sin(shotDir) * power * 0.8;
                        } else {
                            ball.vx = Math.cos(shotDir) * power;
                            ball.vy = Math.sin(shotDir) * power;
                        }

                        aiPlayer.hasBall = false;
                        aiPlayer.shootCharging = false;
                        aiPlayer.lastShotTime = now;
                        aiPlayer.state = 'chase';
                       
                        showNotification('AI shoots aggressively!', 'warning');
                    }
                }
            }

            if (aiPlayer.state !== 'shoot') {
                aiPlayer.shootCharging = false;
                aiPlayer.shootPower = 0;
            }
        }

        function updateVFX(dt){
            const now = performance.now();

            vfx.trail = vfx.trail.filter(t=>performance.now()<t.end);
            if(vfx.trail.length){
                if(!ball._trail) ball._trail=[];
                ball._trail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                while(ball._trail.length>40) ball._trail.pop();
            } else {
                ball._trail = [];
            }


            vfx.shadowTrails = vfx.shadowTrails.filter(t=>performance.now()<t.end);
            if(vfx.shadowTrails.length){
                if(!ball._shadowTrail) ball._shadowTrail=[];
                ball._shadowTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                while(ball._shadowTrail.length>40) ball._shadowTrail.pop();
            } else {
                ball._shadowTrail = [];
            }


            vfx.voidTrails = vfx.voidTrails.filter(t=>performance.now()<t.end);
            if(player.dashing && currentStyle === 'robsan'){
                if(!player._voidDashTrail) player._voidDashTrail=[];
                player._voidDashTrail.unshift({x:player.x, y:player.y, time:performance.now()});
                while(player._voidDashTrail.length>20) player._voidDashTrail.pop();
            } else {
                player._voidDashTrail = [];
            }


            vfx.xdrakeSupernovaTrails = vfx.xdrakeSupernovaTrails.filter(t=>performance.now()<t.end);
            if(player.xdrakeSupernovaDashing && currentStyle === 'xdrake'){
                if(!player._xdrakeSupernovaTrail) player._xdrakeSupernovaTrail=[];
                player._xdrakeSupernovaTrail.unshift({x:player.x, y:player.y, time:performance.now()});
                while(player._xdrakeSupernovaTrail.length>25) player._xdrakeSupernovaTrail.pop();
            } else {
                player._xdrakeSupernovaTrail = [];
            }


            vfx.gojoRedTrail = vfx.gojoRedTrail.filter(t=>performance.now()<t.end);
            if(player.gojoRedActive && ball.vx !== 0 && ball.vy !== 0){
                if(!ball._gojoRedTrail) ball._gojoRedTrail=[];
                ball._gojoRedTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                while(ball._gojoRedTrail.length>40) ball._gojoRedTrail.pop();
            } else {
                ball._gojoRedTrail = [];
            }

            if(ball.hasOilTrail && now < ball.oilTrailEndTime){
                if(!ball._diddyOilTrail) ball._diddyOilTrail=[];
                ball._diddyOilTrail.unshift({x:ball.x, y:ball.y, time:now});
                while(ball._diddyOilTrail.length>35) ball._diddyOilTrail.pop();

                if(Math.random() < 0.4){
                    vfx.diddySlickTrail.push({
                        x: ball.x + (Math.random() - 0.5) * 10,
                        y: ball.y + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 1,
                        vy: (Math.random() - 0.5) * 1,
                        life: 600 + Math.random() * 300,
                        t: 0,
                        r: 1 + Math.random() * 2
                    });
                }
            } else {
                ball._diddyOilTrail = [];
                ball.hasOilTrail = false;
            }

            if(ball.hasGhostTrail && now < ball.ghostTrailEndTime){
                if(!ball._sajaJinGhostTrail) ball._sajaJinGhostTrail=[];
                ball._sajaJinGhostTrail.unshift({x:ball.x, y:ball.y, time:now});
                while(ball._sajaJinGhostTrail.length>50) ball._sajaJinGhostTrail.pop();

                if(Math.random() < 0.6){
                    vfx.sajaJinGhostTrail.push({
                        x: ball.x + (Math.random() - 0.5) * 20,
                        y: ball.y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 800 + Math.random() * 400,
                        t: 0,
                        r: 2 + Math.random() * 4,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            } else {
                ball._sajaJinGhostTrail = [];
                ball.hasGhostTrail = false;
            }

            vfx.leonardoDashTrail = vfx.leonardoDashTrail.filter(t => performance.now() < t.end);
            if (player.leonardoDashing && currentStyle === 'leonardo') {
                if (!player._leonardoDashTrail) player._leonardoDashTrail = [];
                player._leonardoDashTrail.unshift({ x: player.x, y: player.y, time: performance.now() });
                while (player._leonardoDashTrail.length > 20) player._leonardoDashTrail.pop();
            } else {
                player._leonardoDashTrail = [];
            }


            vfx.gojoPurpleTrail = vfx.gojoPurpleTrail.filter(t=>performance.now()<t.end);
            if (vfx.gojoPurpleTrail.length > 0 && ball.vx !== 0 && ball.vy !== 0) {
                if (!ball._gojoPurpleTrail) ball._gojoPurpleTrail = [];
                ball._gojoPurpleTrail.unshift({x: ball.x, y: ball.y, time: performance.now()});
                while(ball._gojoPurpleTrail.length > 50) ball._gojoPurpleTrail.pop();
            } else {
                ball._gojoPurpleTrail = [];
            }


            vfx.eddieVenomShotTrail = vfx.eddieVenomShotTrail.filter(t=>performance.now()<t.end);
            if (vfx.eddieVenomShotTrail.length > 0 && ball.vx !== 0 && ball.vy !== 0) {
                if (!ball._eddieVenomShotTrail) ball._eddieVenomShotTrail = [];
                ball._eddieVenomShotTrail.unshift({x: ball.x, y: ball.y, time: performance.now()});
                while(ball._eddieVenomShotTrail.length > 40) ball._eddieVenomShotTrail.pop();
            } else {
                ball._eddieVenomShotTrail = [];
            }

            vfx.zeusLightningTrail = vfx.zeusLightningTrail.filter(t=>performance.now()<t.end);
            if(player.zeusLightningActive && ball.vx !== 0 && ball.vy !== 0){
                if(!ball._zeusLightningTrail) ball._zeusLightningTrail=[];
                ball._zeusLightningTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                while(ball._zeusLightningTrail.length>30) ball._zeusLightningTrail.pop();
            } else {
                ball._zeusLightningTrail = [];
            }

            vfx.zeusOlympusFuryBallTrail = vfx.zeusOlympusFuryBallTrail.filter(t=>performance.now()<t.end);
            if(vfx.zeusOlympusFuryBallTrail.length > 0 && ball.vx !== 0 && ball.vy !== 0){
                if(!ball._zeusOlympusFuryBallTrail) ball._zeusOlympusFuryBallTrail=[];
                ball._zeusOlympusFuryBallTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                while(ball._zeusOlympusFuryBallTrail.length>50) ball._zeusOlympusFuryBallTrail.pop();
            } else {
                ball._zeusOlympusFuryBallTrail = [];
            }

            vfx.asherStarTrail = vfx.asherStarTrail.filter(t => performance.now() < t.end);
            if (ball.isHoming) {
                if (!ball._asherStarTrail) ball._asherStarTrail = [];
                ball._asherStarTrail.unshift({ x: ball.x, y: ball.y, time: performance.now() });
                while (ball._asherStarTrail.length > 40) ball._asherStarTrail.pop();
            } else {
                ball._asherStarTrail = [];
            }


            vfx.eddieSymbioteMontageAimAura = vfx.eddieSymbioteMontageAimAura.filter(a => performance.now() < a.end);
            vfx.blackPuddles = vfx.blackPuddles.filter(p => (p.t += dt) < p.life);


            vfx.sparks = vfx.sparks.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.sparks){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.98; p.vy*=0.98; }

            vfx.robsanParticles = vfx.robsanParticles.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.robsanParticles){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.95; p.vy*=0.95; }

            vfx.xdrakeFootworkDust = vfx.xdrakeFootworkDust.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.xdrakeFootworkDust){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.92; p.vy*=0.92; }


            vfx.gojoBlueOrbitParticles = vfx.gojoBlueOrbitParticles.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.gojoBlueOrbitParticles){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }


            for(const p of vfx.eddieWeAreParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life; const a = f*0.8;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9;

            }
            vfx.eddieWeAreParticles = vfx.eddieWeAreParticles.filter(p=> p.t < p.life);

            vfx.zeusLightningParticles = vfx.zeusLightningParticles.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.zeusLightningParticles){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.95; p.vy*=0.95; }

            vfx.zeusHeavenlyShieldWaves = vfx.zeusHeavenlyShieldWaves.filter(p=> (p.t+=dt) < p.life);
            for(const p of vfx.zeusHeavenlyShieldWaves){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }

            vfx.zeusLightningChargeEffect = vfx.zeusLightningChargeEffect.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.zeusLightningChargeEffect){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }

            vfx.zeusOlympusFuryPullLines = vfx.zeusOlympusFuryPullLines.filter(l => (l.t += dt) < l.life);

            vfx.zeusGroundScorches = vfx.zeusGroundScorches.filter(s => (s.t += dt) < s.life);

            vfx.ignisFireBreathParticles = vfx.ignisFireBreathParticles.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.ignisFireBreathParticles){ 
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.95; p.vy*=0.95; 
                
                if (currentStyle === 'ignis' && player.ignisFireBreathActive) {
                    const distToBall = Math.hypot(p.x - ball.x, p.y - ball.y);
                    if (distToBall < 20 && !player.hasBall) {
                        player.hasBall = true;
                        ball.vx = 0;
                        ball.vy = 0;
                        showNotification('fire claimed the ball!', 'success');
                    }
                }
            }

            vfx.ignisFireBreathLines = vfx.ignisFireBreathLines.filter(l => (l.t += dt) < l.life);

            vfx.ignisBlazeDashTrail = vfx.ignisBlazeDashTrail.filter(t => (performance.now() < t.end));

            vfx.ignisBlazeDashParticles = vfx.ignisBlazeDashParticles.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.ignisBlazeDashParticles){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.85; p.vy*=0.85; }

            vfx.ignisBlazeDashFlames = vfx.ignisBlazeDashFlames.filter(f => (f.t += dt) < f.life);
            for(const f of vfx.ignisBlazeDashFlames){ f.x+=f.vx*(dt/16); f.y+=f.vy*(dt/16); f.vx*=0.9; f.vy*=0.9; }

            vfx.ignisPhoenixBurstParticles = vfx.ignisPhoenixBurstParticles.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.ignisPhoenixBurstParticles){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }

            vfx.ignisPhoenixBurstChargeAura = vfx.ignisPhoenixBurstChargeAura.filter(a => (a.t += dt) < a.life);
            for(const a of vfx.ignisPhoenixBurstChargeAura){ a.x+=a.vx*(dt/16); a.y+=a.vy*(dt/16); a.vx*=0.92; a.vy*=0.92; }

            vfx.asherTeleportBurst = vfx.asherTeleportBurst.filter(p => (p.t += dt) < p.life);
            for (const p of vfx.asherTeleportBurst) { p.x += p.vx * (dt / 16); p.y += p.vy * (dt / 16); p.vx *= 0.96; p.vy *= 0.96; }
            vfx.asherArrivalGlimmer = vfx.asherArrivalGlimmer.filter(p => (p.t += dt) < p.life);
            for (const p of vfx.asherArrivalGlimmer) { p.x += p.vx * (dt / 16); p.y += p.vy * (dt / 16); p.vx *= 0.92; p.vy *= 0.92; }

            vfx.sixtySevenKidTextClones = vfx.sixtySevenKidTextClones.filter(t => (t.t += dt) < t.life);
            vfx.sixtySevenKidMayhemAura = vfx.sixtySevenKidMayhemAura.filter(a => (a.t += dt) < a.life);
            vfx.sixtySevenKidBlackoutOverlay = vfx.sixtySevenKidBlackoutOverlay.filter(o => (o.t += dt) < o.life);


            vfx.robsanChargeAura = vfx.robsanChargeAura.filter(a=> (a.t+=dt) < a.life);

            vfx.eclipseAura = vfx.eclipseAura.filter(a=> (a.t+=dt) < a.life);

            vfx.eclipseLines = vfx.eclipseLines.filter(l=> (l.t+=dt) < l.life);

            vfx.xdrakeApexAura = vfx.xdrakeApexAura.filter(a=> (a.t+=dt) < a.life);

            // Rabies VFX updates
            vfx.rabiesRagebaitTrail = vfx.rabiesRagebaitTrail.filter(t => (t.t += dt) < t.life);
            for (const t of vfx.rabiesRagebaitTrail) { 
                t.x += t.vx * (dt / 16); 
                t.y += t.vy * (dt / 16); 
                t.vx *= 0.95; 
                t.vy *= 0.95; 
                // Also move end points for thin lines
                if (t.endX && t.endY) {
                    t.endX += t.vx * (dt / 16);
                    t.endY += t.vy * (dt / 16);
                }
            }

            vfx.rabiesRagebaitVeins = vfx.rabiesRagebaitVeins.filter(v => (v.t += dt) < v.life);

            // Rage Bait Ball Following Lines - Track ball position
            vfx.rabiesRagebaitBallLines = vfx.rabiesRagebaitBallLines.filter(line => (line.t += dt) < line.life);
            if (vfx.rabiesRagebaitBallLines.length > 0 && ball.vx !== 0 && ball.vy !== 0) {
                if (!ball._ragebaitTrail) ball._ragebaitTrail = [];
                ball._ragebaitTrail.unshift({x: ball.x, y: ball.y, time: performance.now()});
                while (ball._ragebaitTrail.length > 60) ball._ragebaitTrail.pop(); // Keep more history for spacing
            } else {
                ball._ragebaitTrail = [];
            }

            vfx.rabiesSquidTentacles = vfx.rabiesSquidTentacles.filter(t => (t.t += dt) < t.life);

            vfx.rabiesSquidGlaze = vfx.rabiesSquidGlaze.filter(g => (g.t += dt) < g.life);
            for (const g of vfx.rabiesSquidGlaze) { g.x += g.vx * (dt / 16); g.y += g.vy * (dt / 16); g.vx *= 0.92; g.vy *= 0.92; }

            vfx.rabiesStealTentacles = vfx.rabiesStealTentacles.filter(t => (t.t += dt) < t.life);
            
            // Position steal tentacles and liquid effects
            for (const tentacle of vfx.rabiesStealTentacles) {
                if (tentacle.isLiquidCircle) {
                    // White liquid circle that contracts toward ball
                    const contractionProgress = tentacle.t * tentacle.contractionSpeed;
                    const currentRadius = Math.max(2, tentacle.liquidRadius * (1 - contractionProgress));
                    const circleAngle = tentacle.liquidPhase + tentacle.t * 0.02;
                    
                    tentacle.x = ball.x + Math.cos(circleAngle) * currentRadius;
                    tentacle.y = ball.y + Math.sin(circleAngle) * currentRadius;
                    
                } else if (tentacle.isLiquidParticle) {
                    // Liquid particles that flow toward ball center
                    const flowProgress = tentacle.t * tentacle.liquidFlowSpeed;
                    tentacle.x = tentacle.x + (ball.x - tentacle.x) * flowProgress * 0.1;
                    tentacle.y = tentacle.y + (ball.y - tentacle.y) * flowProgress * 0.1;
                    
                } else if (tentacle.isLiquidTrail) {
                    // Liquid trail particles that fade in place
                    // These stay where they are created as the ball moves
                    
                } else if (tentacle.isExtending && tentacle.grabbing) {
                    // Tentacles that extend from player to ball over time
                    // Update target to ball's CURRENT position (not original position)
                    const angleOffset = tentacle.originalAngleOffset || 0;
                    tentacle.targetX = ball.x + Math.cos(Math.atan2(ball.y - player.y, ball.x - player.x) + angleOffset) * 5;
                    tentacle.targetY = ball.y + Math.sin(Math.atan2(ball.y - player.y, ball.x - player.x) + angleOffset) * 5;
                    
                    if (tentacle.t <= tentacle.extensionDuration) {
                        const extensionProgress = Math.min(1, tentacle.t / tentacle.extensionDuration);
                        const eased = 1 - Math.pow(1 - extensionProgress, 2); // Ease out extension
                        
                        tentacle.x1 = tentacle.x;
                        tentacle.y1 = tentacle.y;
                        tentacle.x2 = tentacle.x + (tentacle.targetX - tentacle.x) * eased;
                        tentacle.y2 = tentacle.y + (tentacle.targetY - tentacle.y) * eased;
                        
                        // Check if tentacle has reached the ball
                        if (eased >= 0.95 && !tentacle.hasReachedBall) {
                            tentacle.hasReachedBall = true;
                            // Add impact effect when tentacle touches ball
                            for (let i = 0; i < 5; i++) {
                                const impactAngle = Math.random() * Math.PI * 2;
                                const impactSpeed = 2 + Math.random() * 3;
                                vfx.rabiesStealTentacles.push({
                                    x: tentacle.x2 + Math.cos(impactAngle) * 3,
                                    y: tentacle.y2 + Math.sin(impactAngle) * 3,
                                    targetX: tentacle.x2,
                                    targetY: tentacle.y2,
                                    life: 300 + Math.random() * 200,
                                    t: 0,
                                    width: 1 + Math.random(),
                                    segments: 1,
                                    grabbing: false,
                                    isImpactSpark: true
                                });
                            }
                        }
                    } else {
                        // After extension, tentacle shrinks as ball moves back to player
                        // Calculate how much the ball has moved back to player
                        if (ball.tweenToPlayer) {
                            const ballProgress = Math.min(1, (performance.now() - ball.tweenStartTime) / ball.tweenDuration);
                            const shrinkFactor = 1 - ballProgress; // Shrink from 100% to 0%
                            
                            // Start from player position
                            tentacle.x1 = tentacle.x;
                            tentacle.y1 = tentacle.y;
                            
                            // End point follows the ball but gets closer to player over time
                            const currentBallX = ball.tweenStartX + (ball.tweenTargetX - ball.tweenStartX) * ballProgress;
                            const currentBallY = ball.tweenStartY + (ball.tweenTargetY - ball.tweenStartY) * ballProgress;
                            
                            // Tentacle end point shrinks toward player
                            tentacle.x2 = tentacle.x + (currentBallX - tentacle.x) * shrinkFactor;
                            tentacle.y2 = tentacle.y + (currentBallY - tentacle.y) * shrinkFactor;
                            
                            // Store shrink factor for rendering
                            tentacle.shrinkFactor = shrinkFactor;
                        } else {
                            // Ball tween complete, tentacle fully retracted
                            tentacle.x1 = tentacle.x;
                            tentacle.y1 = tentacle.y;
                            tentacle.x2 = tentacle.x;
                            tentacle.y2 = tentacle.y;
                            tentacle.shrinkFactor = 0;
                        }
                    }
                    
                } else if (tentacle.grabbing) {
                    // Regular grabbing tentacles (fallback)
                    const progress = Math.min(1, tentacle.t / (tentacle.life * 0.6));
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    tentacle.x1 = tentacle.x;
                    tentacle.y1 = tentacle.y;
                    tentacle.x2 = tentacle.x + (tentacle.targetX - tentacle.x) * eased;
                    tentacle.y2 = tentacle.y + (tentacle.targetY - tentacle.y) * eased;
                } else {
                    // Non-grabbing tentacles (VFX particles)
                    tentacle.x1 = tentacle.x;
                    tentacle.y1 = tentacle.y;
                    tentacle.x2 = tentacle.targetX || tentacle.x;
                    tentacle.y2 = tentacle.targetY || tentacle.y;
                }
            }

            vfx.rabiesPookiePowerPfps = vfx.rabiesPookiePowerPfps.filter(p => (p.t += dt) < p.life);

            vfx.rabiesPookiePowerAura = vfx.rabiesPookiePowerAura.filter(a => (a.t += dt) < a.life);
            for (const a of vfx.rabiesPookiePowerAura) { a.x += a.vx * (dt / 16); a.y += a.vy * (dt / 16); a.vx *= 0.94; a.vy *= 0.94; }

            // Squid Glaze ball circling effect
            const currentTime = performance.now();
            if (ball.squidGlazed && currentTime < ball.squidGlazeEndTime) {
                if (Math.random() < 0.4) {
                    const angle = currentTime * 0.003; // Slow rotation
                    const radius = ball.r + 8 + Math.sin(currentTime * 0.005) * 4;
                    for (let i = 0; i < 3; i++) {
                        const circleAngle = angle + (i * Math.PI * 2 / 3);
                        vfx.rabiesSquidGlaze.push({
                            x: ball.x + Math.cos(circleAngle) * radius,
                            y: ball.y + Math.sin(circleAngle) * radius,
                            vx: Math.cos(circleAngle + Math.PI / 2) * 2,
                            vy: Math.sin(circleAngle + Math.PI / 2) * 2,
                            r: 2 + Math.random() * 3,
                            life: 800 + Math.random() * 400,
                            t: 0,
                            isWhiteCircling: true // Flag for white circling particles
                        });
                    }
                }
            } else if (ball.squidGlazed && currentTime >= ball.squidGlazeEndTime) {
                ball.squidGlazed = false; // Clean up when effect ends
            }

            vfx.gojoPurpleCombineVFX = vfx.gojoPurpleCombineVFX.filter(v=> (v.t+=dt) < v.life);


            for(const aura of vfx.eddieWeAreAura){
                aura.t += dt;

            }
            vfx.eddieWeAreAura = vfx.eddieWeAreAura.filter(a => a.t < a.life);

            vfx.zeusHeavenlyShieldAura = vfx.zeusHeavenlyShieldAura.filter(a => (a.t+=dt) < a.life);

            vfx.zeusOlympusFuryAura = vfx.zeusOlympusFuryAura.filter(a => (a.t+=dt) < a.life);

            for(const line of vfx.eddieVenomTendrils){
                line.t += dt;

                line.endX = ball.x;
                line.endY = ball.y;
            }
            vfx.eddieVenomTendrils = vfx.eddieVenomTendrils.filter(l => l.t < l.life);

            vfx.eddieVenomBallSwirl = vfx.eddieVenomBallSwirl.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.eddieVenomBallSwirl){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }

            vfx.robsanGroundRupture = vfx.robsanGroundRupture.filter(r => (r.t += dt) < r.life);
            vfx.robsanEclipseWisps = vfx.robsanEclipseWisps.filter(w => (w.t += dt) < w.life);
            for(const wisp of vfx.robsanEclipseWisps){ wisp.x+=wisp.vx*(dt/16); wisp.y+=wisp.vy*(dt/16); wisp.vx*=0.95; wisp.vy*=0.95; }
            vfx.robsanVoidPuffs = vfx.robsanVoidPuffs.filter(p => (p.t += dt) < p.life);
            vfx.xdrakeSupernovaGroundCrack = vfx.xdrakeSupernovaGroundCrack.filter(c => (c.t += dt) < c.life);
            vfx.xdrakeFootworkLeaves = vfx.xdrakeFootworkLeaves.filter(l => (l.t += dt) < l.life);
            for(const leaf of vfx.xdrakeFootworkLeaves){ leaf.x+=leaf.vx*(dt/16); leaf.y+=leaf.vy*(dt/16); leaf.vx*=0.9; leaf.vy*=0.9; }
            vfx.xdrakeAncientApexGroundBurst = vfx.xdrakeAncientApexGroundBurst.filter(b => (b.t += dt) < b.life);
            for(const b of vfx.xdrakeAncientApexGroundBurst){ b.x+=b.vx*(dt/16); b.y+=b.vy*(dt/16); b.vx*=0.9; b.vy*=0.9; }
            vfx.gojoRedExplosion = vfx.gojoRedExplosion.filter(e => (e.t += dt) < e.life);
            vfx.gojoLapseBluePullEffect = vfx.gojoLapseBluePullEffect.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.gojoLapseBluePullEffect){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.85; p.vy*=0.85; }
            vfx.gojoPurpleArcs = vfx.gojoPurpleArcs.filter(a => (a.t += dt) < a.life);
            vfx.eddieWeAreRipples = vfx.eddieWeAreRipples.filter(r => (r.t += dt) < r.life);
            vfx.eddieTeleportFlicker = vfx.eddieTeleportFlicker.filter(f => (f.t += dt) < f.life);

            vfx.hudsonSpeedLines = vfx.hudsonSpeedLines.filter(line => (line.t += dt) < line.life);
            vfx.hudsonEnergyWaves = vfx.hudsonEnergyWaves.filter(wave => (wave.t += dt) < wave.life);
            vfx.hudsonEmperorDribbleTrail = vfx.hudsonEmperorDribbleTrail.filter(trail => (trail.t += dt) < trail.life);
            vfx.hudsonEmperorDribbleParticles = vfx.hudsonEmperorDribbleParticles.filter(particle => (particle.t += dt) < particle.life);
            vfx.hudsonEmperorDribbleAura = vfx.hudsonEmperorDribbleAura.filter(aura => (aura.t += dt) < aura.life);

            vfx.robsanShadowClones = vfx.robsanShadowClones.filter(clone => (clone.t += dt) < clone.life);
            vfx.robsanVoidRifts = vfx.robsanVoidRifts.filter(rift => (rift.t += dt) < rift.life);

            vfx.xdrakeNatureSpirits = vfx.xdrakeNatureSpirits.filter(spirit => (spirit.t += dt) < spirit.life);
            for(const spirit of vfx.xdrakeNatureSpirits) {
                spirit.x += spirit.vx * (dt / 16);
                spirit.y += spirit.vy * (dt / 16);
                spirit.vx *= 0.98;
                spirit.vy *= 0.98;
            }
            vfx.xdrakeTerraforms = vfx.xdrakeTerraforms.filter(terra => (terra.t += dt) < terra.life);

            vfx.gojoInfinityBarriers = vfx.gojoInfinityBarriers.filter(barrier => (barrier.t += dt) < barrier.life);
            vfx.gojoDomainExpansions = vfx.gojoDomainExpansions.filter(domain => (domain.t += dt) < domain.life);

            vfx.eddieSymbioteSpikes = vfx.eddieSymbioteSpikes.filter(spike => (spike.t += dt) < spike.life);
            vfx.eddieVenomDrops = vfx.eddieVenomDrops.filter(drop => (drop.t += dt) < drop.life);
            for(const drop of vfx.eddieVenomDrops) {
                drop.x += drop.vx * (dt / 16);
                drop.y += drop.vy * (dt / 16);
                drop.vx *= 0.95;
                drop.vy *= 0.95;
            }

            vfx.zeusThunderClouds = vfx.zeusThunderClouds.filter(cloud => (cloud.t += dt) < cloud.life);
            vfx.zeusLightningBolts = vfx.zeusLightningBolts.filter(bolt => (bolt.t += dt) < bolt.life);

            vfx.energyResidue = vfx.energyResidue.filter(residue => (residue.t += dt) < residue.life);
            vfx.fieldCracks = vfx.fieldCracks.filter(crack => (crack.t += dt) < crack.life);
            vfx.shockwaveRings = vfx.shockwaveRings.filter(ring => (ring.t += dt) < ring.life);


            vfx.shockwaves = vfx.shockwaves.filter(s=> (s.t+=dt) < s.life);
            for(const s of vfx.shockwaves){
                const t = s.t/s.life; const r = s.r + t*80;
                const a = (1-t)*0.8;

                const sColor1 = getRGBA(s.color1, a);
                const sColor2 = getRGBA(s.color2, a * 0.8);

                ctx.strokeStyle=sColor1;
                ctx.lineWidth=3; ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.stroke();
                ctx.strokeStyle=sColor2;
                ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(s.x,s.y,r*1.12,0,Math.PI*2); ctx.stroke();
            }
            for(const l of vfx.lines){
                const t=l.t/l.life; const a=(1-t)*0.6;
                const x2 = l.x + Math.cos(l.a)*l.len;
                const y2 = l.y + Math.sin(l.a)*l.len;
                ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=2;
                ctx.beginPath(); ctx.moveTo(l.x,l.y); ctx.lineTo(x2,y2); ctx.stroke();
            }

            for(const a of vfx.robsanAura){
                const progress = a.t / a.life;
                const currentRadius = lerp(a.radius * 0.5, a.radius * 2, progress);
                const opacity = (1 - progress) * 0.7;

                const grd = ctx.createRadialGradient(a.x, a.y, a.radius * 0.5, a.x, a.y, currentRadius);
                grd.addColorStop(0, `rgba(49, 46, 129, ${opacity * 0.8})`);
                grd.addColorStop(0.7, `rgba(76, 29, 149, ${opacity * 0.4})`);
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(a.x, a.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            if (vfx.voidTrails.length && player._voidDashTrail && player._voidDashTrail.length > 1) {
                for(let i=0;i<player._voidDashTrail.length-1;i++){
                    const p=player._voidDashTrail[i], n=player._voidDashTrail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/(VOID_DASH_DURATION + 100), 0, 1)*0.9;
                    const w = lerp(vfx.voidTrails[0].w,2,i/player._voidDashTrail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,getRGBA(vfx.voidTrails[0].trailColorStart,a));
                    g.addColorStop(1,getRGBA(vfx.voidTrails[0].trailColorEnd,a*0.6));
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }
            }

            if (vfx.xdrakeSupernovaTrails.length && player._xdrakeSupernovaTrail && player._xdrakeSupernovaTrail.length > 1) {
                for(let i=0;i<player._xdrakeSupernovaTrail.length-1;i++){
                    const p=player._xdrakeSupernovaTrail[i], n=player._xdrakeSupernovaTrail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/(XDRAKE_SUPERNOVA_DASH_DURATION + 100), 0, 1)*0.9;
                    const w = lerp(vfx.xdrakeSupernovaTrails[0].w,2,i/player._xdrakeSupernovaTrail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorStart,a));
                    g.addColorStop(1,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorEnd,a*0.6));
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }



            }

            vfx.lincolnShrekTrail = vfx.lincolnShrekTrail.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.lincolnShrekTrail) {
                p.x += p.vx * (dt / 16);
                p.y += p.vy * (dt / 16);
                p.vx *= 0.95;
                p.vy *= 0.95;
            }

            vfx.lincolnShrekParticles = vfx.lincolnShrekParticles.filter(p => (p.t += dt) < p.life);
            for(const p of vfx.lincolnShrekParticles) {
                p.x += p.vx * (dt / 16);
                p.y += p.vy * (dt / 16);
                p.vx *= 0.96;
                p.vy *= 0.96;
            }
        }

        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

              function drawField(){
            ctx.save();
            ctx.strokeStyle='rgba(255,255,255,0.7)';
            ctx.lineWidth=3;
            roundRect(ctx, margin, margin, W-2*margin, H-2*margin, 16);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(W/2, margin); ctx.lineTo(W/2, H-margin); ctx.stroke();
            ctx.beginPath(); ctx.arc(W/2, H/2, 70, 0, Math.PI*2); ctx.stroke();
            drawGoal(margin, H/2-goalW/2, true);
            drawGoal(W-margin-goalDepth, H/2-goalW/2, false);
            ctx.restore();
        }

        function drawGoal(x,y,left){
            ctx.save();
            ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=2.5;
            ctx.strokeRect(x, y, goalDepth, goalW);
            const areaW=70, areaH=goalW+60;
            const gx = left ? margin : W-margin-areaW;
            ctx.strokeRect(gx, H/2-areaH/2, areaW, areaH);
            ctx.restore();
        }

        function drawPlayer(){
            ctx.save();

            const currentR = player.r;

            for(const scorch of vfx.zeusGroundScorches){
                const progress = scorch.t / scorch.life;
                const opacity = (1 - progress) * 0.4;
                const currentRadius = scorch.r * (1 + progress * 0.5);

                const grd = ctx.createRadialGradient(scorch.x, scorch.y, 0, scorch.x, scorch.y, currentRadius);
                const rootStyle = getComputedStyle(document.documentElement);
                const startColor = rootStyle.getPropertyValue('--zeus-olympus-aura-start').trim();
                const endColor = rootStyle.getPropertyValue('--zeus-primary').trim();
                grd.addColorStop(0, getRGBA(startColor, opacity * 0.8));
                grd.addColorStop(1, getRGBA(endColor, opacity * 0.2));
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(scorch.x, scorch.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            }


            if (player.spinning && currentStyle === 'robsan') {
                const spinProgress = 1 - (player.spinTimer / ROBSAN_SPIN_DURATION);
                const auraRadius = player.r * (1 + spinProgress * 1.5);
                const auraOpacity = (1 - spinProgress) * 0.6;
                const pulseOffset = Math.sin(performance.now() * 0.02) * 2;

                const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                grd.addColorStop(0, `rgba(49, 46, 129, ${auraOpacity * 0.8})`);
                grd.addColorStop(0.5, `rgba(76, 29, 149, ${auraOpacity * 0.5})`);
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                ctx.fill();

                for (let i = 0; i < 3; i++) {
                    const offset = i * (spinProgress * 8);
                    const angle = spinProgress * Math.PI * 4 + i * (Math.PI / 6);
                    const sx = player.x + Math.cos(angle) * offset;
                    const sy = player.y + Math.sin(angle) * offset;
                    const shadowOpacity = (1 - spinProgress) * (0.3 - i * 0.1);
                    if (shadowOpacity > 0) {
                        ctx.fillStyle = `rgba(0,0,0,${shadowOpacity})`;
                        ctx.beginPath();
                        ctx.arc(sx, sy, player.r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }


            if (player.charging && currentStyle === 'robsan') {
                const chargeProgress = 1 - (player.chargeTimer / ROBSAN_CHARGE_DURATION);
                const auraRadius = player.r * (1.2 + chargeProgress * 0.8);
                const auraOpacity = chargeProgress * 0.5 + 0.2;
                const pulseOffset = Math.sin(performance.now() * 0.05) * 3;

                const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                grd.addColorStop(0, `rgba(30, 0, 50, ${auraOpacity * 0.6})`);
                grd.addColorStop(0.5, `rgba(40, 0, 60, ${auraOpacity * 0.3})`);
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const aura of vfx.eclipseAura){
                const progress = aura.t / aura.life;
                const currentAuraRadius = lerp(aura.radius * 0.5, aura.radius * 2, progress);
                const opacity = (1 - progress) * 0.6;

                const grd = ctx.createRadialGradient(aura.x, aura.y, aura.radius * 0.5, aura.x, aura.y, currentAuraRadius);
                grd.addColorStop(0, `rgba(0, 0, 0, ${opacity * 0.8})`);
                grd.addColorStop(0.7, `rgba(30, 0, 50, ${opacity * 0.4})`);
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(aura.x, aura.y, currentAuraRadius, 0, Math.PI * 2);
                ctx.fill();
            }


            if (player.xdrakeSupernovaDashing && currentStyle === 'xdrake') {
                const dashProgress = 1 - (player.xdrakeSupernovaDashTimer / XDRAKE_SUPERNOVA_DASH_DURATION);
                const auraRadius = player.r * (1.2 + dashProgress * 0.8);
                const auraOpacity = (1 - dashProgress) * 0.7;
                const pulseOffset = Math.sin(performance.now() * 0.08) * 4;

                const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                const rootStyle = getComputedStyle(document.documentElement);
                const startColor = rootStyle.getPropertyValue('--xdrake-green-primary').trim();
                const endColor = rootStyle.getPropertyValue('--xdrake-green-secondary').trim();

                grd.addColorStop(0, getRGBA(startColor, auraOpacity * 0.8));
                grd.addColorStop(0.5, getRGBA(endColor, auraOpacity * 0.5));
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                ctx.fill();
            }


            if (player.xdrakeAncientApexCharging && currentStyle === 'xdrake') {
                const now = performance.now();
                const chargeProgress = clamp((now - player.ancientApexChargeTimer) / XDRAKE_ANCIENT_APEX_CHARGE_DURATION, 0.0, 1.0);
                const auraRadius = player.r * (1.5 + chargeProgress * 1.5);
                const auraOpacity = chargeProgress * 0.6 + 0.2;
                const pulseOffset = Math.sin(now * 0.08) * 5;

                const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                const rootStyle = getComputedStyle(document.documentElement);
                const startColor = rootStyle.getPropertyValue('--xdrake-apex-aura-start').trim();
                const midColor = rootStyle.getPropertyValue('--xdrake-green-primary').trim();
                const endColor = rootStyle.getPropertyValue('--xdrake-apex-aura-end').trim();

                grd.addColorStop(0, getRGBA(startColor, auraOpacity * 0.9));
                grd.addColorStop(0.5, getRGBA(midColor, auraOpacity * 0.7));
                grd.addColorStop(1, getRGBA(endColor, auraOpacity * 0.4));
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                ctx.fill();
            }


            if (currentStyle === 'gojo' && (player.gojoRedActive || player.gojoLapseBlueActive || player.gojoPurpleActive || player.gojoRedCharging)) {
                const glowStrength = Math.sin(performance.now() * 0.01) * 0.1 + 0.3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(99, 102, 241, ${glowStrength})`;
            }


            if (currentStyle === 'eddie' && player.eddieWeAreActive) {
                const now = performance.now();
                const progress = 1 - (player.eddieWeAreEndTime - now) / EDDIE_WE_ARE_DURATION;
                const auraRadius = currentR * (1.2 + Math.sin(now * 0.02) * 0.2);
                const auraOpacity = 0.5 + Math.cos(now * 0.03) * 0.2;

                const grd = ctx.createRadialGradient(player.x, player.y, currentR, player.x, player.y, auraRadius);
                grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-we-are-aura').trim(), auraOpacity * 0.8));
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 20;
                ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-we-are-glow').trim();
            }

            if (currentStyle === 'eddie' && player.eddieSymbioteMontageActive && player.eddieSymbioteMontagePhase === 'aiming') {
                for(const aura of vfx.eddieSymbioteMontageAimAura){
                    const progress = (performance.now() - aura.t) / aura.life;
                    const currentAuraRadius = lerp(player.r * 1.5, aura.radius, progress);
                    const opacity = (1 - progress) * 0.7;

                    const grd = ctx.createRadialGradient(aura.x, aura.y, player.r, aura.x, aura.y, currentAuraRadius);
                    grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-symbiote-montage-trail').trim(), opacity * 0.8));
                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(aura.x, aura.y, currentAuraRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                const now = performance.now();
                const chargeProgress = clamp((now - player.zeusLightningChargeStartTime) / ZEUS_LIGHTNING_CHARGE_DURATION, 0.0, 1.0);
                const auraRadius = player.r * (1.2 + chargeProgress * 0.8);
                const auraOpacity = chargeProgress * 0.7;
                const pulseOffset = Math.sin(now * 0.1) * 3;

                const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                const rootStyle = getComputedStyle(document.documentElement);
                grd.addColorStop(0, getRGBA(rootStyle.getPropertyValue('--zeus-lightning-trail-start'), auraOpacity * 0.8));
                grd.addColorStop(0.5, getRGBA(rootStyle.getPropertyValue('--zeus-lightning-trail-end'), auraOpacity * 0.5));
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                ctx.fill();
            }

            if (currentStyle === 'zeus' && player.zeusHeavenlyShieldActive) {
                for (const aura of vfx.zeusHeavenlyShieldAura) {
                    const progress = aura.t / aura.life;
                    const currentRadius = lerp(aura.radius * 0.5, aura.radius, progress);
                    const opacity = (1 - progress) * 0.6;

                    const grd = ctx.createRadialGradient(aura.x, aura.y, player.r, aura.x, aura.y, currentRadius);
                    grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--zeus-shield-aura'), opacity * 0.8));
                    grd.addColorStop(0.8, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--zeus-shield-glow'), opacity * 0.4));
                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(aura.x, aura.y, currentRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming') {
                for(const aura of vfx.zeusOlympusFuryAura){
                    const progress = (performance.now() - aura.t) / aura.life;
                    const currentAuraRadius = lerp(player.r * 1.5, aura.radius, progress);
                    const opacity = (1 - progress) * 0.7;

                    const grd = ctx.createRadialGradient(aura.x, aura.y, player.r, aura.x, aura.y, currentAuraRadius);
                    grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--zeus-olympus-aura-start'), opacity * 0.8));
                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(aura.x, aura.y, currentAuraRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }


            if(player.hasBall && currentStyle === 'hudson'){
                const grd=ctx.createRadialGradient(player.x, player.y, player.r*0.6, player.x, player.y, player.r*1.8);
                grd.addColorStop(0,'rgba(79,209,197,0.35)');
                grd.addColorStop(1,'rgba(79,209,197,0)');
                ctx.fillStyle=grd;
                ctx.beginPath(); ctx.arc(player.x, player.y, player.r*2.2, 0, Math.PI*2); ctx.fill();
            }


            let playerFillColor = '#2dd4bf';
            if (currentStyle === 'xdrake') {
                if (player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging) {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--xdrake-green-primary');
                } else {
                    playerFillColor = '#2dd4bf';
                }
            } else if (currentStyle === 'gojo') {
                playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-primary');
            } else if (currentStyle === 'eddie') {
                if (player.eddieWeAreActive || player.eddieAwakeningActive) {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-secondary');
                } else {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-primary');
                }
            } else if (currentStyle === 'zeus') {
                playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--zeus-primary');
                if (player.zeusHeavenlyShieldActive || player.zeusLightningCharging || player.zeusOlympusFuryActive) {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--zeus-secondary');
                }
            } else if (currentStyle === 'ignis') {
                playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--ignis-primary');
                if (player.ignisFireBreathActive || player.ignisBlazeDashing || player.ignisPhoenixBurstCharging) {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--ignis-fire-core');
                }
            } else if (currentStyle === 'cristiano') {
                if (player.cristianoPortugueseSpiritActive) {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--cristiano-primary');
                } else {
                    playerFillColor = '#2dd4bf';
                }
            } else if (currentStyle === 'wally') {
                if (player.wallyFlashyLightningActive) {
                    playerFillColor = '#ffffff';
                } else {
                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--wally-primary');
                }
            }

            if (currentStyle === 'wally') {
                if (player.wallyRocketBoostActive) {
                    const boostPulse = Math.sin(performance.now() * 0.02) * 0.3 + 0.7;
                    const boostRadius = player.r * (2.0 + boostPulse * 0.5);
                    const boostOpacity = boostPulse * 0.8;

                    const boostGrd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, boostRadius);
                    boostGrd.addColorStop(0, `rgba(0, 188, 212, ${boostOpacity * 0.9})`);
                    boostGrd.addColorStop(0.5, `rgba(21, 101, 192, ${boostOpacity * 0.6})`);
                    boostGrd.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = boostGrd;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, boostRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (player.wallySpeedForceActive) {
                    const domeOpacity = 0.3 + Math.sin(performance.now() * 0.008) * 0.2;
                    ctx.strokeStyle = `rgba(0, 188, 212, ${domeOpacity})`;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, WALLY_SPEED_FORCE_RANGE, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                if (player.wallyFlashyLightningActive) {
                    const lightningPulse = Math.sin(performance.now() * 0.025) * 0.4 + 0.8;
                    const lightningRadius = player.r * (3.0 + lightningPulse * 1.0);
                    const lightningOpacity = lightningPulse * 0.9;

                    const lightningGrd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, lightningRadius);
                    lightningGrd.addColorStop(0, `rgba(255, 255, 255, ${lightningOpacity * 0.8})`);
                    lightningGrd.addColorStop(0.3, `rgba(0, 188, 212, ${lightningOpacity * 0.7})`);
                    lightningGrd.addColorStop(0.7, `rgba(129, 212, 250, ${lightningOpacity * 0.4})`);
                    lightningGrd.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = lightningGrd;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, lightningRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                }
            }

            if (currentStyle === 'eddie' && player.eddieAwakeningActive) {
                const awakePulse = Math.sin(performance.now() * 0.008) * 0.4 + 0.6;
                const awakeRadius = player.r * (2.5 + awakePulse * 0.5);
                const awakeOpacity = awakePulse * 0.7;

                const awakeGrd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, awakeRadius);
                awakeGrd.addColorStop(0, `rgba(0, 0, 0, ${awakeOpacity * 0.8})`);
                awakeGrd.addColorStop(0.4, `rgba(20, 20, 30, ${awakeOpacity * 0.6})`);
                awakeGrd.addColorStop(0.8, `rgba(40, 40, 60, ${awakeOpacity * 0.3})`);
                awakeGrd.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = awakeGrd;
                ctx.beginPath();
                ctx.arc(player.x, player.y, awakeRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 25;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            }

            if (currentStyle === 'cristiano' && player.cristianoPortugueseSpiritActive) {
                const spiritPulse = Math.sin(performance.now() * 0.012) * 0.5 + 0.7;
                const spiritRadius = player.r * (3.5 + spiritPulse * 0.8);
                const spiritOpacity = spiritPulse * 0.8;

                ctx.save();

                const redAura = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, spiritRadius);
                redAura.addColorStop(0, `rgba(220, 38, 38, ${spiritOpacity * 0.6})`);
                redAura.addColorStop(0.4, `rgba(255, 50, 50, ${spiritOpacity * 0.4})`);
                redAura.addColorStop(0.7, `rgba(255, 215, 0, ${spiritOpacity * 0.3})`);
                redAura.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = redAura;
                ctx.beginPath();
                ctx.arc(player.x, player.y, spiritRadius, 0, Math.PI * 2);
                ctx.fill();

                const greenCore = ctx.createRadialGradient(player.x, player.y, player.r * 0.5, player.x, player.y, spiritRadius * 0.6);
                greenCore.addColorStop(0, `rgba(22, 163, 74, ${spiritOpacity * 0.7})`);
                greenCore.addColorStop(0.5, `rgba(34, 197, 94, ${spiritOpacity * 0.5})`);
                greenCore.addColorStop(1, `rgba(22, 163, 74, ${spiritOpacity * 0.2})`);
                ctx.fillStyle = greenCore;
                ctx.beginPath();
                ctx.arc(player.x, player.y, spiritRadius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 30;
                ctx.shadowColor = `rgba(255, 215, 0, ${spiritOpacity})`;

                ctx.restore();
            }

            ctx.fillStyle=playerFillColor;
            ctx.strokeStyle='rgba(0,0,0,.45)';
            ctx.lineWidth=2;
            ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.shadowBlur = 0;

            if(player.awakeningActive){
                ctx.save();
                ctx.globalAlpha = 0.4;
                const auraSize = player.r * 2.5;
                const gradient = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraSize);
                gradient.addColorStop(0, 'rgba(0, 100, 200, 0.6)');
                gradient.addColorStop(0.7, 'rgba(0, 50, 150, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 100, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(player.x, player.y, auraSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            const ang=Math.atan2(mouse.y-player.y, mouse.x-player.x);
            const ex=player.x+Math.cos(ang)*player.r*0.5;
            const ey=player.y+Math.sin(ang)*player.r*0.5;
            if(player.awakeningActive){
                ctx.save();
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 10;
                ctx.fillStyle='#00FFFF';
                ctx.beginPath(); 
                ctx.arc(ex, ey, 3.5, 0, Math.PI*2); 
                ctx.fill();
                ctx.restore();
            } else {
                ctx.fillStyle='#083344'; ctx.beginPath(); ctx.arc(ex, ey, 3.5, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();


            if(player.hasBall && !player.gojoPurpleActive && !player.gojoRedCharging && !(currentStyle === 'eddie' && player.eddieSymbioteMontageActive) &&
               !player.zeusLightningCharging && !(currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming')){
                ctx.save();
                ctx.strokeStyle='rgba(255,255,255,.8)'; ctx.setLineDash([8,6]); ctx.lineWidth=2;
                ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(ball.x, ball.y); ctx.stroke();
                ctx.restore();
            }


            if (player.gojoLapseBlueActive && player.gojoLapseBlueBall) {
                const lb = player.gojoLapseBlueBall;
                ctx.save();
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-primary');
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-secondary');
                ctx.lineWidth = 2;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(49, 130, 206, 0.7)`;
                ctx.beginPath();
                ctx.arc(lb.x, lb.y, lb.r, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }


            if (player.gojoPurpleActive) {
                ctx.save();
                ctx.shadowBlur = 20;

                if (player.gojoPurpleLeftBall) {
                    const lb = player.gojoPurpleLeftBall;
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-primary');
                    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-secondary');
                    ctx.shadowColor = `rgba(229, 62, 62, 0.7)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(lb.x, lb.y, lb.r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }

                if (player.gojoPurpleRightBall) {
                    const rb = player.gojoPurpleRightBall;
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-primary');
                    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-secondary');
                    ctx.shadowColor = `rgba(49, 130, 206, 0.7)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(rb.x, rb.y, rb.r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

      function drawBall(){

            if(vfx.trail.length && ball._trail && ball._trail.length > 1){
                for(let i=0;i<ball._trail.length-1;i++){
                    const p=ball._trail[i], n=ball._trail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/450, 0, 1)*0.8;
                    const w = lerp(14,2,i/ball._trail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,`rgba(96,165,250,${a})`);
                    g.addColorStop(1,`rgba(244,114,182,${a})`);
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }
            }

            if(vfx.shadowTrails.length && ball._shadowTrail && ball._shadowTrail.length > 1){
                for(let i=0;i<ball._shadowTrail.length-1;i++){
                    const p=ball._shadowTrail[i], n=ball._shadowTrail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/600, 0, 1)*0.9;
                    const w = lerp(20,4,i/ball._shadowTrail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,`rgba(20, 0, 40, ${a})`);
                    g.addColorStop(1,`rgba(10, 0, 20, ${a * 0.6})`);
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }
            }

            if (vfx.xdrakeApexAura.length && ball._xdrakeApexTrail && ball._xdrakeApexTrail.length > 1) {
                 for(let i = 0; i < ball._xdrakeApexTrail.length - 1; i++){
                    const p = ball._xdrakeApexTrail[i], n = ball._xdrakeApexTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / (vfx.xdrakeApexAura[0].life + 100), 0, 1) * 0.9;
                    const w = lerp(24, 6, i / ball._xdrakeApexTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    const rootStyle = getComputedStyle(document.documentElement);
                    const startColor = rootStyle.getPropertyValue('--xdrake-apex-ball-trail-start').trim();
                    const endColor = rootStyle.getPropertyValue('--xdrake-apex-ball-trail-end').trim();
                    g.addColorStop(0, getRGBA(startColor, a));
                    g.addColorStop(1, getRGBA(endColor, a * 0.7));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                 }
            }


            if (vfx.gojoRedTrail.length && ball._gojoRedTrail && ball._gojoRedTrail.length > 1) {
                for (let i = 0; i < ball._gojoRedTrail.length - 1; i++) {
                    const p = ball._gojoRedTrail[i], n = ball._gojoRedTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 500, 0, 1) * 0.9;
                    const w = lerp(vfx.gojoRedTrail[0].w, 2, i / ball._gojoRedTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.gojoRedTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.gojoRedTrail[0].colorEnd, a * 0.6));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                }
            }


            if (vfx.gojoPurpleTrail.length && ball._gojoPurpleTrail && ball._gojoPurpleTrail.length > 1) {
                for (let i = 0; i < ball._gojoPurpleTrail.length - 1; i++) {
                    const p = ball._gojoPurpleTrail[i], n = ball._gojoPurpleTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 1000, 0, 1) * 0.9;
                    const w = lerp(vfx.gojoPurpleTrail[0].w, 2, i / ball._gojoPurpleTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.gojoPurpleTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.gojoPurpleTrail[0].colorEnd, a * 0.6));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                }
            }


            if (vfx.eddieVenomShotTrail.length && ball._eddieVenomShotTrail && ball._eddieVenomShotTrail.length > 1) {
                for (let i = 0; i < ball._eddieVenomShotTrail.length - 1; i++) {
                    const p = ball._eddieVenomShotTrail[i], n = ball._eddieVenomShotTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 600, 0, 1) * 0.9;
                    const w = lerp(vfx.eddieVenomShotTrail[0].w, 2, i / ball._eddieVenomShotTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.eddieVenomShotTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.eddieVenomShotTrail[0].colorEnd, a * 0.6));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                }
            }

            if (vfx.zeusLightningTrail.length && ball._zeusLightningTrail && ball._zeusLightningTrail.length > 1) {
                for (let i = 0; i < ball._zeusLightningTrail.length - 1; i++) {
                    const p = ball._zeusLightningTrail[i], n = ball._zeusLightningTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 400, 0, 1) * 0.9;
                    const w = lerp(vfx.zeusLightningTrail[0].w, 2, i / ball._zeusLightningTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.zeusLightningTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.zeusLightningTrail[0].colorEnd, a * 0.8));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                }
            }

            if (vfx.zeusOlympusFuryBallTrail.length && ball._zeusOlympusFuryBallTrail && ball._zeusOlympusFuryBallTrail.length > 1) {
                for (let i = 0; i < ball._zeusOlympusFuryBallTrail.length - 1; i++) {
                    const p = ball._zeusOlympusFuryBallTrail[i], n = ball._zeusOlympusFuryBallTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 800, 0, 1) * 0.9;
                    const w = lerp(vfx.zeusOlympusFuryBallTrail[0].w, 4, i / ball._zeusOlympusFuryBallTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.zeusOlympusFuryBallTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.zeusOlympusFuryBallTrail[0].colorEnd, a * 0.7));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                }
            }


            ctx.save();
            ctx.fillStyle='rgba(0,0,0,.25)';
            ctx.beginPath(); ctx.ellipse(ball.x+1.5, ball.y+ball.r*0.85, ball.r*0.9, ball.r*0.5, 0, 0, Math.PI*2); ctx.fill();


            let ballColor = '#f8fafc';
            if (currentStyle === 'gojo') {
                if (player.gojoRedActive) {
                    ballColor = getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-primary');
                } else if (vfx.gojoPurpleTrail.length > 0) {
                    ballColor = getComputedStyle(document.documentElement).getPropertyValue('--gojo-purple-primary');
                }
            } else if (currentStyle === 'eddie' && vfx.eddieVenomShotTrail.length > 0) {
                 ballColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-secondary');
            } else if (currentStyle === 'zeus') {
                if (player.zeusLightningActive || vfx.zeusOlympusFuryBallTrail.length > 0) {
                    ballColor = getComputedStyle(document.documentElement).getPropertyValue('--zeus-lightning-trail-end');
                } else {
                    ballColor = '#f8fafc';
                }
            }

            // Check for squid glaze effect
            const now = performance.now();
            if (ball.squidGlazed && now < ball.squidGlazeEndTime) {
                ballColor = '#ffffff'; // Pure white during squid glaze
            }

            ctx.fillStyle=ballColor;

            ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle='#0f172a'; ctx.lineWidth=1.5; ctx.stroke();
            ctx.beginPath();
            for(let i=0;i<5;i++){
                const a=(-Math.PI/2)+i*(2*Math.PI/5);
                const x=ball.x+Math.cos(a)*ball.r*0.55;
                const y=ball.y+Math.sin(a)*ball.r*0.55;
                if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.closePath(); ctx.stroke();
            ctx.restore();
        }

        function drawAI(){
            if (!aiEnabled) return;

            ctx.save();

            ctx.shadowColor = 'rgba(255, 100, 100, 0.6)';
            ctx.shadowBlur = aiPlayer.shootCharging ? 15 : 8;

            let aiFillColor = '#ef4444';
            if (aiPlayer.shootCharging) {
                aiFillColor = '#dc2626';
            }

            ctx.fillStyle = aiFillColor;
            ctx.strokeStyle = 'rgba(0,0,0,.45)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(aiPlayer.x, aiPlayer.y, aiPlayer.r, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
            ctx.shadowBlur = 0;

            if (aiPlayer.hasBall && aiPlayer.state === 'shoot') {
                const goalX = margin;
                const goalY = H/2;
                ctx.save();
                ctx.strokeStyle = 'rgba(255,100,100,.6)';
                ctx.setLineDash([8,6]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(aiPlayer.x, aiPlayer.y);
                ctx.lineTo(goalX, goalY);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        }

        function drawUI(){
            const now = performance.now();
            const rootStyle = getComputedStyle(document.documentElement);


            if(mouse.down && player.hasBall && chargeStart && !player.gojoRedCharging){
                const held=Math.min(now - chargeStart, AUTO_MS);
                const pct=held/AUTO_MS*100;
                powerFill.style.width=pct.toFixed(1)+'%';
            } else if (currentStyle === 'xdrake' && player.xdrakeAncientApexCharging) {
                const held = Math.min(now - player.ancientApexChargeTimer, XDRAKE_ANCIENT_APEX_CHARGE_DURATION);
                const pct = (held / XDRAKE_ANCIENT_APEX_CHARGE_DURATION) * 100;
                powerFill.style.width = pct.toFixed(1) + '%';
            } else if (currentStyle === 'gojo' && player.gojoRedCharging) {
                const held = Math.min(now - player.gojoRedChargeStartTime, GOJO_RED_CHARGE_DURATION);
                const pct = (held / GOJO_RED_CHARGE_DURATION) * 100;
                powerFill.style.width = pct.toFixed(1) + '%';
            } else if (currentStyle === 'eddie' && player.eddieSymbioteMontageActive && player.eddieSymbioteMontagePhase === 'aiming') {
                const held = Math.min(now - player.eddieSymbioteMontageAimStartTime, EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION);
                const pct = (held / EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION) * 100;
                powerFill.style.width = pct.toFixed(1) + '%';
            } else if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                const held = Math.min(now - player.zeusLightningChargeStartTime, ZEUS_LIGHTNING_CHARGE_DURATION);
                const pct = (held / ZEUS_LIGHTNING_CHARGE_DURATION) * 100;
                powerFill.style.width = pct.toFixed(1) + '%';
            } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming') {
                const held = Math.min(now - player.zeusOlympusFuryAimStartTime, ZEUS_OLYMPUS_FURY_AIM_DURATION);
                const pct = (held / ZEUS_OLYMPUS_FURY_AIM_DURATION) * 100;
                powerFill.style.width = pct.toFixed(1) + '%';
            }
            else {
                powerFill.style.width = '0%';
            }



            let cdLeftC = 0;
            slotC.classList.remove('ready');
            slotC.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'ignis', 'asher', 'leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');

            if (currentStyle === 'hudson') {
                cdLeftC = Math.max(0, abilityReadyAt - now);
                slotC.classList.add('hudson');
                abilityNameCEl.textContent = 'Hudson Impact';
            } else if (currentStyle === 'robsan') {
                cdLeftC = Math.max(0, shadowSpiralReadyAt - now);
                slotC.classList.add('robsan');
                abilityNameCEl.textContent = 'Shadow Spiral';
            } else if (currentStyle === 'xdrake') {
                cdLeftC = Math.max(0, supernovaReadyAt - now);
                slotC.classList.add('xdrake');
                abilityNameCEl.textContent = 'Supernova';
            } else if (currentStyle === 'gojo') {
                cdLeftC = Math.max(0, gojoRedReadyAt - now);
                slotC.classList.add('gojo');
                abilityNameCEl.textContent = 'Red';
            } else if (currentStyle === 'eddie') {
                cdLeftC = Math.max(0, eddieWeAreReadyAt - now);
                slotC.classList.add('eddie');
                abilityNameCEl.textContent = 'We Are';
            } else if (currentStyle === 'zeus') {
                cdLeftC = Math.max(0, zeusLightningReadyAt - now);
                slotC.classList.add('zeus');
                abilityNameCEl.textContent = 'Lightning Bolt';
            } else if (currentStyle === 'ignis') {
                cdLeftC = Math.max(0, ignisFireBreathReadyAt - now);
                slotC.classList.add('ignis');
                abilityNameCEl.textContent = 'Fire Breath';
            } else if (currentStyle === 'asher') {
                cdLeftC = Math.max(0, asherAutoGoalReadyAt - now);
                slotC.classList.add('asher');
                abilityNameCEl.textContent = 'Starfall Shot';
            } else if (currentStyle === 'leonardo') {
                cdLeftC = Math.max(0, leonardoFocusShotReadyAt - now);
                slotC.classList.add('leonardo');
                abilityNameCEl.textContent = 'Focus Shot';
            } else if (currentStyle === 'angus') {
                cdLeftC = 0;
                slotC.classList.add('angus');
                abilityNameCEl.textContent = `Power Burst (${player.angusBurstUsesLeft}/3)`;
            } else if (currentStyle === 'diddy') {
                cdLeftC = Math.max(0, diddyBabyOilReadyAt - now);
                slotC.classList.add('diddy');
                abilityNameCEl.textContent = 'Baby Oil Ascension';
            } else if (currentStyle === 'cristiano') {
                cdLeftC = Math.max(0, cristianoPowerShotReadyAt - now);
                slotC.classList.add('cristiano');
                abilityNameCEl.textContent = 'Power Shot';
            } else if (currentStyle === 'saja-jin') {
                cdLeftC = Math.max(0, sajaJinDemonicHeroismReadyAt - now);
                slotC.classList.add('saja-jin');
                abilityNameCEl.textContent = 'Demonic Heroism';
            } else if (currentStyle === 'abby') {
                cdLeftC = Math.max(0, abbyColossalCalvesReadyAt - now);
                slotC.classList.add('abby');
                abilityNameCEl.textContent = 'Colossal Calves';
            } else if (currentStyle === 'lincoln') {
                cdLeftC = Math.max(0, lincolnShrekMoveReadyAt - now);
                slotC.classList.add('lincoln');
                abilityNameCEl.textContent = 'Shrek Move';
            } else if (currentStyle === 'korbin') {
                cdLeftC = Math.max(0, korbinFieryApocalypseReadyAt - now);
                slotC.classList.add('korbin');
                abilityNameCEl.textContent = 'Fiery Apocalypse';
            } else if (currentStyle === '67kid') {
                cdLeftC = Math.max(0, sixtySevenKidMayhemReadyAt - now);
                slotC.classList.add('67kid');
                abilityNameCEl.textContent = '67 Mayhem';
            } else if (currentStyle === 'wally') {
                cdLeftC = Math.max(0, wallyRocketBoostReadyAt - now);
                slotC.classList.add('wally');
                abilityNameCEl.textContent = 'Rocket Boost';
            } else if (currentStyle === 'rabies') {
                cdLeftC = Math.max(0, rabiesRagebaitReadyAt - now);
                slotC.classList.add('rabies');
                abilityNameCEl.textContent = 'Ragebait';
            }
            const coolPctC = clamp(1 - cdLeftC / ABILITY_COOLDOWN, 0, 1) * 100;
            const coolElC = document.getElementById('coolC');
            const coolTxC = document.getElementById('coolCText');
            coolElC.style.width = `${coolPctC}%`;

            if(cdLeftC > 0){
                coolTxC.textContent = (cdLeftC/1000).toFixed(1)+'s';
                if(currentStyle === 'xdrake') slotC.classList.add('xdrake');
                if(currentStyle === 'gojo') slotC.classList.add('gojo-red-cool');
                if(currentStyle === 'eddie') slotC.classList.add('eddie');
                if(currentStyle === 'zeus') slotC.classList.add('zeus');
                if(currentStyle === 'asher') slotC.classList.add('asher');
                if(currentStyle === 'leonardo') slotC.classList.add('leonardo');
                if(currentStyle === 'angus') slotC.classList.add('angus');
                if(currentStyle === 'diddy') slotC.classList.add('diddy');
                if(currentStyle === 'cristiano') slotC.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotC.classList.add('saja-jin');
                if(currentStyle === 'abby') slotC.classList.add('abby');
                if(currentStyle === 'lincoln') slotC.classList.add('lincoln');
                if(currentStyle === 'korbin') slotC.classList.add('korbin');
                if(currentStyle === '67kid') slotC.classList.add('67kid');
                if(currentStyle === 'wally') slotC.classList.add('wally');
                if(currentStyle === 'rabies') slotC.classList.add('rabies');

            } else {
                slotC.classList.add('ready');
                coolTxC.textContent = '';
                if(currentStyle === 'xdrake') slotC.classList.add('xdrake');
                if(currentStyle === 'gojo') slotC.classList.add('gojo-red-ready');
                if(currentStyle === 'eddie') slotC.classList.add('eddie');
                if(currentStyle === 'zeus') slotC.classList.add('zeus');
                if(currentStyle === 'ignis') slotC.classList.add('ignis');
                if(currentStyle === 'asher') slotC.classList.add('asher');
                if(currentStyle === 'leonardo') slotC.classList.add('leonardo');
                if(currentStyle === 'angus') slotC.classList.add('angus');
                if(currentStyle === 'diddy') slotC.classList.add('diddy');
                if(currentStyle === 'cristiano') slotC.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotC.classList.add('saja-jin');
                if(currentStyle === 'abby') slotC.classList.add('abby');
                if(currentStyle === 'lincoln') slotC.classList.add('lincoln');
                if(currentStyle === 'korbin') slotC.classList.add('korbin');
                if(currentStyle === '67kid') slotC.classList.add('67kid');
                if(currentStyle === 'wally') slotC.classList.add('wally');
                if(currentStyle === 'rabies') slotC.classList.add('ragebait-ready');

            }
            if (currentStyle === 'none') { slotC.style.display = 'none'; } else { slotC.style.display = 'flex'; }



            let cdLeftV = 0;
            slotV.classList.remove('ready');
            slotV.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'ignis', 'asher', 'leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');

            if (currentStyle === 'robsan') {
                cdLeftV = Math.max(0, eclipseGraspReadyAt - now);
                slotV.classList.add('robsan');
                abilityNameVEl.textContent = 'Eclipse Grasp';
            } else if (currentStyle === 'xdrake') {
                cdLeftV = Math.max(0, fossilFootworkReadyAt - now);
                slotV.classList.add('xdrake');
                abilityNameVEl.textContent = 'Fossilised Footwork';
            } else if (currentStyle === 'gojo') {
                cdLeftV = Math.max(0, gojoLapseBlueReadyAt - now);
                slotV.classList.add('gojo');
                abilityNameVEl.textContent = 'Lapse Blue';
            } else if (currentStyle === 'eddie') {
                cdLeftV = Math.max(0, eddieVenomStrikeReadyAt - now);
                slotV.classList.add('eddie');
                abilityNameVEl.textContent = 'Venom Strike';
            } else if (currentStyle === 'zeus') {
                cdLeftV = Math.max(0, zeusHeavenlyShieldReadyAt - now);
                slotV.classList.add('zeus');
                abilityNameVEl.textContent = 'Heavenly Shield';
            } else if (currentStyle === 'ignis') {
                cdLeftV = Math.max(0, ignisBlazeDashReadyAt - now);
                slotV.classList.add('ignis');
                abilityNameVEl.textContent = 'Blaze Dash';
            } else if (currentStyle === 'asher') {
                cdLeftV = Math.max(0, asherBallTeleportReadyAt - now);
                slotV.classList.add('asher');
                abilityNameVEl.textContent = 'Celestial Pull';
            } else if (currentStyle === 'leonardo') {
                cdLeftV = Math.max(0, leonardoShieldReadyAt - now);
                slotV.classList.add('leonardo');
                abilityNameVEl.textContent = 'Sensory Shield';
            } else if (currentStyle === 'angus') {
                cdLeftV = Math.max(0, angusTimeStopReadyAt - now);
                slotV.classList.add('angus');
                abilityNameVEl.textContent = 'Time Stop';
            } else if (currentStyle === 'diddy') {
                cdLeftV = Math.max(0, diddySlickShotReadyAt - now);
                slotV.classList.add('diddy');
                abilityNameVEl.textContent = 'Slick Shot';
            } else if (currentStyle === 'cristiano') {
                cdLeftV = Math.max(0, cristianoGoatTackleReadyAt - now);
                slotV.classList.add('cristiano');
                abilityNameVEl.textContent = "GOAT's Tackle";
            } else if (currentStyle === 'saja-jin') {
                cdLeftV = Math.max(0, sajaJinSoulSuckingShotReadyAt - now);
                slotV.classList.add('saja-jin');
                abilityNameVEl.textContent = 'Soul-Sucking Shot';
            } else if (currentStyle === 'hudson') {
                cdLeftV = Math.max(0, hudsonEmperorDribbleReadyAt - now);
                slotV.classList.add('hudson');
                abilityNameVEl.textContent = 'dribble like an emperor';
            } else if (currentStyle === 'abby') {
                cdLeftV = Math.max(0, abbyPowerPinReadyAt - now);
                slotV.classList.add('abby');
                abilityNameVEl.textContent = 'Power Pin';
            } else if (currentStyle === 'lincoln') {
                cdLeftV = Math.max(0, lincolnKissMoveReadyAt - now);
                slotV.classList.add('lincoln');
                abilityNameVEl.textContent = 'Kiss Move';
            } else if (currentStyle === 'korbin') {
                cdLeftV = Math.max(0, korbinBigBackPowerReadyAt - now);
                slotV.classList.add('korbin');
                abilityNameVEl.textContent = 'Big Back Power';
            } else if (currentStyle === 'wally') {
                cdLeftV = Math.max(0, wallySpeedForceReadyAt - now);
                slotV.classList.add('wally');
                abilityNameVEl.textContent = 'Speed Force';
            } else if (currentStyle === 'rabies') {
                cdLeftV = Math.max(0, rabiesStealBallrotReadyAt - now);
                slotV.classList.add('rabies');
                abilityNameVEl.textContent = 'Steal a Ballrot';
            }
            let cooldownDuration = ABILITY_COOLDOWN;
            if (currentStyle === 'hudson') cooldownDuration = HUDSON_EMPEROR_DRIBBLE_COOLDOWN;
            if (currentStyle === 'korbin') cooldownDuration = KORBIN_BIG_BACK_POWER_COOLDOWN;
            const coolPctV = clamp(1 - cdLeftV / cooldownDuration, 0, 1) * 100;
            const coolElV = document.getElementById('coolV');
            const coolTxV = document.getElementById('coolVText');
            coolElV.style.width = `${coolPctV}%`;

            if(cdLeftV > 0){
                coolTxV.textContent = (cdLeftV/1000).toFixed(1)+'s';
                if(currentStyle === 'robsan') slotV.classList.add('eclipse-cool');
                if(currentStyle === 'xdrake') slotV.classList.add('footwork-cool');
                if(currentStyle === 'gojo') slotV.classList.add('gojo-blue-cool');
                if(currentStyle === 'eddie') slotV.classList.add('eddie');
                if(currentStyle === 'zeus') slotV.classList.add('zeus');
                if(currentStyle === 'ignis') slotV.classList.add('ignis');
                if(currentStyle === 'asher') slotV.classList.add('asher');
                if(currentStyle === 'leonardo') slotV.classList.add('leonardo');
                if(currentStyle === 'angus') slotV.classList.add('angus');
                if(currentStyle === 'diddy') slotV.classList.add('diddy');
                if(currentStyle === 'cristiano') slotV.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotV.classList.add('saja-jin');
                if(currentStyle === 'hudson') slotV.classList.add('hudson');
                if(currentStyle === 'abby') slotV.classList.add('abby');
                if(currentStyle === 'lincoln') slotV.classList.add('lincoln');
                if(currentStyle === 'korbin') slotV.classList.add('korbin');
                if(currentStyle === 'wally') slotV.classList.add('wally');
                if(currentStyle === 'rabies') slotV.classList.add('rabies');
            } else {
                slotV.classList.add('ready');
                coolTxV.textContent = '';
                if(currentStyle === 'robsan') slotV.classList.add('eclipse-ready');
                if(currentStyle === 'xdrake') slotV.classList.add('footwork-ready');
                if(currentStyle === 'gojo') slotV.classList.add('gojo-blue-ready');
                if(currentStyle === 'eddie') slotV.classList.add('eddie');
                if(currentStyle === 'zeus') slotV.classList.add('zeus');
                if(currentStyle === 'ignis') slotV.classList.add('ignis');
                if(currentStyle === 'asher') slotV.classList.add('asher');
                if(currentStyle === 'leonardo') slotV.classList.add('leonardo');
                if(currentStyle === 'angus') slotV.classList.add('angus');
                if(currentStyle === 'diddy') slotV.classList.add('diddy');
                if(currentStyle === 'cristiano') slotV.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotV.classList.add('saja-jin');
                if(currentStyle === 'hudson') slotV.classList.add('hudson');
                if(currentStyle === 'abby') slotV.classList.add('abby');
                if(currentStyle === 'lincoln') slotV.classList.add('lincoln');
                if(currentStyle === 'wally') slotV.classList.add('wally');
                if(currentStyle === 'rabies') slotV.classList.add('steal-ballrot-ready');
            }
            if (currentStyle === 'none') { slotV.style.display = 'none'; } else { slotV.style.display = 'flex'; }



            let cdLeftX = 0;
            slotX.classList.remove('ready');
            slotX.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher', 'leonardo', 'angus', 'diddy', 'cristiano', 'saja-jin', 'lincoln', 'abby', 'korbin', 'wally', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');

            if (currentStyle === 'robsan') {
                cdLeftX = Math.max(0, voidDashReadyAt - now);
                slotX.classList.add('robsan');
                abilityNameXEl.textContent = 'Void Dash';
            } else if (currentStyle === 'xdrake') {
                cdLeftX = Math.max(0, ancientApexReadyAt - now);
                slotX.classList.add('xdrake');
                abilityNameXEl.textContent = 'Ancient Apex';
            } else if (currentStyle === 'gojo') {
                cdLeftX = Math.max(0, gojoPurpleReadyAt - now);
                slotX.classList.add('gojo');
                abilityNameXEl.textContent = 'Purple';
            } else if (currentStyle === 'eddie') {
                cdLeftX = Math.max(0, eddieSymbioteMontageReadyAt - now);
                slotX.classList.add('eddie');
                abilityNameXEl.textContent = 'Symbiote Montage';
            } else if (currentStyle === 'zeus') {
                cdLeftX = Math.max(0, zeusOlympusFuryReadyAt - now);
                slotX.classList.add('zeus');
                abilityNameXEl.textContent = 'Olympus\' Fury';
            } else if (currentStyle === 'ignis') {
                cdLeftX = Math.max(0, ignisPhoenixBurstReadyAt - now);
                slotX.classList.add('ignis');
                abilityNameXEl.textContent = 'Phoenix Burst';
            } else if (currentStyle === 'leonardo') {
                cdLeftX = Math.max(0, leonardoDashReadyAt - now);
                slotX.classList.add('leonardo');
                abilityNameXEl.textContent = 'Pattern Weave';
            } else if (currentStyle === 'angus') {
                cdLeftX = Math.max(0, angusTeleportReadyAt - now);
                slotX.classList.add('angus');
                abilityNameXEl.textContent = 'Shadow Teleport';
            } else if (currentStyle === 'diddy') {
                cdLeftX = Math.max(0, diddyOilSlickReadyAt - now);
                slotX.classList.add('diddy');
                abilityNameXEl.textContent = 'Baby Oil Blindness';
            } else if (currentStyle === 'cristiano') {
                cdLeftX = Math.max(0, cristianoPortugueseSpiritReadyAt - now);
                slotX.classList.add('cristiano');
                abilityNameXEl.textContent = 'Portuguese Spirit';
            } else if (currentStyle === 'saja-jin') {
                cdLeftX = Math.max(0, sajaJinHypnoticShotReadyAt - now);
                slotX.classList.add('saja-jin');
                abilityNameXEl.textContent = 'Hypnotic Shot';
            } else if (currentStyle === 'abby') {
                cdLeftX = Math.max(0, abbyDemonDriveReadyAt - now);
                slotX.classList.add('abby');
                abilityNameXEl.textContent = 'Demon Drive';
            } else if (currentStyle === 'korbin') {
                cdLeftX = Math.max(0, korbinBigShotReadyAt - now);
                slotX.classList.add('korbin');
                abilityNameXEl.textContent = 'Big Shot';
            } else if (currentStyle === 'lincoln') {
                cdLeftX = Math.max(0, lincolnGyattShowdownReadyAt - now);
                slotX.classList.add('lincoln');
                abilityNameXEl.textContent = 'Gyatt Showdown';
            } else if (currentStyle === 'wally') {
                cdLeftX = Math.max(0, wallyFlashyLightningReadyAt - now);
                slotX.classList.add('wally');
                abilityNameXEl.textContent = 'Flashy Lightning';
            } else if (currentStyle === 'rabies') {
                cdLeftX = Math.max(0, rabiesSquidGlazeReadyAt - now);
                slotX.classList.add('rabies');
                abilityNameXEl.textContent = 'Squid Glaze';
            }
            const coolPctX = clamp(1 - cdLeftX / (currentStyle === 'gojo' || currentStyle === 'eddie' || currentStyle === 'zeus' || currentStyle === 'ignis' ? ABILITY_COOLDOWN * 2 : 
                currentStyle === 'korbin' ? KORBIN_BIG_SHOT_COOLDOWN : ABILITY_COOLDOWN), 0, 1) * 100;
            const coolElX = document.getElementById('coolX');
            const coolTxX = document.getElementById('coolXText');
            coolElX.style.width = `${coolPctX}%`;

            if(cdLeftX > 0){
                coolTxX.textContent = (cdLeftX/1000).toFixed(1)+'s';
                if(currentStyle === 'robsan') slotX.classList.add('void-cool');
                if(currentStyle === 'xdrake') slotX.classList.add('apex-cool');
                if(currentStyle === 'gojo') slotX.classList.add('gojo-purple-cool');
                if(currentStyle === 'eddie') slotX.classList.add('eddie');
                if(currentStyle === 'zeus') slotX.classList.add('zeus');
                if(currentStyle === 'ignis') slotX.classList.add('ignis');
                if(currentStyle === 'leonardo') slotX.classList.add('leonardo');
                if(currentStyle === 'angus') slotX.classList.add('angus');
                if(currentStyle === 'diddy') slotX.classList.add('diddy');
                if(currentStyle === 'cristiano') slotX.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotX.classList.add('saja-jin');
                if(currentStyle === 'abby') slotX.classList.add('abby');
                if(currentStyle === 'korbin') slotX.classList.add('korbin');
                if(currentStyle === 'lincoln') slotX.classList.add('lincoln');
                if(currentStyle === 'wally') slotX.classList.add('wally');
                if(currentStyle === 'rabies') slotX.classList.add('rabies');
            } else {
                slotX.classList.add('ready');
                coolTxX.textContent = '';
                if(currentStyle === 'robsan') slotX.classList.add('void-ready');
                if(currentStyle === 'xdrake') slotX.classList.add('apex-ready');
                if(currentStyle === 'gojo') slotX.classList.add('gojo-purple-ready');
                if(currentStyle === 'eddie') slotX.classList.add('eddie');
                if(currentStyle === 'zeus') slotX.classList.add('zeus');
                if(currentStyle === 'ignis') slotX.classList.add('ignis');
                if(currentStyle === 'leonardo') slotX.classList.add('leonardo');
                if(currentStyle === 'angus') slotX.classList.add('angus');
                if(currentStyle === 'diddy') slotX.classList.add('diddy');
                if(currentStyle === 'cristiano') slotX.classList.add('cristiano');
                if(currentStyle === 'saja-jin') slotX.classList.add('saja-jin');
                if(currentStyle === 'abby') slotX.classList.add('abby');
                if(currentStyle === 'korbin') slotX.classList.add('korbin');
                if(currentStyle === 'lincoln') slotX.classList.add('lincoln');
                if(currentStyle === 'wally') slotX.classList.add('wally');
                if(currentStyle === 'rabies') slotX.classList.add('squid-glaze-ready');
            }
            if (currentStyle === 'none' || currentStyle === 'hudson' || currentStyle === 'asher') { slotX.style.display = 'none'; } else { slotX.style.display = 'flex'; }

            // B Slot Logic (Rabies only)
            let cdLeftB = 0;
            slotB.classList.remove('ready');
            slotB.classList.remove('rabies', 'pookie-power-ready');

            if (currentStyle === 'rabies') {
                cdLeftB = Math.max(0, rabiesPookiePowerReadyAt - now);
                slotB.classList.add('rabies');
                abilityNameBEl.textContent = 'Pookie Power';
            }
            const coolPctB = clamp(1 - cdLeftB / ABILITY_COOLDOWN, 0, 1) * 100;
            const coolElB = document.getElementById('coolB');
            const coolTxB = document.getElementById('coolBText');
            coolElB.style.width = `${coolPctB}%`;

            if(cdLeftB > 0){
                coolTxB.textContent = (cdLeftB/1000).toFixed(1)+'s';
                if(currentStyle === 'rabies') slotB.classList.add('rabies');
            } else {
                slotB.classList.add('ready');
                coolTxB.textContent = '';
                if(currentStyle === 'rabies') slotB.classList.add('pookie-power-ready');
            }
            if (currentStyle === 'rabies') { slotB.style.display = 'flex'; } else { slotB.style.display = 'none'; }
        }

        function checkGoal(){
            if(ball.x - ball.r <= margin + goalDepth && ball.y > H/2 - goalW/2 && ball.y < H/2 + goalW/2){
                scoreR++;
                if (currentStyle === 'wally' && !player.awakeningActive && player.awakeningProgress < AWAKENING_GOALS_REQUIRED) {
                    player.awakeningProgress++;
                    updateAwakeningBar();
                }
                if (currentStyle === 'eddie' && player.eddieAwakeningProgress < 100) {
                    player.eddieAwakeningProgress = Math.min(100, player.eddieAwakeningProgress + 10);
                }
                updatePlayerLevel();
                resetRound();
            }
            if(ball.x + ball.r >= W - margin - goalDepth && ball.y > H/2 - goalW/2 && ball.y < H/2 + goalW/2){
                scoreL++;
                updatePlayerLevel();
                if (currentStyle === 'wally' && !player.awakeningActive && player.awakeningProgress < AWAKENING_GOALS_REQUIRED) {
                    player.awakeningProgress++;
                    updateAwakeningBar();
                }
                if (currentStyle === 'eddie' && player.eddieAwakeningProgress < 100) {
                    player.eddieAwakeningProgress = Math.min(100, player.eddieAwakeningProgress + 10);
                }
                resetRound();
            }
        }

        function updateAwakeningBar() {
            const awakeningLabel = document.getElementById('awakening-label');
            
            if (player.awakeningActive) {
                const now = performance.now();
                const timeLeft = Math.max(0, player.awakeningEndTime - now);
                const timeLeftPercentage = (timeLeft / AWAKENING_DURATION) * 100;
                const timeLeftSeconds = Math.ceil(timeLeft / 1000);
                
                awakeningFill.style.width = `${timeLeftPercentage}%`;
                awakeningLabel.textContent = `G - Awakening: ${timeLeftSeconds}s remaining`;
                
                awakeningFill.style.background = 'linear-gradient(90deg, #ff6b6b, #ffd93d)';
                awakeningBar.classList.remove('full');
            } else {
                const progressPercentage = (player.awakeningProgress / AWAKENING_GOALS_REQUIRED) * 100;
                awakeningFill.style.width = `${progressPercentage}%`;
                awakeningLabel.textContent = `G - Awakening: ${Math.round(progressPercentage)}%`;
                
                awakeningFill.style.background = 'linear-gradient(90deg, #00ffff, #0080ff)';
                
                if (player.awakeningProgress >= AWAKENING_GOALS_REQUIRED) {
                    awakeningBar.classList.add('full');
                    awakeningLabel.textContent = 'G - Awakening: READY!';
                } else {
                    awakeningBar.classList.remove('full');
                }
            }
            
            if (currentStyle === 'eddie' && player.eddieAwakeningProgress >= 100) {
            }
        }

        function triggerEddieAwakening() {
            player.eddieAwakeningActive = true;
            player.eddieAwakeningEndTime = performance.now() + 100000;
            player.eddieAwakeningVideoPlaying = true;

            const video = document.createElement('video');
            video.src = 'venomawk.mp4';
            video.style.position = 'fixed';
            video.style.top = '50%';
            video.style.left = '50%';
            video.style.transform = 'translate(-50%, -50%)';
            video.style.zIndex = '9999';
            video.style.width = '100%';
            video.style.height = '100%';
            video.style.objectFit = 'contain';
            video.autoplay = true;
            video.muted = false;

            document.body.appendChild(video);

            setTimeout(() => {
                video.remove();
                player.eddieAwakeningVideoPlaying = false;
            }, 5000);

            updateEddieAwakeningMoves();

            player.eddieAwakeningProgress = 100;
            updateAwakeningBar();
        }

        function updateEddieAwakeningMoves() {
            if (currentStyle === 'eddie') {
                if (player.eddieAwakeningActive) {
                    abilityNameCEl.textContent = 'Venom Devastation';
                    abilityNameVEl.textContent = 'Shadow Realm';
                    abilityNameXEl.textContent = 'Symbiote Montage';
                } else {
                    abilityNameCEl.textContent = 'We Are';
                    abilityNameVEl.textContent = 'Venom Strike';
                    abilityNameXEl.textContent = 'Symbiote Montage';
                }
            }
        }

        function updateEddieAwakeningTimer() {
            if (currentStyle === 'eddie' && player.eddieAwakeningActive) {
                const now = performance.now();
                const timeLeft = player.eddieAwakeningEndTime - now;

                if (timeLeft <= 0) {
                    player.eddieAwakeningActive = false;
                    player.eddieAwakeningProgress = 0;
                    updateAwakeningBar();
                    updateEddieAwakeningMoves();
                } else {
                    const progressPercent = (timeLeft / 100000) * 100;
                    player.eddieAwakeningProgress = Math.max(0, progressPercent);
                    updateAwakeningBar();
                }
            }
        }

        
        function triggerAwakening() {
            player.awakeningActive = true;
            player.awakeningEndTime = performance.now() + AWAKENING_DURATION;
            player.awakeningEyesActive = true;
            player.awakeningAuraActive = true;
            player.autoEyesClosedTriggered = false;

            showAwakeningSubtitle("My... Ordinary... Life..", () => {
                showNotification('Awakening activated! New abilities unlocked!', 'success');
            });

            addAwakeningEffects();

            updateAwakeningMoves();

            updateAwakeningBar();
        }

        function showAwakeningSubtitle(text, callback) {
            const subtitleEl = document.createElement('div');
            subtitleEl.style.position = 'fixed';
            subtitleEl.style.top = '20%'; 
            subtitleEl.style.left = '50%';
            subtitleEl.style.transform = 'translate(-50%, -50%)';
            subtitleEl.style.background = 'rgba(0, 0, 0, 0.9)';
            subtitleEl.style.color = '#00ffff';
            subtitleEl.style.padding = '15px 30px'; 
            subtitleEl.style.borderRadius = '12px';
            subtitleEl.style.fontSize = '2rem'; 
            subtitleEl.style.fontFamily = 'Nunito, sans-serif';
            subtitleEl.style.fontWeight = '900';
            subtitleEl.style.textAlign = 'center';
            subtitleEl.style.zIndex = '10000';
            subtitleEl.style.border = '2px solid #00ffff';
            subtitleEl.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.4)';
            subtitleEl.style.textShadow = '0 0 8px rgba(0, 255, 255, 0.6)';
            document.body.appendChild(subtitleEl);

            let charIndex = 0;
            const typeInterval = setInterval(() => {
                subtitleEl.textContent = text.substring(0, charIndex);
                charIndex++;
                
                if (charIndex > text.length) {
                    clearInterval(typeInterval);
                    setTimeout(() => {
                        subtitleEl.remove();
                        if (callback) callback();
                    }, 2000);
                }
            }, 100);
        }

        function addAwakeningEffects() {
            player.awakeningEyesActive = true;
            
            player.awakeningAuraActive = true;
            
            
            for (let i = 0; i < 30; i++) { 
                vfx.sparks.push({
                    x: player.x + (Math.random() - 0.5) * 80,
                    y: player.y + (Math.random() - 0.5) * 80,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    life: 1500 + Math.random() * 800,
                    t: 0,
                    r: 1.5 + Math.random() * 2,
                    color: 'rgba(0, 255, 255,'
                });
            }
        }

        function updateAwakeningMoves() {
            if (player.awakeningActive) {
                document.querySelector('.movesbar').style.filter = 'grayscale(1) brightness(0.5)';
                
                document.getElementById('awakened-movesbar').style.display = 'flex';
            } else {
                document.querySelector('.movesbar').style.filter = 'none';
                
                document.getElementById('awakened-movesbar').style.display = 'none';
            }
        }

        function updateAwakeningTimer() {
            if (currentStyle === 'wally' && player.awakeningActive) {
                const now = performance.now();
                const timeLeft = player.awakeningEndTime - now;

                if (player.lastFearActive && now >= player.lastFearEndTime) {
                    player.lastFearActive = false;
                    showNotification('Last Fear shield ended!', 'info');
                }

                updateAwakeningBar();

                if (timeLeft <= 5000 && timeLeft > 4000 && !player.autoEyesClosedTriggered) {
                    player.autoEyesClosedTriggered = true;
                    
                    const quickBlackScreen = document.createElement('div');
                    quickBlackScreen.style.position = 'fixed';
                    quickBlackScreen.style.top = '0';
                    quickBlackScreen.style.left = '0';
                    quickBlackScreen.style.width = '100vw';
                    quickBlackScreen.style.height = '100vh';
                    quickBlackScreen.style.backgroundColor = 'black';
                    quickBlackScreen.style.zIndex = '10000';
                    quickBlackScreen.style.opacity = '0';
                    quickBlackScreen.style.transition = 'opacity 0.05s ease-in';
                    document.body.appendChild(quickBlackScreen);

                    setTimeout(() => {
                        quickBlackScreen.style.opacity = '1';
                    }, 10);

                    setTimeout(() => {
                        player.x = W - margin - goalDepth - 25;
                        player.y = H/2;
                        
                        ball.x = W - margin - goalDepth + 3;
                        ball.y = H/2;
                        ball.vx = 0;
                        ball.vy = 0;
                        
                        for (let i = 0; i < 8; i++) {
                            vfx.sparks.push({
                                x: player.x + (Math.random() - 0.5) * 40,
                                y: player.y + (Math.random() - 0.5) * 40,
                                vx: (Math.random() - 0.5) * 3,
                                vy: (Math.random() - 0.5) * 3,
                                life: 500,
                                t: 0,
                                r: 1 + Math.random(),
                                color: 'rgba(0, 255, 255,'
                            });
                        }
                        
                        setTimeout(() => checkGoal(), 50);
                        
                        quickBlackScreen.style.opacity = '0';
                        setTimeout(() => quickBlackScreen.remove(), 100);
                        
                        showNotification('Final teleport before awakening ends!', 'warning');
                    }, 300);
                }

                if (timeLeft <= 0) {
                    endAwakening();
                }
            }
        }

        function endAwakening() {
            player.awakeningActive = false;
            player.awakeningEyesActive = false;
            player.awakeningAuraActive = false;
            player.lastFearActive = false;
            player.partOfMyDesireActive = false;
            
            if (player.partOfMyDesireOriginalMaxSpd) {
                player.maxSpd = player.partOfMyDesireOriginalMaxSpd;
            }
            if (player.partOfMyDesireOriginalShotPower) {
                player.shotPower = player.partOfMyDesireOriginalShotPower;
            }
            
            player.awakeningProgress = 0;
            
            canvas.style.filter = 'none';
            
            updateAwakeningMoves();
            updateAwakeningBar();
            
            showNotification('Awakening ended! Need 10 more goals to awaken again.', 'info');
        }


        function tryLastFear() {
            if (!player.awakeningActive) return;
            
            const now = performance.now();
            if (player.lastFearActive) {
                showNotification('Last Fear already active!', 'warning');
                return;
            }

            player.lastFearActive = true;
            player.lastFearEndTime = now + LAST_FEAR_DURATION;

            for (let i = 0; i < 3; i++) {
                vfx.sparks.push({
                    x: player.x,
                    y: player.y,
                    vx: 0,
                    vy: 0,
                    life: LAST_FEAR_DURATION,
                    t: 0,
                    r: player.r * (3 + i * 0.5),
                    color: `rgba(0, 255, 255, ${0.4 - i * 0.1})`,
                    isShield: true,
                    shieldLayer: i,
                    attachedToPlayer: true
                });
            }

            for (let i = 0; i < 15; i++) {
                const angle = (i / 15) * Math.PI * 2;
                const dist = player.r * 3.5;
                vfx.sparks.push({
                    x: player.x + Math.cos(angle) * dist,
                    y: player.y + Math.sin(angle) * dist,
                    vx: Math.cos(angle) * 0.5,
                    vy: Math.sin(angle) * 0.5,
                    life: LAST_FEAR_DURATION,
                    t: 0,
                    r: 2 + Math.random() * 2,
                    color: 'rgba(0, 255, 255,',
                    isShieldSparkle: true,
                    attachedToPlayer: true,
                    orbitalAngle: angle,
                    orbitalDistance: dist
                });
            }

            showNotification('Last Fear activated! Shield up!', 'success');
        }

        function tryEyesClosed() {
            if (!player.awakeningActive) return;

            const blackScreen = document.createElement('div');
            blackScreen.style.position = 'fixed';
            blackScreen.style.top = '0';
            blackScreen.style.left = '0';
            blackScreen.style.width = '100vw';
            blackScreen.style.height = '100vh';
            blackScreen.style.backgroundColor = 'black';
            blackScreen.style.zIndex = '10000';
            blackScreen.style.opacity = '0';
            blackScreen.style.transition = 'opacity 0.1s ease-in';
            document.body.appendChild(blackScreen);

            setTimeout(() => {
                blackScreen.style.opacity = '1';
            }, 10);

            setTimeout(() => {
                player.x = W - margin - goalDepth - 30;
                player.y = H/2;
                
                ball.x = W - margin - goalDepth + 5;
                ball.y = H/2;
                ball.vx = 0;
                ball.vy = 0;
                
                for (let i = 0; i < 15; i++) {
                    vfx.sparks.push({
                        x: player.x + (Math.random() - 0.5) * 60,
                        y: player.y + (Math.random() - 0.5) * 60,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 800,
                        t: 0,
                        r: 1.5 + Math.random() * 2,
                        color: 'rgba(0, 255, 255,'
                    });
                }
                
                setTimeout(() => {
                    checkGoal();
                }, 50);
                
                blackScreen.style.opacity = '0';
                setTimeout(() => {
                    blackScreen.remove();
                }, 100);
                
                showNotification('Teleported to enemy goal!', 'success');
            }, 500);

            showNotification('Eyes Closed activated!', 'success');
        }

        function tryPartOfMyDesire() {
            if (!player.awakeningActive) return;
            
            const now = performance.now();
            if (player.partOfMyDesireActive) {
                showNotification('Part of my Desire already active!', 'warning');
                return;
            }

            player.partOfMyDesireActive = true;
            player.partOfMyDesireEndTime = now + PART_OF_MY_DESIRE_DURATION;
            player.partOfMyDesireOriginalMaxSpd = player.maxSpd;
            player.partOfMyDesireOriginalShotPower = player.shotPower || 1.0;
            
            player.maxSpd *= PART_OF_MY_DESIRE_SPEED_BOOST;
            player.shotPower = (player.shotPower || 1.0) * PART_OF_MY_DESIRE_STRENGTH_BOOST;

            for (let i = 0; i < 40; i++) {
                vfx.sparks.push({
                    x: player.x + (Math.random() - 0.5) * 100,
                    y: player.y + (Math.random() - 0.5) * 100,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: PART_OF_MY_DESIRE_DURATION,
                    t: 0,
                    r: 1 + Math.random() * 2,
                    color: 'rgba(255, 215, 0,',
                    isSpeedBoost: true,
                    attachedToPlayer: true
                });
            }

            vfx.sparks.push({
                x: player.x,
                y: player.y,
                vx: 0,
                vy: 0,
                life: PART_OF_MY_DESIRE_DURATION,
                t: 0,
                r: player.r * 2,
                color: 'rgba(255, 215, 0, 0.3)',
                isSpeedAura: true,
                attachedToPlayer: true
            });

            showNotification('Part of my Desire activated! 30% speed & strength boost!', 'success');
        }

        function updatePlayerLevel() {
            playerGoals++;
            localStorage.setItem('playerGoals', playerGoals);
           
            const progressPercent = (playerGoals / goalsForNextLevel) * 100;
            document.getElementById('level-progress').style.width = `${progressPercent}%`;
            document.getElementById('goals-progress').textContent = playerGoals;
            document.getElementById('goals-needed').textContent = goalsForNextLevel;
           
            if (playerGoals >= goalsForNextLevel) {
                playerLevel++;
                playerGoals = 0;
                localStorage.setItem('playerLevel', playerLevel);
                localStorage.setItem('playerGoals', playerGoals);
                goalsForNextLevel = playerLevel * 2;
               
                document.getElementById('level-number').textContent = playerLevel;
                document.getElementById('goals-progress').textContent = playerGoals;
                document.getElementById('goals-needed').textContent = goalsForNextLevel;
                document.getElementById('level-progress').style.width = '0%';
               
                const levelUpMsg = document.createElement('div');
                levelUpMsg.className = 'level-up';
                levelUpMsg.textContent = 'LEVEL UP!';
                document.getElementById('game-screen').appendChild(levelUpMsg);
                setTimeout(() => levelUpMsg.remove(), 2000);
               
                updateLincolnButtonAvailability();
                updateWallyButtonAvailability();
            }
        }

        function initializeLevelSystem() {
            document.getElementById('level-number').textContent = playerLevel;
            document.getElementById('goals-progress').textContent = playerGoals;
            document.getElementById('goals-needed').textContent = goalsForNextLevel;
            const progressPercent = (playerGoals / goalsForNextLevel) * 100;
            document.getElementById('level-progress').style.width = `${progressPercent}%`;
            updateLincolnButtonAvailability();
            updateWallyButtonAvailability();
        }

        function updateLevelDisplay() {
            localStorage.setItem('playerLevel', playerLevel);
            document.getElementById('level-number').textContent = playerLevel;
            goalsForNextLevel = playerLevel * 2;
            document.getElementById('goals-needed').textContent = goalsForNextLevel;
            const progressPercent = (playerGoals / goalsForNextLevel) * 100;
            document.getElementById('level-progress').style.width = `${progressPercent}%`;
            updateLincolnButtonAvailability();
            updateWallyButtonAvailability();
        }

        function updateLincolnButtonAvailability() {
            if (playerLevel >= 15) {
                styleLincolnBtn.style.opacity = '1';
                styleLincolnBtn.style.cursor = 'pointer';
                styleLincolnBtn.title = 'Lincoln - Requires the ball for Shrek Move';
                styleLincolnBtn.textContent = 'lincoln';
            } else {
                styleLincolnBtn.style.opacity = '0.5';
                styleLincolnBtn.style.cursor = 'not-allowed';
                styleLincolnBtn.title = 'Requires Level 15';
                styleLincolnBtn.textContent = `lincoln (lvl 15)`;
            }
        }

        function updateWallyButtonAvailability() {
            if (playerLevel >= 50) {
                styleWallyBtn.style.opacity = '1';
                styleWallyBtn.style.cursor = 'pointer';
                styleWallyBtn.title = 'Wally West - The Flash';
                styleWallyBtn.textContent = 'wally';
            } else {
                styleWallyBtn.style.opacity = '0.5';
                styleWallyBtn.style.cursor = 'not-allowed';
                styleWallyBtn.title = 'Requires Level 50';
                styleWallyBtn.textContent = `wally (lvl 50)`;
            }
        }

        function resetRound(){
            player.x=W*0.25; player.y=H*0.5; player.vx=0; player.vy=0; player.hasBall=false;
            ball.x=W*0.5; ball.y=H*0.5; ball.vx=0; ball.vy=0;

            if (currentStyle === 'eddie') {
                player.eddieAwakeningActive = false;
                updateAwakeningBar();
                updateEddieAwakeningMoves();
            }

            if (currentStyle === 'saja-jin') {
                player.sajaJinDemonicHeroismActive = false;
                player.sajaJinHypnoticShotActive = false;
                if (player.sajaJinDemonicHeroismOriginalMaxSpd) {
                    player.maxSpd = player.sajaJinDemonicHeroismOriginalMaxSpd;
                }
            }
            ball.isHoming = false;

            if (aiEnabled) {
                aiPlayer.x = W*0.75;
                aiPlayer.y = H*0.5;
                aiPlayer.vx = 0;
                aiPlayer.vy = 0;
                aiPlayer.hasBall = false;
                aiPlayer.state = 'chase';
                aiPlayer.shootCharging = false;
            }



            player.spinning = false;
            player.charging = false;
            player.telekinising = false;
            player.dashing = false;
            player.xdrakeSupernovaDashing = false;
            player.xdrakeFossilFootworking = false;
            player.xdrakeAncientApexCharging = false;
            player.gojoRedCharging = false;
            player.gojoRedActive = false;
            player.gojoLapseBlueActive = false;
            player.gojoLapseBlueBall = null;
            player.gojoPurpleActive = false;
            player.gojoPurpleConverging = false;
            player.gojoPurpleConvergenceStartTime = 0;
            player.gojoPurpleLeftBall = null;
            player.gojoPurpleRightBall = null;
            player.gojoPurpleInitialDir = 0;
            player.gojoPurpleShotFired = false;
            gojoPurpleShockwaveEndTime = 0;

            player.eddieWeAreActive = false;
            player.maxSpd = player.eddieWeAreOriginalMaxSpd;
            player.eddieWeAreEndTime = 0;

            player.cristianoPortugueseSpiritActive = false;
            player.cristianoPortugueseSpiritEndTime = 0;
            player.eddieVenomStrikeActive = false;
            player.eddieSymbioteMontageActive = false;
            player.eddieSymbioteMontagePhase = '';
            player.eddieSymbioteMontageTeleportCount = 0;
            player.eddieSymbioteMontageAimStartTime = 0;
            player.eddieSymbioteMontageShotFired = false;

            player.zeusLightningCharging = false;
            player.zeusLightningChargeStartTime = 0;
            player.zeusLightningActive = false;
            player.zeusHeavenlyShieldActive = false;
            player.zeusHeavenlyShieldEndTime = 0;
            player.zeusHeavenlyShieldRadius = 0;
            player.zeusOlympusFuryActive = false;
            player.zeusOlympusFuryPhase = '';
            player.zeusOlympusFuryPullStartTime = 0;
            player.zeusOlympusFuryAimStartTime = 0;
            player.zeusOlympusFuryShotFired = false;
            player.zeusOlympusFuryOrigHasBall = false;
            player.asherAutoGoalActive = false;

            player.leonardoFocusShotActive = false;
            player.leonardoShieldActive = false;
            player.leonardoDashing = false;
            player.angusCharging = false;
            player.angusChargeStartTime = 0;
            player.angusBurstUsesLeft = 3;
            player.angusTimeStopActive = false;
            player.angusTimeStopEndTime = 0;
            player.angusTeleportActive = false;




            vfx.trail = [];
            vfx.sparks = [];
            vfx.shockwaves = [];
            vfx.flashes = [];
            vfx.lines = [];
            vfx.robsanParticles = [];
            vfx.robsanAura = [];
            vfx.shadowTrails = [];
            vfx.robsanChargeAura = [];
            vfx.eclipseAura = [];
            vfx.eclipseLines = [];
            vfx.voidTrails = [];
            vfx.xdrakeSupernovaTrails = [];
            vfx.xdrakeFootworkDust = [];
            vfx.xdrakeApexAura = [];
            vfx.gojoRedTrail = [];
            vfx.gojoBlueOrbitParticles = [];
            vfx.gojoPurpleCombineVFX = [];
            vfx.gojoPurpleTrail = [];
            vfx.eddieWeAreAura = [];
            vfx.eddieWeAreParticles = [];
            vfx.eddieVenomTendrils = [];
            vfx.eddieVenomShotTrail = [];
            vfx.eddieSymbioteMontageAimAura = [];
            vfx.blackPuddles = [];

            vfx.zeusLightningParticles = [];
            vfx.zeusLightningTrail = [];
            vfx.zeusHeavenlyShieldWaves = [];
            vfx.zeusHeavenlyShieldAura = [];
            vfx.zeusOlympusFuryAura = [];
            vfx.zeusOlympusFuryBallTrail = [];
            vfx.zeusLightningChargeEffect = [];
            vfx.zeusOlympusFuryPullLines = [];
            vfx.zeusGroundScorches = [];

            vfx.ignisFireBreathParticles = [];
            vfx.ignisFireBreathLines = [];
            vfx.ignisBlazeDashTrail = [];
            vfx.ignisBlazeDashParticles = [];
            vfx.ignisBlazeDashFlames = [];
            vfx.ignisPhoenixBurstParticles = [];
            vfx.ignisPhoenixBurstChargeAura = [];

            vfx.asherStarTrail = [];
            vfx.asherTeleportBurst = [];
            vfx.asherArrivalGlimmer = [];

            vfx.hudsonEmperorDribbleTrail = [];
            vfx.hudsonEmperorDribbleParticles = [];
            vfx.hudsonEmperorDribbleAura = [];
            vfx.robsanGroundRupture = [];
            vfx.robsanEclipseWisps = [];
            vfx.robsanVoidPuffs = [];
            vfx.xdrakeSupernovaGroundCrack = [];
            vfx.xdrakeFootworkLeaves = [];
            vfx.xdrakeAncientApexGroundBurst = [];
            vfx.gojoRedExplosion = [];
            vfx.gojoLapseBluePullEffect = [];
            vfx.gojoPurpleArcs = [];
            vfx.eddieWeAreRipples = [];
            vfx.eddieVenomBallSwirl = [];
            vfx.eddieTeleportFlicker = [];

            vfx.hudsonSpeedLines = [];
            vfx.hudsonEnergyWaves = [];
            vfx.robsanShadowClones = [];
            vfx.robsanVoidRifts = [];
            vfx.xdrakeNatureSpirits = [];
            vfx.xdrakeTerraforms = [];
            vfx.gojoInfinityBarriers = [];
            vfx.gojoDomainExpansions = [];
            vfx.eddieSymbioteSpikes = [];
            vfx.eddieVenomDrops = [];
            vfx.zeusThunderClouds = [];
            vfx.zeusLightningBolts = [];
            vfx.playerMovementTrail = [];
            vfx.fieldCracks = [];
            vfx.energyResidue = [];
            vfx.shockwaveRings = [];
            vfx.leonardoFocusText = [];
            vfx.leonardoFocusParticles = [];
            vfx.leonardoShieldAura = [];
            vfx.leonardoShieldParticles = [];
            vfx.leonardoDashTrail = [];
            vfx.leonardoDashParticles = [];
            vfx.leonardoPatternField = [];
            vfx.angusChargeParticles = [];
            vfx.angusBurstVFX = [];
            vfx.angusTimeStopField = [];
            vfx.angusTeleportTrail = [];
            vfx.cristianoPowerShotTrail = [];
            vfx.cristianoGoatTackleParticles = [];
            vfx.cristianoPortugueseSpiritAura = [];
            vfx.cristianoMovementTrail = [];

            vfx.korbinFireApocalypseFlames = [];
            vfx.korbinFireApocalypseEmbers = [];
            vfx.korbinFireApocalypseExplosion = [];
            vfx.korbinFireApocalypseTrail = [];
            vfx.korbinFireApocalypseShockwave = [];
            vfx.korbinBigShotWindParticles = [];
            vfx.korbinBigShotWindSwirls = [];
            vfx.korbinBigShotWindTrail = [];
            vfx.korbinBigBackPowerWindTrail = [];
            vfx.korbinBigBackPowerWindBurst = [];
            vfx.korbinBigBackPowerShockwave = [];

            vfx.wallyRocketTrail = [];
            vfx.wallySpeedForceDome = [];
            vfx.wallySpeedForceAura = [];
            vfx.wallyLightningAura = [];
            vfx.wallyLightningBolts = [];
            vfx.wallyMovementTrail = [];

            vfx.sixtySevenKidTextClones = [];
            vfx.sixtySevenKidMayhemAura = [];
            vfx.sixtySevenKidBlackoutOverlay = [];
            
            vfx.rabiesRagebaitTrail = [];
            vfx.rabiesRagebaitVeins = [];
            vfx.rabiesRagebaitBallLines = [];
            vfx.rabiesSquidTentacles = [];
            vfx.rabiesSquidGlaze = [];
            vfx.rabiesStealTentacles = [];
            vfx.rabiesPookiePowerPfps = [];
            vfx.rabiesPookiePowerAura = [];
        }

        function resetGame(){
            scoreL=0; scoreR=0;
            resetRound();
        }

        function loop(timestamp) {
            if (!isPlaying) return;
            const dt = Math.min(timestamp - last, 16.67);
            last = timestamp;

            updatePlayer(dt);
            updateBall(dt);
            updateAI(dt);
            updateVFX(dt);
            updateEddieAwakeningTimer();
            updateAwakeningTimer();
            checkGoal();

            ctx.save();
            ctx.clearRect(0, 0, W, H);
            drawField();
            drawBall();
            drawPlayer();
            drawAI();
            drawVFX(dt);
            drawUI();
            ctx.restore();

            loopId = requestAnimationFrame(loop);
        }


              function drawVFX(dt){
            const now = performance.now();

            for(const p of vfx.sparks){
                if (p.attachedToPlayer) {
                    if (p.isShield) {
                        p.x = player.x;
                        p.y = player.y;
                    } else if (p.isShieldSparkle) {
                        p.orbitalAngle += 0.02;
                        p.x = player.x + Math.cos(p.orbitalAngle) * p.orbitalDistance;
                        p.y = player.y + Math.sin(p.orbitalAngle) * p.orbitalDistance;
                    } else if (p.isSpeedAura) {
                        p.x = player.x;
                        p.y = player.y;
                    } else if (p.isSpeedBoost) {
                        const trailX = player.x - (player.vx || 0) * 3 + (Math.random() - 0.5) * 40;
                        const trailY = player.y - (player.vy || 0) * 3 + (Math.random() - 0.5) * 40;
                        p.x = trailX;
                        p.y = trailY;
                    }
                }

                const f = 1 - p.t/p.life; 
                const a = f*0.9;
                
                if (p.isShield) {
                    const pulse = Math.sin(p.t * 0.005) * 0.3 + 0.7;
                    const shieldAlpha = a * pulse * 0.6;
                    
                    ctx.save();
                    ctx.globalAlpha = shieldAlpha;
                    ctx.strokeStyle = `rgba(0, 255, 255, ${shieldAlpha})`;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    const g = ctx.createRadialGradient(p.x, p.y, p.r * 0.8, p.x, p.y, p.r);
                    g.addColorStop(0, `rgba(0, 255, 255, ${shieldAlpha * 0.1})`);
                    g.addColorStop(1, `rgba(0, 255, 255, ${shieldAlpha * 0.4})`);
                    ctx.fillStyle = g;
                    ctx.fill();
                    ctx.restore();
                } else if (p.isSpeedAura) {
                    const pulse = Math.sin(p.t * 0.008) * 0.2 + 0.8;
                    const auraAlpha = a * pulse * 0.5;
                    
                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
                    g.addColorStop(0, `rgba(255, 215, 0, ${auraAlpha * 0.6})`);
                    g.addColorStop(0.7, `rgba(255, 165, 0, ${auraAlpha * 0.3})`);
                    g.addColorStop(1, `rgba(255, 100, 0, 0)`);
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*4);
                    g.addColorStop(0,`${p.color}${a})`);
                    g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
                }
            }


            for(const p of vfx.robsanParticles){
                const f = 1 - p.t/p.life;
                const a = f * 0.8;
                const pulse = Math.sin(p.t * 0.01) * 0.3 + 0.7;
                const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3.5);
                g.addColorStop(0,`rgba(68, 10, 107, ${a * pulse})`);
                g.addColorStop(0.5,`rgba(99, 58, 161, ${a * 0.6})`);
                g.addColorStop(1,`rgba(30, 0, 50, 0)`);
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r * pulse,0,Math.PI*2); ctx.fill();
            }

            for(const p of vfx.xdrakeFootworkDust){
                const f = 1 - p.t/p.life;
                const a = f * 0.85;
                const earthPulse = Math.sin(p.t * 0.008) * 0.3 + 0.7;
                const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3.5);
                g.addColorStop(0,`rgba(109, 75, 46, ${a * earthPulse})`);
                g.addColorStop(0.4,`rgba(34, 197, 94, ${a * 0.4})`);
                g.addColorStop(1,`rgba(101, 69, 34, 0)`);
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r * earthPulse,0,Math.PI*2); ctx.fill();
            }

            for(const p of vfx.gojoBlueOrbitParticles){
                const f = 1 - p.t/p.life;
                const a = f * 0.9;
                const infinityWave = Math.sin(p.t * 0.005) * 0.4 + 0.6;
                const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*4);
                g.addColorStop(0,`rgba(49, 130, 206, ${a * infinityWave})`);
                g.addColorStop(0.3,`rgba(255, 255, 255, ${a * 0.5})`);
                g.addColorStop(1,`rgba(44, 82, 130, 0)`);
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r * infinityWave,0,Math.PI*2); ctx.fill();
            }

            for (const p of vfx.angusChargeParticles) {
                const f = 1 - p.t/p.life;
                const a = f * 0.9;
                const shimmer = Math.sin(p.t * 0.02) * 0.2 + 0.8;
                const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 3.5);
                g.addColorStop(0, `rgba(255, 255, 255, ${a * shimmer})`);
                g.addColorStop(0.6, `rgba(243, 244, 246, ${a * 0.7})`);
                g.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * shimmer, 0, Math.PI * 2);
                ctx.fill();
            }

            // Rabies VFX Rendering
            for (const trail of vfx.rabiesRagebaitTrail) {
                if (!trail.x || !trail.y || !isFinite(trail.x) || !isFinite(trail.y)) continue;
                
                // Skip if delay hasn't passed yet
                if (trail.delay && trail.t < trail.delay) continue;
                
                const f = 1 - trail.t / trail.life;
                const a = f * 0.8;
                
                if (trail.isThinLine && trail.endX && trail.endY) {
                    // Render thin red line
                    const intensityFlicker = Math.sin(trail.t * 0.05) * 0.4 + 0.6;
                    ctx.strokeStyle = `rgba(255, 0, 0, ${a * intensityFlicker})`;
                    ctx.lineWidth = Math.max(0.5, trail.w * intensityFlicker);
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(trail.x, trail.y);
                    ctx.lineTo(trail.endX, trail.endY);
                    ctx.stroke();
                    
                    // Small glow at ends
                    const g = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, 3);
                    g.addColorStop(0, `rgba(255, 0, 0, ${a * intensityFlicker})`);
                    g.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Regular trail particles
                    if (!trail.r) continue;
                    const intensityFlicker = Math.sin(trail.t * 0.03) * 0.3 + 0.7;
                    const g = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, Math.max(1, trail.r * 2.5));
                    g.addColorStop(0, `rgba(255, 0, 0, ${a * intensityFlicker})`);
                    g.addColorStop(0.5, `rgba(135, 206, 235, ${a * 0.6})`);
                    g.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, Math.max(1, trail.r * intensityFlicker), 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            for (const vein of vfx.rabiesRagebaitVeins) {
                if (!vein.x1 || !vein.y1 || !vein.x2 || !vein.y2 || !isFinite(vein.x1) || !isFinite(vein.y1) || !isFinite(vein.x2) || !isFinite(vein.y2)) continue;
                const f = 1 - vein.t / vein.life;
                const a = f * 0.7;
                const pulse = Math.sin(vein.t * 0.02) * 0.4 + 0.6;
                ctx.strokeStyle = `rgba(255, 0, 0, ${a * pulse})`;
                ctx.lineWidth = Math.max(1, 2 * pulse);
                ctx.beginPath();
                ctx.moveTo(vein.x1, vein.y1);
                ctx.lineTo(vein.x2, vein.y2);
                ctx.stroke();
            }

            // Render 4 curved lines following the ball for rage bait
            if (vfx.rabiesRagebaitBallLines.length > 0 && ball._ragebaitTrail && ball._ragebaitTrail.length > 10) {
                for (let lineIndex = 0; lineIndex < 4; lineIndex++) {
                    const lineSpacing = 8; // Points apart for each line
                    const startIndex = lineIndex * lineSpacing;
                    
                    if (startIndex + 20 < ball._ragebaitTrail.length) { // Need enough points for smooth curve
                        ctx.strokeStyle = `rgba(255, 0, 0, 0.8)`;
                        ctx.lineWidth = 3 + lineIndex * 0.5; // Slightly different thickness for each line
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        
                        // Draw curved line through ball trail points
                        const points = ball._ragebaitTrail.slice(startIndex, startIndex + 25);
                        if (points.length >= 2) {
                            // Start the path
                            ctx.moveTo(points[0].x, points[0].y);
                            
                            // Create smooth curves using quadratic curves
                            for (let i = 1; i < points.length - 1; i += 2) {
                                const current = points[i];
                                const next = points[i + 1] || points[i];
                                
                                // Add slight curve offset for visual appeal
                                const curveOffset = Math.sin(i * 0.5 + lineIndex) * 5;
                                const perpAngle = Math.atan2(next.y - current.y, next.x - current.x) + Math.PI / 2;
                                const curveX = current.x + Math.cos(perpAngle) * curveOffset;
                                const curveY = current.y + Math.sin(perpAngle) * curveOffset;
                                
                                ctx.quadraticCurveTo(curveX, curveY, next.x, next.y);
                            }
                            
                            ctx.stroke();
                            
                            // Add glow effect
                            ctx.strokeStyle = `rgba(255, 100, 100, 0.4)`;
                            ctx.lineWidth = (3 + lineIndex * 0.5) + 2;
                            ctx.stroke();
                        }
                    }
                }
            }

            for (const tentacle of vfx.rabiesSquidTentacles) {
                if (!tentacle.x1 || !tentacle.y1 || !tentacle.x2 || !tentacle.y2 || !isFinite(tentacle.x1) || !isFinite(tentacle.y1) || !isFinite(tentacle.x2) || !isFinite(tentacle.y2)) continue;
                const f = 1 - tentacle.t / tentacle.life;
                const a = f * 0.8;
                const wiggle = Math.sin(tentacle.t * 0.025) * 0.3 + 0.7;
                ctx.strokeStyle = `rgba(135, 206, 235, ${a * wiggle})`;
                ctx.lineWidth = Math.max(1, 4 * wiggle);
                ctx.beginPath();
                ctx.moveTo(tentacle.x1, tentacle.y1);
                ctx.lineTo(tentacle.x2, tentacle.y2);
                ctx.stroke();
                
                // Tentacle tip glow
                const g = ctx.createRadialGradient(tentacle.x2, tentacle.y2, 0, tentacle.x2, tentacle.y2, 8);
                g.addColorStop(0, `rgba(135, 206, 235, ${a * 0.9})`);
                g.addColorStop(0.7, `rgba(0, 0, 0, ${a * 0.5})`);
                g.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(tentacle.x2, tentacle.y2, Math.max(1, 6 * wiggle), 0, Math.PI * 2);
                ctx.fill();
            }

            for (const glaze of vfx.rabiesSquidGlaze) {
                if (!glaze.x || !glaze.y || !glaze.r || !isFinite(glaze.x) || !isFinite(glaze.y) || !isFinite(glaze.r)) continue;
                const f = 1 - glaze.t / glaze.life;
                const a = f * 0.6;
                const sticky = Math.sin(glaze.t * 0.015) * 0.2 + 0.8;
                const g = ctx.createRadialGradient(glaze.x, glaze.y, 0, glaze.x, glaze.y, Math.max(1, glaze.r * 1.8));
                
                if (glaze.isWhiteCircling) {
                    // White circling particles around the ball
                    g.addColorStop(0, `rgba(255, 255, 255, ${a * sticky})`);
                    g.addColorStop(0.5, `rgba(200, 200, 255, ${a * 0.6})`);
                    g.addColorStop(1, 'rgba(255, 255, 255, 0)');
                } else {
                    // Regular squid glaze particles (dark/black)
                    g.addColorStop(0, `rgba(0, 0, 0, ${a * sticky})`);
                    g.addColorStop(0.6, `rgba(135, 206, 235, ${a * 0.4})`);
                    g.addColorStop(1, 'rgba(255, 255, 255, 0)');
                }
                
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(glaze.x, glaze.y, Math.max(1, glaze.r * sticky), 0, Math.PI * 2);
                ctx.fill();
            }

            for (const tentacle of vfx.rabiesStealTentacles) {
                // Skip rendering if delayed
                if (tentacle.delay && performance.now() - tentacle.createdAt < tentacle.delay) continue;
                
                const f = 1 - tentacle.t / tentacle.life;
                const a = f * 0.9;
                const menace = Math.sin(tentacle.t * 0.04) * 0.3 + 0.7;
                
                if (tentacle.isLiquidCircle) {
                    // White liquid circle effect around ball - MORE GLOWY AND VIBRANT
                    const liquidAlpha = f * 1.0; // Increased alpha
                    const ripple = Math.sin(tentacle.t * 0.04 + tentacle.liquidPhase) * 3 + 4; // Bigger ripple
                    const pulse = Math.sin(tentacle.t * 0.06) * 0.3 + 1.0; // Pulsing effect
                    
                    // Outer glow layer - much brighter
                    const outerGlow = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, (tentacle.width + ripple) * pulse * 2));
                    outerGlow.addColorStop(0, `rgba(255, 255, 255, ${liquidAlpha * 0.9})`);
                    outerGlow.addColorStop(0.2, `rgba(255, 255, 255, ${liquidAlpha * 0.7})`);
                    outerGlow.addColorStop(0.5, `rgba(135, 206, 235, ${liquidAlpha * 0.5})`);
                    outerGlow.addColorStop(0.8, `rgba(200, 230, 255, ${liquidAlpha * 0.2})`);
                    outerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = outerGlow;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, (tentacle.width + ripple) * pulse * 2), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Main liquid circle - enhanced
                    const mainGlow = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, (tentacle.width + ripple) * pulse));
                    mainGlow.addColorStop(0, `rgba(255, 255, 255, ${liquidAlpha})`);
                    mainGlow.addColorStop(0.3, `rgba(255, 255, 255, ${liquidAlpha * 0.9})`);
                    mainGlow.addColorStop(0.6, `rgba(200, 230, 255, ${liquidAlpha * 0.6})`);
                    mainGlow.addColorStop(1, 'rgba(135, 206, 235, 0)');
                    ctx.fillStyle = mainGlow;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, (tentacle.width + ripple) * pulse), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner bright core - super bright
                    const coreGlow = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, tentacle.width * 0.6 * pulse));
                    coreGlow.addColorStop(0, `rgba(255, 255, 255, ${liquidAlpha})`);
                    coreGlow.addColorStop(0.5, `rgba(255, 255, 255, ${liquidAlpha * 0.8})`);
                    coreGlow.addColorStop(1, `rgba(255, 255, 255, ${liquidAlpha * 0.3})`);
                    ctx.fillStyle = coreGlow;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, tentacle.width * 0.6 * pulse), 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (tentacle.isLiquidParticle) {
                    // Liquid particles flowing toward ball - MORE GLOWY
                    const liquidAlpha = f * 0.9; // Increased alpha
                    const flow = Math.sin(tentacle.t * 0.06) * 2 + 2.5; // Bigger flow effect
                    const sparkle = Math.sin(tentacle.t * 0.1 + Math.random() * Math.PI) * 0.4 + 1.0;
                    
                    // Outer particle glow
                    const particleGlow = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, (tentacle.width + flow) * sparkle * 1.8));
                    particleGlow.addColorStop(0, `rgba(255, 255, 255, ${liquidAlpha * 0.8})`);
                    particleGlow.addColorStop(0.4, `rgba(255, 255, 255, ${liquidAlpha * 0.6})`);
                    particleGlow.addColorStop(0.7, `rgba(200, 230, 255, ${liquidAlpha * 0.3})`);
                    particleGlow.addColorStop(1, 'rgba(135, 206, 235, 0)');
                    ctx.fillStyle = particleGlow;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, (tentacle.width + flow) * sparkle * 1.8), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Core particle
                    const coreParticle = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, (tentacle.width + flow) * sparkle));
                    coreParticle.addColorStop(0, `rgba(255, 255, 255, ${liquidAlpha})`);
                    coreParticle.addColorStop(0.5, `rgba(255, 255, 255, ${liquidAlpha * 0.7})`);
                    coreParticle.addColorStop(1, 'rgba(200, 230, 255, 0)');
                    ctx.fillStyle = coreParticle;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, (tentacle.width + flow) * sparkle), 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (tentacle.isLiquidTrail) {
                    // Liquid trail particles left behind as ball moves - MORE GLOWY
                    const trailAlpha = f * 0.9; // Increased alpha
                    const pulse = Math.sin(tentacle.t * 0.08) * 0.7 + 1.3; // Bigger pulse
                    const shimmer = Math.sin(tentacle.t * 0.12 + Math.random() * Math.PI) * 0.3 + 1.0;
                    
                    // Outer trail glow
                    const trailGlow = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, tentacle.width * pulse * shimmer * 2));
                    trailGlow.addColorStop(0, `rgba(255, 255, 255, ${trailAlpha * 0.7})`);
                    trailGlow.addColorStop(0.4, `rgba(255, 255, 255, ${trailAlpha * 0.5})`);
                    trailGlow.addColorStop(0.7, `rgba(200, 230, 255, ${trailAlpha * 0.3})`);
                    trailGlow.addColorStop(1, 'rgba(135, 206, 235, 0)');
                    ctx.fillStyle = trailGlow;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, tentacle.width * pulse * shimmer * 2), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Main trail particle
                    const mainTrail = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, tentacle.width * pulse * shimmer));
                    mainTrail.addColorStop(0, `rgba(255, 255, 255, ${trailAlpha})`);
                    mainTrail.addColorStop(0.6, `rgba(200, 230, 255, ${trailAlpha * 0.6})`);
                    mainTrail.addColorStop(1, 'rgba(135, 206, 235, 0)');
                    ctx.fillStyle = mainTrail;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, tentacle.width * pulse * shimmer), 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (tentacle.isImpactSpark) {
                    // Impact sparks when tentacle touches ball - MORE VIBRANT
                    const sparkAlpha = f * 1.0;
                    const sparkSize = 3 + Math.sin(tentacle.t * 0.15) * 2; // Bigger sparks
                    const intensity = Math.sin(tentacle.t * 0.2) * 0.5 + 1.0;
                    
                    // Bright outer spark glow
                    const sparkGlow = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, sparkSize * intensity * 2.5));
                    sparkGlow.addColorStop(0, `rgba(255, 255, 255, ${sparkAlpha})`);
                    sparkGlow.addColorStop(0.3, `rgba(255, 255, 0, ${sparkAlpha * 0.8})`);
                    sparkGlow.addColorStop(0.6, `rgba(255, 200, 0, ${sparkAlpha * 0.5})`);
                    sparkGlow.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = sparkGlow;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, sparkSize * intensity * 2.5), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner spark core
                    const sparkCore = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, sparkSize * intensity));
                    sparkCore.addColorStop(0, `rgba(255, 255, 255, ${sparkAlpha})`);
                    sparkCore.addColorStop(0.5, `rgba(255, 255, 0, ${sparkAlpha * 0.9})`);
                    sparkCore.addColorStop(1, `rgba(255, 200, 0, ${sparkAlpha * 0.4})`);
                    ctx.fillStyle = sparkCore;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, sparkSize * intensity), 0, Math.PI * 2);
                    ctx.fill();
                    
                    const g = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, sparkSize));
                    g.addColorStop(0, `rgba(255, 255, 255, ${sparkAlpha})`);
                    g.addColorStop(0.5, `rgba(255, 255, 0, ${sparkAlpha * 0.8})`);
                    g.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, sparkSize), 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (tentacle.isWhitePuddle) {
                    // White puddles along the path (legacy support)
                    const puddleAlpha = f * 0.8;
                    const ripple = Math.sin(tentacle.t * 0.03) * 2 + tentacle.puddleSize;
                    
                    const g = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, ripple));
                    g.addColorStop(0, `rgba(255, 255, 255, ${puddleAlpha})`);
                    g.addColorStop(0.4, `rgba(255, 255, 255, ${puddleAlpha * 0.7})`);
                    g.addColorStop(0.8, `rgba(135, 206, 235, ${puddleAlpha * 0.3})`);
                    g.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, ripple), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Secondary smaller puddle for depth
                    ctx.fillStyle = `rgba(255, 255, 255, ${puddleAlpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, ripple * 0.4), 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (tentacle.isWhiteVfx) {
                    // White VFX particles getting the ball (legacy support)
                    const g = ctx.createRadialGradient(tentacle.x, tentacle.y, 0, tentacle.x, tentacle.y, Math.max(1, tentacle.width * 3));
                    g.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                    g.addColorStop(0.7, `rgba(135, 206, 235, ${a * 0.5})`);
                    g.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(tentacle.x, tentacle.y, Math.max(1, tentacle.width * 2), 0, Math.PI * 2);
                    ctx.fill();
                } else if (tentacle.x1 && tentacle.y1 && tentacle.x2 && tentacle.y2 && isFinite(tentacle.x1) && isFinite(tentacle.y1) && isFinite(tentacle.x2) && isFinite(tentacle.y2)) {
                    // Enhanced squiggly tentacles or regular tentacles
                    const baseAlpha = a * menace;
                    
                    // Apply shrink factor if available (for decreasing size effect)
                    const shrinkFactor = tentacle.shrinkFactor !== undefined ? tentacle.shrinkFactor : 1.0;
                    const glowIntensity = shrinkFactor * 1.5 + 0.5; // More glow as it shrinks
                    
                    if (tentacle.isSquiggly) {
                        // Render squiggly lines with multiple segments - MORE GLOWY
                        const squiggleAmount = Math.sin(tentacle.t * 0.05 + tentacle.squigglePhase) * 8 * shrinkFactor;
                        const segments = Math.max(4, tentacle.segments);
                        
                        // Outer glow for tentacle
                        ctx.strokeStyle = `rgba(200, 230, 255, ${baseAlpha * 0.4 * glowIntensity})`;
                        ctx.lineWidth = Math.max(1, tentacle.width * 4 * shrinkFactor);
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        ctx.beginPath();
                        ctx.moveTo(tentacle.x1, tentacle.y1);
                        
                        for (let i = 1; i <= segments; i++) {
                            const progress = i / segments;
                            const baseX = tentacle.x1 + (tentacle.x2 - tentacle.x1) * progress;
                            const baseY = tentacle.y1 + (tentacle.y2 - tentacle.y1) * progress;
                            
                            // Add squiggle effect
                            const perpX = -(tentacle.y2 - tentacle.y1) / Math.hypot(tentacle.x2 - tentacle.x1, tentacle.y2 - tentacle.y1);
                            const perpY = (tentacle.x2 - tentacle.x1) / Math.hypot(tentacle.x2 - tentacle.x1, tentacle.y2 - tentacle.y1);
                            const squiggleOffset = Math.sin(progress * Math.PI * 4 + tentacle.t * 0.03 + tentacle.squigglePhase) * squiggleAmount;
                            
                            const x = baseX + perpX * squiggleOffset;
                            const y = baseY + perpY * squiggleOffset;
                            
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        
                        // Main tentacle line - brighter and shrinking
                        ctx.strokeStyle = `rgba(255, 255, 255, ${baseAlpha * glowIntensity})`;
                        ctx.lineWidth = Math.max(1, tentacle.width * 2.5 * shrinkFactor);
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        ctx.beginPath();
                        ctx.moveTo(tentacle.x1, tentacle.y1);
                        
                        for (let i = 1; i <= segments; i++) {
                            const progress = i / segments;
                            const baseX = tentacle.x1 + (tentacle.x2 - tentacle.x1) * progress;
                            const baseY = tentacle.y1 + (tentacle.y2 - tentacle.y1) * progress;
                            
                            const perpX = -(tentacle.y2 - tentacle.y1) / Math.hypot(tentacle.x2 - tentacle.x1, tentacle.y2 - tentacle.y1);
                            const perpY = (tentacle.x2 - tentacle.x1) / Math.hypot(tentacle.x2 - tentacle.x1, tentacle.y2 - tentacle.y1);
                            const squiggleOffset = Math.sin(progress * Math.PI * 4 + tentacle.t * 0.03 + tentacle.squigglePhase) * squiggleAmount;
                            
                            const x = baseX + perpX * squiggleOffset;
                            const y = baseY + perpY * squiggleOffset;
                            
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        
                        // Inner bright core line
                        ctx.strokeStyle = `rgba(255, 255, 255, ${baseAlpha * glowIntensity * 1.2})`;
                        ctx.lineWidth = Math.max(0.5, tentacle.width * 1.2 * shrinkFactor);
                        
                        ctx.beginPath();
                        ctx.moveTo(tentacle.x1, tentacle.y1);
                        
                        for (let i = 1; i <= segments; i++) {
                            const progress = i / segments;
                            const baseX = tentacle.x1 + (tentacle.x2 - tentacle.x1) * progress;
                            const baseY = tentacle.y1 + (tentacle.y2 - tentacle.y1) * progress;
                            
                            const perpX = -(tentacle.y2 - tentacle.y1) / Math.hypot(tentacle.x2 - tentacle.x1, tentacle.y2 - tentacle.y1);
                            const perpY = (tentacle.x2 - tentacle.x1) / Math.hypot(tentacle.x2 - tentacle.x1, tentacle.y2 - tentacle.y1);
                            const squiggleOffset = Math.sin(progress * Math.PI * 4 + tentacle.t * 0.03 + tentacle.squigglePhase) * squiggleAmount;
                            
                            const x = baseX + perpX * squiggleOffset;
                            const y = baseY + perpY * squiggleOffset;
                            
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        
                        // Enhanced energy burst at tip - scales with shrink factor
                        if (shrinkFactor > 0.1) { // Only show if tentacle is big enough
                            const tipGlow = (15 + Math.sin(tentacle.t * 0.06 + tentacle.squigglePhase) * 5) * shrinkFactor * glowIntensity;
                            const g = ctx.createRadialGradient(tentacle.x2, tentacle.y2, 0, tentacle.x2, tentacle.y2, tipGlow);
                            g.addColorStop(0, `rgba(255, 255, 255, ${baseAlpha * glowIntensity})`);
                            g.addColorStop(0.3, `rgba(255, 255, 255, ${baseAlpha * 0.8 * glowIntensity})`);
                            g.addColorStop(0.6, `rgba(200, 230, 255, ${baseAlpha * 0.6 * glowIntensity})`);
                            g.addColorStop(1, 'rgba(135, 206, 235, 0)');
                            ctx.fillStyle = g;
                            ctx.beginPath();
                            ctx.arc(tentacle.x2, tentacle.y2, Math.max(1, tipGlow), 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                    } else {
                        // Regular tentacles
                        ctx.strokeStyle = `rgba(255, 255, 255, ${baseAlpha})`;
                        ctx.lineWidth = Math.max(1, 5 * menace);
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(tentacle.x1, tentacle.y1);
                        ctx.lineTo(tentacle.x2, tentacle.y2);
                        ctx.stroke();
                        
                        // White energy burst at tip
                        const g = ctx.createRadialGradient(tentacle.x2, tentacle.y2, 0, tentacle.x2, tentacle.y2, 10);
                        g.addColorStop(0, `rgba(255, 255, 255, ${baseAlpha})`);
                        g.addColorStop(0.5, `rgba(135, 206, 235, ${baseAlpha * 0.6})`);
                        g.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        ctx.fillStyle = g;
                        ctx.beginPath();
                        ctx.arc(tentacle.x2, tentacle.y2, Math.max(1, 8 * menace), 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            for (const pfp of vfx.rabiesPookiePowerPfps) {
                if (!pfp.x || !pfp.y || !isFinite(pfp.x) || !isFinite(pfp.y)) continue;
                const f = 1 - pfp.t / pfp.life;
                const a = f * 0.9;
                const divine = Math.sin(pfp.t * 0.02 + pfp.pulsePhase) * 0.4 + 0.6;
                const scalePulse = Math.sin(pfp.t * 0.03 + pfp.pulsePhase) * 0.2 + 1;
                
                // Enhanced PFP shadow/glow with multiple layers
                const shadowRadius = 35 * pfp.scale * scalePulse;
                const shadowG = ctx.createRadialGradient(pfp.x, pfp.y, 0, pfp.x, pfp.y, shadowRadius);
                shadowG.addColorStop(0, `rgba(255, 255, 255, ${a * divine * 0.8})`);
                shadowG.addColorStop(0.3, `rgba(135, 206, 235, ${a * 0.6})`);
                shadowG.addColorStop(0.7, `rgba(255, 255, 255, ${a * 0.3})`);
                shadowG.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = shadowG;
                ctx.beginPath();
                ctx.arc(pfp.x, pfp.y, shadowRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Power ring around PFP
                ctx.strokeStyle = `rgba(255, 255, 255, ${a * divine})`;
                ctx.lineWidth = 3 * scalePulse;
                ctx.beginPath();
                ctx.arc(pfp.x, pfp.y, 25 * pfp.scale * scalePulse, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw the actual PFP image if available (BIGGER!)
                if (pfp.image && pfp.image.complete) {
                    ctx.save();
                    ctx.globalAlpha = a;
                    const size = 40 * pfp.scale * scalePulse; // Much bigger!
                    
                    // Add glow filter effect
                    ctx.shadowColor = 'rgba(135, 206, 235, 0.8)';
                    ctx.shadowBlur = 10 * scalePulse;
                    
                    ctx.drawImage(pfp.image, pfp.x - size/2, pfp.y - size/2, size, size);
                    ctx.restore();
                } else {
                    // Enhanced PFP main circle fallback
                    const size = 20 * pfp.scale * scalePulse;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${a})`;
                    ctx.fillStyle = `rgba(135, 206, 235, ${a * 0.4})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(pfp.x, pfp.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                
                // Energy sparks around PFP
                if (Math.random() < 0.3) {
                    const sparkAngle = Math.random() * Math.PI * 2;
                    const sparkDist = 30 + Math.random() * 20;
                    const sparkX = pfp.x + Math.cos(sparkAngle) * sparkDist;
                    const sparkY = pfp.y + Math.sin(sparkAngle) * sparkDist;
                    
                    const sparkG = ctx.createRadialGradient(sparkX, sparkY, 0, sparkX, sparkY, 4);
                    sparkG.addColorStop(0, `rgba(255, 255, 255, ${a * 0.8})`);
                    sparkG.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = sparkG;
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            for (const aura of vfx.rabiesPookiePowerAura) {
                if (!aura.x || !aura.y || !aura.size || !isFinite(aura.x) || !isFinite(aura.y) || !isFinite(aura.size)) continue;
                
                // Skip if delay hasn't passed yet
                if (aura.delay && aura.t < aura.delay) continue;
                
                const f = 1 - aura.t / aura.life;
                const a = f * 0.7;
                const godly = Math.sin(aura.t * 0.01) * 0.5 + 0.5;
                
                if (aura.isRingVfx) {
                    // Special ring VFX around PFPs
                    const g = ctx.createRadialGradient(aura.x, aura.y, 0, aura.x, aura.y, Math.max(1, aura.size * 1.5));
                    g.addColorStop(0, `rgba(255, 255, 255, ${a * godly})`);
                    g.addColorStop(0.5, `rgba(135, 206, 235, ${a * 0.8})`);
                    g.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(aura.x, aura.y, Math.max(1, aura.size * godly), 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Regular power aura particles
                    const g = ctx.createRadialGradient(aura.x, aura.y, 0, aura.x, aura.y, Math.max(1, aura.size * 2));
                    g.addColorStop(0, `rgba(255, 255, 255, ${a * godly * 0.4})`);
                    g.addColorStop(0.3, `rgba(135, 206, 235, ${a * 0.6})`);
                    g.addColorStop(0.7, `rgba(0, 0, 0, ${a * 0.4})`);
                    g.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(aura.x, aura.y, Math.max(1, aura.size * godly), 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            for (const burst of vfx.angusBurstVFX) {
                const progress = burst.t / burst.life;
                const opacity = Math.sin(progress * Math.PI) * 0.6;
                const radius = burst.radius * (1 + progress * 2);

                ctx.save();
                ctx.translate(burst.x, burst.y);

                const burstGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                burstGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                burstGradient.addColorStop(0.5, `rgba(243, 244, 246, ${opacity * 0.6})`);
                burstGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = burstGradient;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                ctx.lineWidth = 3;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const lineLength = radius * 0.7;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 20, Math.sin(angle) * 20);
                    ctx.lineTo(Math.cos(angle) * lineLength, Math.sin(angle) * lineLength);
                    ctx.stroke();
                }

                ctx.restore();
            }

            if (vfx.angusPuddles) {
for (let i = vfx.angusPuddles.length - 1; i >= 0; i--) {
const p = vfx.angusPuddles[i];
p.t += 30;

ctx.save();
ctx.globalAlpha = p.alpha * (1 - p.t / p.life);
ctx.fillStyle = 'white';
ctx.beginPath();
ctx.ellipse(p.x, p.y, p.radius, p.radius * 0.4, 0, 0, Math.PI * 2);
ctx.fill();
ctx.restore();

if (p.t >= p.life) {
vfx.angusPuddles.splice(i, 1);
}
}
}


            for (const field of vfx.angusTimeStopField) {
                const progress = field.t / field.life;
                const opacity = Math.sin(progress * Math.PI) * 0.4;
                const radius = field.radius;

                ctx.save();
                ctx.translate(field.x, field.y);

                for (let i = 0; i < 4; i++) {
                    const ringRadius = radius * (0.3 + i * 0.2);
                    const ringOpacity = opacity * (1 - i * 0.2);

                    ctx.strokeStyle = `rgba(156, 163, 175, ${ringOpacity})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]);
                    ctx.lineDashOffset = -performance.now() * 0.01 * (i + 1);
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                ctx.restore();
            }

            for (const trail of vfx.angusTeleportTrail) {
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * 0.7;

                ctx.save();
                ctx.strokeStyle = `rgba(75, 85, 99, ${opacity})`;
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';

                const gradient = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                gradient.addColorStop(0, `rgba(156, 163, 175, ${opacity})`);
                gradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity * 0.8})`);
                gradient.addColorStop(1, `rgba(75, 85, 99, ${opacity})`);
                ctx.strokeStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(trail.startX, trail.startY);
                ctx.lineTo(trail.endX, trail.endY);
                ctx.stroke();

                ctx.restore();
            }

for (const text of vfx.leonardoFocusText) {
    const progress = text.t / text.life;
    const easeOut = 1 - Math.pow(1 - progress, 3);
    const opacity = Math.sin(progress * Math.PI);

    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--leonardo-accent');
    ctx.shadowBlur = 20;
    ctx.font = `bold 32px 'Segoe UI'`;

    ctx.save();
    ctx.translate(text.x - (70 * easeOut), text.y);
    ctx.rotate(-Math.PI / 12 * easeOut);
    ctx.fillStyle = 'black';
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.font = `bold 36px 'Segoe UI'`;
    ctx.strokeText('AUTISM', 0, 0);
    ctx.fillText('AUTISM', 0, 0);
    ctx.restore();

    ctx.save();
    ctx.translate(text.x + (70 * easeOut), text.y);
    ctx.rotate(Math.PI / 12 * easeOut);
    ctx.fillStyle = 'black';
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.font = `bold 36px 'Segoe UI'`;
    ctx.strokeText('ATTACK', 0, 0);
    ctx.fillText('ATTACK', 0, 0);
    ctx.restore();

    ctx.save();
    ctx.translate(text.x, text.y);
    const burstRadius = 30 * (1 - progress);
    const burstGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, burstRadius);
    burstGradient.addColorStop(0, `rgba(165, 243, 252, ${opacity * 0.8})`);
    burstGradient.addColorStop(1, 'rgba(165, 243, 252, 0)');
    ctx.fillStyle = burstGradient;
    ctx.beginPath();
    ctx.arc(0, 0, burstRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.restore();
}


            for (const aura of vfx.leonardoShieldAura) {
                const progress = aura.t / aura.life;
                const opacity = Math.sin(progress * Math.PI) * 0.4;
                const rotation = performance.now() * 0.001;
                const fastRotation = performance.now() * 0.003;

                ctx.save();
                ctx.translate(aura.x, aura.y);

                ctx.strokeStyle = `rgba(6, 182, 212, ${opacity * 0.8})`;
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.lineDashOffset = -performance.now() * 0.05;
                ctx.beginPath();
                ctx.arc(0, 0, aura.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                for (let layer = 0; layer < 4; layer++) {
                    const radius = aura.radius * (0.3 + layer * 0.15);
                    const layerRotation = rotation * (layer % 2 === 0 ? 1 : -1) * (1 + layer * 0.3);
                    const layerOpacity = opacity * (1 - layer * 0.15);

                    ctx.strokeStyle = `rgba(165, 243, 252, ${layerOpacity})`;
                    ctx.lineWidth = 2 - layer * 0.3;
                    ctx.beginPath();
                    for (let j = 0; j < 6; j++) {
                        const angle = (j * Math.PI / 3) + layerRotation;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }

                for (let i = 0; i < 8; i++) {
                    const particleAngle = (i / 8) * Math.PI * 2 + fastRotation;
                    const particleRadius = aura.radius * 0.8 + Math.sin(fastRotation * 2 + i) * 10;
                    const px = Math.cos(particleAngle) * particleRadius;
                    const py = Math.sin(particleAngle) * particleRadius;

                    const particleGradient = ctx.createRadialGradient(px, py, 0, px, py, 8);
                    particleGradient.addColorStop(0, `rgba(165, 243, 252, ${opacity * 0.9})`);
                    particleGradient.addColorStop(1, 'rgba(165, 243, 252, 0)');
                    ctx.fillStyle = particleGradient;
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            if (vfx.leonardoDashTrail.length && player._leonardoDashTrail && player._leonardoDashTrail.length > 1) {
                const trail = player._leonardoDashTrail;
                for (let i = 0; i < trail.length - 1; i++) {
                    const p = trail[i];
                    const n = trail[i + 1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / (LEONARDO_DASH_DURATION + 150), 0, 1);

                    const weaveOffset = Math.sin(i * 0.8 + performance.now() * 0.02) * 10;
                    const perpDir = Math.atan2(n.y - p.y, n.x - p.x) + Math.PI / 2;

                    const x1 = p.x + Math.cos(perpDir) * weaveOffset;
                    const y1 = p.y + Math.sin(perpDir) * weaveOffset;
                    const x2 = n.x + Math.cos(perpDir) * weaveOffset;
                    const y2 = n.y + Math.sin(perpDir) * weaveOffset;

                    const g = ctx.createLinearGradient(x1, y1, x2, y2);
                    g.addColorStop(0, getRGBA(vfx.leonardoDashTrail[0].colorStart, a * 0.9));
                    g.addColorStop(1, getRGBA(vfx.leonardoDashTrail[0].colorEnd, a * 0.6));

                    ctx.strokeStyle = g;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }

            for (const field of vfx.leonardoPatternField) {
                const progress = field.t / field.life;
                const opacity = Math.sin(progress * Math.PI) * 0.3;
                const rotation = performance.now() * 0.002;

                ctx.save();
                ctx.translate(field.x, field.y);

                const fieldGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, field.radius);
                fieldGradient.addColorStop(0, `rgba(6, 182, 212, ${opacity * 0.6})`);
                fieldGradient.addColorStop(0.7, `rgba(165, 243, 252, ${opacity * 0.3})`);
                fieldGradient.addColorStop(1, 'rgba(165, 243, 252, 0)');
                ctx.fillStyle = fieldGradient;
                ctx.beginPath();
                ctx.arc(0, 0, field.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = `rgba(165, 243, 252, ${opacity * 0.8})`;
                ctx.lineWidth = 1;
                const gridSize = 15;
                const gridCount = Math.floor(field.radius * 2 / gridSize);

                for (let i = -gridCount; i <= gridCount; i++) {
                    for (let j = -gridCount; j <= gridCount; j++) {
                        const x = i * gridSize;
                        const y = j * gridSize;
                        const distance = Math.sqrt(x*x + y*y);

                        if (distance < field.radius) {
                            const nodeOpacity = opacity * (1 - distance / field.radius);
                            ctx.fillStyle = `rgba(165, 243, 252, ${nodeOpacity})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                for (let ring = 1; ring <= 3; ring++) {
                    const ringRadius = field.radius * (ring / 4);
                    ctx.strokeStyle = `rgba(6, 182, 212, ${opacity * (1 - ring * 0.2)})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 10]);
                    ctx.lineDashOffset = -performance.now() * 0.02 * ring;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                ctx.restore();
            }

            for(const p of vfx.leonardoFocusParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life; const a = f*0.9;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.98; p.vy*=0.98;
                
                const fieldRadius = p.r * (6 + Math.sin(p.t * 0.02) * 2);
                const fieldGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, fieldRadius);
                fieldGrad.addColorStop(0, `rgba(6, 182, 212, ${a * 0.3})`);
                fieldGrad.addColorStop(0.4, `${p.color}${a * 0.5})`);
                fieldGrad.addColorStop(0.8, `rgba(165, 243, 252, ${a * 0.2})`);
                fieldGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = fieldGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, fieldRadius, 0, Math.PI * 2);
                ctx.fill();
                
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 2);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                coreGrad.addColorStop(0.3, `${p.color}${a})`);
                coreGrad.addColorStop(0.7, `rgba(6, 182, 212, ${a * 0.8})`);
                coreGrad.addColorStop(1, `${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 2, 0, Math.PI * 2);
                ctx.fill();
                
                if(Math.random() < 0.4) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(165, 243, 252, ${a * 0.7})`;
                    ctx.lineWidth = 1;
                    for(let ring = 1; ring <= 3; ring++) {
                        const ringRadius = p.r * ring * 1.5;
                        ctx.setLineDash([2, 4]);
                        ctx.lineDashOffset = -p.t * 0.05 * ring;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, ringRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                    ctx.restore();
                }
            }
            vfx.leonardoFocusParticles = vfx.leonardoFocusParticles.filter(p=> p.t < p.life);

            for(const p of vfx.leonardoShieldParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life; const a = f*0.8;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.96; p.vy*=0.96;
                
                const shieldPulse = Math.sin(p.t * 0.03) * 0.4 + 0.6;
                const shieldGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 4 * shieldPulse);
                shieldGrad.addColorStop(0, `rgba(6, 182, 212, ${a * 0.7})`);
                shieldGrad.addColorStop(0.4, `${p.color}${a * 0.9})`);
                shieldGrad.addColorStop(0.8, `rgba(165, 243, 252, ${a * 0.4})`);
                shieldGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = shieldGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 4 * shieldPulse, 0, Math.PI * 2);
                ctx.fill();
                
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 2);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.9})`);
                coreGrad.addColorStop(0.3, `${p.color}${a})`);
                coreGrad.addColorStop(0.8, `rgba(6, 182, 212, ${a * 0.7})`);
                coreGrad.addColorStop(1, `${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 2, 0, Math.PI * 2);
                ctx.fill();
                
                if(Math.random() < 0.3) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(165, 243, 252, ${a * 0.8})`;
                    ctx.lineWidth = 2;
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.t * 0.02);
                    
                    ctx.beginPath();
                    for(let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const x = Math.cos(angle) * p.r * 3;
                        const y = Math.sin(angle) * p.r * 3;
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
            }
            vfx.leonardoShieldParticles = vfx.leonardoShieldParticles.filter(p=> p.t < p.life);

            for(const p of vfx.leonardoDashParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life; const a = f*0.7;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.94; p.vy*=0.94;
                
                const weaveIntensity = Math.sin(p.t * 0.025) * 0.5 + 0.5;
                const weaveGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 5);
                weaveGrad.addColorStop(0, `rgba(165, 243, 252, ${a * weaveIntensity * 0.6})`);
                weaveGrad.addColorStop(0.4, `${p.color}${a * 0.8})`);
                weaveGrad.addColorStop(0.8, `rgba(6, 182, 212, ${a * 0.4})`);
                weaveGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = weaveGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 5, 0, Math.PI * 2);
                ctx.fill();
                
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 2.5);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.9})`);
                coreGrad.addColorStop(0.3, `${p.color}${a})`);
                coreGrad.addColorStop(0.7, `rgba(165, 243, 252, ${a * 0.8})`);
                coreGrad.addColorStop(1, `${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                if(Math.random() < 0.5) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(165, 243, 252, ${a * 0.9})`;
                    ctx.lineWidth = 1.5;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = `rgba(6, 182, 212, ${a})`;
                    
                    for(let streak = 0; streak < 4; streak++) {
                        const angle = (streak / 4) * Math.PI * 2 + p.t * 0.01;
                        const length = p.r * (2 + Math.sin(p.t * 0.03 + streak) * 1);
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x + Math.cos(angle) * length, p.y + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
            vfx.leonardoDashParticles = vfx.leonardoDashParticles.filter(p=> p.t < p.life);

            for(const p of vfx.angusChargeParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life;
                const a = f * 0.8;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.95; p.vy*=0.95;
                
                const temporalPulse = Math.sin(p.t * 0.02) * 0.4 + 0.6;
                const temporalGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 5 * temporalPulse);
                temporalGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.4})`);
                temporalGrad.addColorStop(0.3, `${p.color}${a * 0.7})`);
                temporalGrad.addColorStop(0.7, `rgba(255, 255, 255, ${a * 0.3})`);
                temporalGrad.addColorStop(1, `rgba(255, 255, 255, 0)`);
                ctx.fillStyle = temporalGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 5 * temporalPulse, 0, Math.PI * 2);
                ctx.fill();
                
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 3);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                coreGrad.addColorStop(0.4, `${p.color}${a})`);
                coreGrad.addColorStop(0.8, `rgba(255, 255, 255, ${a * 0.7})`);
                coreGrad.addColorStop(1, `rgba(255, 255, 255, 0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 3, 0, Math.PI * 2);
                ctx.fill();
                
                if(Math.random() < 0.4) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 255, 255, ${a * 0.9})`;
                    ctx.lineWidth = 1 + Math.random();
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = `${p.color}${a})`;
                    
                    for(let spark = 0; spark < 3; spark++) {
                        const angle = Math.random() * Math.PI * 2;
                        const length = p.r * (1.5 + Math.random() * 2);
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        const endX = p.x + Math.cos(angle) * length;
                        const endY = p.y + Math.sin(angle) * length;
                        ctx.lineTo(endX + (Math.random() - 0.5) * 4, endY + (Math.random() - 0.5) * 4);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
            vfx.angusChargeParticles = vfx.angusChargeParticles.filter(p=> p.t < p.life);

            for (const burst of vfx.angusBurstVFX) {
                burst.t += dt;
            }
            vfx.angusBurstVFX = vfx.angusBurstVFX.filter(b => b.t < b.life);

            for (const field of vfx.angusTimeStopField) {
                field.t += dt;
            }
            vfx.angusTimeStopField = vfx.angusTimeStopField.filter(f => f.t < f.life);

            for (const trail of vfx.angusTeleportTrail) {
                trail.t += dt;
            }
            vfx.angusTeleportTrail = vfx.angusTeleportTrail.filter(t => t.t < t.life);

            for(const p of vfx.eddieWeAreParticles){
                p.t+=dt;
                const f = 1 - p.t/p.life; const a = f*0.8;
                p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9;

            }
            vfx.eddieWeAreParticles = vfx.eddieWeAreParticles.filter(p=> p.t < p.life);

            for(const p of vfx.zeusLightningParticles){
                const f = 1 - p.t/p.life; const a = f*0.9;
                const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*4);
                g.addColorStop(0,`${p.color}${a})`);
                g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
            }

            for(const p of vfx.zeusLightningChargeEffect){
                const f = 1 - p.t/p.life; const a = f*0.7;
                ctx.fillStyle = `${p.color}${a})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
            }


            for(const p of vfx.zeusHeavenlyShieldWaves){
                const f = 1 - p.t/p.life; const a = f*0.7;
                const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3);
                g.addColorStop(0,`${p.color}${a})`);
                g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
            }




            for(const line of vfx.zeusOlympusFuryPullLines){
                const progress = line.t / line.life;
                const opacity = (1 - progress) * 0.8;
                const currentX = lerp(line.startX, line.endX, progress);
                const currentY = lerp(line.startY, line.endY, progress);
                const length = lerp(0, Math.hypot(line.endX - line.startX, line.endY - line.startY), progress);
                const angle = Math.atan2(line.endY - line.startY, line.endX - line.startX);

                ctx.save();
                ctx.translate(currentX, currentY);
                ctx.rotate(angle);
                ctx.strokeStyle = `${line.color}${opacity})`;
                ctx.lineWidth = line.thickness * (1 - progress * 0.5);
                ctx.beginPath();
                ctx.moveTo(-length/2, 0);
                ctx.lineTo(length/2, 0);
                ctx.stroke();
                ctx.restore();
            }

            for(const p of vfx.ignisFireBreathParticles){
                const f = 1 - p.t/p.life; const a = f*0.8;
                const flickerIntensity = Math.sin(p.t * 0.05) * 0.3 + 0.7;
                
                const fireGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3);
                const rootStyle = getComputedStyle(document.documentElement);
                const fireStartColor = rootStyle.getPropertyValue('--ignis-fire-breath-start').trim();
                const fireEndColor = rootStyle.getPropertyValue('--ignis-fire-breath-end').trim();
                fireGrad.addColorStop(0, getRGBA(fireStartColor, a * flickerIntensity));
                fireGrad.addColorStop(0.5, getRGBA(fireEndColor, a * flickerIntensity * 0.7));
                fireGrad.addColorStop(1, getRGBA(fireEndColor, 0));
                ctx.fillStyle = fireGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = getRGBA(fireStartColor, a * flickerIntensity);
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const l of vfx.ignisFireBreathLines){
                const f = 1 - l.t/l.life; const a = f*0.9;
                const flickerIntensity = Math.sin(l.t * 0.1) * 0.4 + 0.6;
                
                const rootStyle = getComputedStyle(document.documentElement);
                const fireStartColor = rootStyle.getPropertyValue('--ignis-fire-breath-start').trim();
                const fireEndColor = rootStyle.getPropertyValue('--ignis-fire-breath-end').trim();
                
                const lineGrad = ctx.createLinearGradient(l.startX, l.startY, l.endX, l.endY);
                lineGrad.addColorStop(0, getRGBA(fireStartColor, a * flickerIntensity));
                lineGrad.addColorStop(0.7, getRGBA(fireEndColor, a * flickerIntensity * 0.8));
                lineGrad.addColorStop(1, getRGBA(fireEndColor, a * flickerIntensity * 0.3));
                
                ctx.strokeStyle = lineGrad;
                ctx.lineWidth = l.thickness * f;
                ctx.lineCap = 'round';
                ctx.shadowColor = fireStartColor;
                ctx.shadowBlur = l.thickness * 2;
                
                ctx.beginPath();
                ctx.moveTo(l.startX, l.startY);
                ctx.lineTo(l.endX, l.endY);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
            }

            for(const trail of vfx.ignisBlazeDashTrail){
                const progress = 1 - ((trail.end - performance.now()) / 800);
                if (progress < 0 || progress > 1) continue;
                
                const opacity = (1 - progress) * 0.8;
                const trailLength = 60 * (1 - progress * 0.5);
                
                ctx.save();
                ctx.translate(trail.x, trail.y);
                
                for(let layer = 0; layer < 3; layer++){
                    const layerOpacity = opacity * (0.8 - layer * 0.2);
                    const layerWidth = (8 - layer * 2) * (1 - progress * 0.3);
                    
                    const grd = ctx.createLinearGradient(-trailLength, 0, 0, 0);
                    grd.addColorStop(0, getRGBA(trail.colorEnd, 0));
                    grd.addColorStop(0.3, getRGBA(trail.colorStart, layerOpacity * 0.6));
                    grd.addColorStop(0.8, getRGBA(trail.colorStart, layerOpacity));
                    grd.addColorStop(1, getRGBA(trail.colorEnd, layerOpacity * 0.8));
                    
                    ctx.fillStyle = grd;
                    ctx.fillRect(-trailLength, -layerWidth/2, trailLength, layerWidth);
                }
                ctx.restore();
            }

            for(const p of vfx.ignisBlazeDashParticles){
                const f = 1 - p.t/p.life; const a = f*0.7;
                const flickerIntensity = Math.sin(p.t * 0.08) * 0.3 + 0.7;
                
                const rootStyle = getComputedStyle(document.documentElement);
                const fireStartColor = rootStyle.getPropertyValue('--ignis-fire-breath-start').trim();
                const fireEndColor = rootStyle.getPropertyValue('--ignis-fire-breath-end').trim();
                
                const particleGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2.5);
                particleGrad.addColorStop(0, getRGBA(fireStartColor, a * flickerIntensity));
                particleGrad.addColorStop(0.6, getRGBA(fireEndColor, a * flickerIntensity * 0.6));
                particleGrad.addColorStop(1, getRGBA(fireEndColor, 0));
                ctx.fillStyle = particleGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = getRGBA(fireStartColor, a * flickerIntensity);
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const f of vfx.ignisBlazeDashFlames){
                const fade = 1 - f.t/f.life; const a = fade*0.8;
                const flameFlicker = Math.sin(f.t * 0.1) * 0.4 + 0.6;
                
                const rootStyle = getComputedStyle(document.documentElement);
                const fireStartColor = rootStyle.getPropertyValue('--ignis-fire-breath-start').trim();
                const fireEndColor = rootStyle.getPropertyValue('--ignis-fire-breath-end').trim();
                
                ctx.save();
                ctx.translate(f.x, f.y);
                
                const flameGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, f.size * 3);
                flameGrad.addColorStop(0, getRGBA(fireStartColor, a * flameFlicker));
                flameGrad.addColorStop(0.4, getRGBA(fireEndColor, a * flameFlicker * 0.8));
                flameGrad.addColorStop(1, getRGBA(fireEndColor, a * 0.2));
                ctx.fillStyle = flameGrad;
                
                ctx.beginPath();
                ctx.ellipse(0, 0, f.size * 3, f.size * 1.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }

            for(const a of vfx.ignisPhoenixBurstChargeAura){
                const fade = 1 - a.t/a.life; const alpha = fade*0.8;
                const chargeFlicker = Math.sin(a.t * 0.12) * 0.5 + 0.5;
                const intensity = a.intensity || 0.5;
                
                const rootStyle = getComputedStyle(document.documentElement);
                const fireStartColor = rootStyle.getPropertyValue('--ignis-fire-breath-start').trim();
                const phoenixCore = rootStyle.getPropertyValue('--ignis-phoenix-burst-core').trim() || fireStartColor;
                
                const chargeGrad = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, a.size * (2 + intensity));
                chargeGrad.addColorStop(0, getRGBA(phoenixCore, alpha * chargeFlicker * intensity));
                chargeGrad.addColorStop(0.5, getRGBA(fireStartColor, alpha * chargeFlicker * intensity * 0.7));
                chargeGrad.addColorStop(1, getRGBA(fireStartColor, 0));
                ctx.fillStyle = chargeGrad;
                ctx.beginPath();
                ctx.arc(a.x, a.y, a.size * (2 + intensity), 0, Math.PI * 2);
                ctx.fill();
                
                if (intensity > 0.8) {
                    ctx.fillStyle = getRGBA('#ffffff', alpha * chargeFlicker * 0.6);
                    ctx.beginPath();
                    ctx.arc(a.x, a.y, a.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            for(const p of vfx.ignisPhoenixBurstParticles){
                const f = 1 - p.t/p.life; const a = f*0.9;
                const burstIntensity = Math.sin(p.t * 0.03) * 0.4 + 0.8;
                
                const burstGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
                const rootStyle = getComputedStyle(document.documentElement);
                const burstCore = rootStyle.getPropertyValue('--ignis-phoenix-burst-core').trim();
                const burstRing = rootStyle.getPropertyValue('--ignis-phoenix-burst-ring').trim();
                burstGrad.addColorStop(0, getRGBA(burstCore, a * burstIntensity));
                burstGrad.addColorStop(0.3, getRGBA(burstRing, a * burstIntensity * 0.8));
                burstGrad.addColorStop(0.7, getRGBA(burstRing, a * 0.5));
                burstGrad.addColorStop(1, getRGBA(burstRing, 0));
                ctx.fillStyle = burstGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = getRGBA('rgba(255, 255, 255, 1)', a * burstIntensity * 0.7);
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            vfx.robsanChargeAura = vfx.robsanChargeAura.filter(a=> (a.t+=dt) < a.life);

            vfx.eclipseAura = vfx.eclipseAura.filter(a=> (a.t+=dt) < a.life);

            for(const line of vfx.eclipseLines){
                const totalProgress = line.t / line.life;
                if (totalProgress > 1) continue;

                let lineStartX, lineStartY, lineEndX, lineEndY, opacity, lineWidth;
                const rootStyle = getComputedStyle(document.documentElement);
                const color1 = rootStyle.getPropertyValue('--eclipse-line-color').trim();
                const color2 = rootStyle.getPropertyValue('--eclipse-line-glow').trim();

                if (line.phase === 'extending') {
                    const extendProgress = line.t / line.extendDuration;
                    lineStartX = line.startX;
                    lineStartY = line.startY;
                    lineEndX = lerp(line.startX, line.endX, Math.min(extendProgress, 1));
                    lineEndY = lerp(line.startY, line.endY, Math.min(extendProgress, 1));
                    opacity = Math.min(extendProgress * 2, 1);
                    lineWidth = 6 * Math.min(extendProgress * 1.5, 1);
                } else {
                    const retractProgress = (line.t - line.extendDuration) / line.retractDuration;
                    lineStartX = lerp(line.endX, line.startX, Math.min(retractProgress, 1));
                    lineStartY = lerp(line.endY, line.startY, Math.min(retractProgress, 1));
                    lineEndX = line.startX;
                    lineEndY = line.startY;
                    opacity = (1 - retractProgress) * 0.9;
                    lineWidth = 6 * (1 - retractProgress * 0.5);
                }

                const dx = lineEndX - lineStartX;
                const dy = lineEndY - lineStartY;
                const dist = Math.hypot(dx, dy);

                if (dist < 1) continue;

                const angle = Math.atan2(dy, dx);

                ctx.save();
                ctx.translate(lineStartX, lineStartY);
                ctx.rotate(angle);

                const segments = Math.max(Math.floor(dist / 8), 1);
                ctx.beginPath();
                ctx.moveTo(0, 0);

                for (let i = 0; i <= segments; i++) {
                    const segmentProgress = i / segments;
                    const x = segmentProgress * dist;
                    const wiggleOffset = Math.sin(segmentProgress * Math.PI * line.wiggleFreq + performance.now() * 0.03) * line.wiggleAmp * opacity;
                    ctx.lineTo(x, wiggleOffset);
                }

                ctx.strokeStyle = getRGBA(color1, opacity);
                ctx.lineWidth = lineWidth;
                ctx.shadowBlur = 15 * opacity;
                ctx.shadowColor = getRGBA(color2, opacity * 0.8);
                ctx.stroke();

                ctx.restore();
            }

            vfx.xdrakeApexAura = vfx.xdrakeApexAura.filter(a=> (a.t+=dt) < a.life);

            vfx.gojoPurpleCombineVFX = vfx.gojoPurpleCombineVFX.filter(v=> (v.t+=dt) < v.life);


            for(const aura of vfx.eddieWeAreAura){
                const progress = aura.t / aura.life;
                const currentRadius = lerp(aura.radius * 0.5, aura.radius * 2, progress);
                const opacity = (1 - progress) * 0.7;

                const grd = ctx.createRadialGradient(aura.x, aura.y, aura.radius * 0.5, aura.x, aura.y, currentRadius);
                grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-we-are-aura').trim(), opacity * 0.8));
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(aura.x, aura.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            vfx.zeusHeavenlyShieldAura = vfx.zeusHeavenlyShieldAura.filter(a => (a.t+=dt) < a.life);

            vfx.zeusOlympusFuryAura = vfx.zeusOlympusFuryAura.filter(a => (a.t+=dt) < a.life);

            for(const line of vfx.eddieVenomTendrils){
                const progress = line.t / line.life;
                if (progress > 1) continue;

                const startX = line.startX;
                const startY = line.startY;
                const endX = line.endX;
                const endY = line.endY;

                const dist = Math.hypot(endX - startX, endY - startY);
                const angle = Math.atan2(endY - startY, endX - startX);

                ctx.save();
                ctx.translate(startX, startY);
                ctx.rotate(angle);

                const segments = Math.floor(dist / 10) || 1;
                ctx.beginPath();
                ctx.moveTo(0, 0);

                for (let i = 0; i <= segments; i++) {
                    const segmentProgress = i / segments;
                    const x = segmentProgress * dist;
                    const wiggleOffset = Math.sin(segmentProgress * Math.PI * line.wiggleFreq + performance.now() * 0.02) * line.wiggleAmp * (1 - progress);
                    ctx.lineTo(x, wiggleOffset);
                }

                ctx.strokeStyle = getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-tendril-start').trim(), 0.9 * (1 - progress));
                ctx.lineWidth = 6 * (1 - progress);
                ctx.shadowBlur = 20 * (1 - progress);
                ctx.shadowColor = getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-glow').trim(), 0.8 * (1 - progress));
                ctx.stroke();

                ctx.restore();
            }
            for(const puddle of vfx.blackPuddles){
                const f = 1 - puddle.t/puddle.life;
                const a = f * 0.6;
                const r = puddle.r * (1 + (puddle.t / puddle.life) * 0.5);

                ctx.fillStyle = `${puddle.color}${a})`;
                ctx.beginPath();
                ctx.arc(puddle.x, puddle.y, r, 0, Math.PI * 2);
                ctx.fill();
            }


            for(const rupture of vfx.robsanGroundRupture){
                const progress = rupture.t / rupture.life;
                const opacity = (1 - progress) * 0.8;
                const length = rupture.length * (1 + progress);
                const width = rupture.width * (1 - progress * 0.5);

                ctx.save();
                ctx.translate(rupture.x, rupture.y);
                ctx.rotate(rupture.dir);
                ctx.strokeStyle = `${rupture.color}${opacity})`;
                ctx.lineWidth = width;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(-length / 2, 0);
                ctx.lineTo(length / 2, 0);
                ctx.stroke();
                ctx.restore();
            }

            for(const wisp of vfx.robsanEclipseWisps){
                const f = 1 - wisp.t/wisp.life; const a = f*0.6;
                ctx.fillStyle = `${wisp.color}${a})`;
                ctx.beginPath(); ctx.arc(wisp.x, wisp.y, wisp.r, 0, Math.PI*2); ctx.fill();
            }

            for(const puff of vfx.robsanVoidPuffs){
                const progress = puff.t / puff.life;
                const opacity = (1 - progress) * 0.7;
                const radius = puff.r * (1 + progress);

                ctx.fillStyle = `${puff.color}${opacity})`;
                ctx.beginPath();
                ctx.arc(puff.x, puff.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const crack of vfx.xdrakeSupernovaGroundCrack){
                const progress = crack.t / crack.life;
                const opacity = (1 - progress) * 0.5;
                const size = crack.size * (1 + progress * 0.5);

                ctx.fillStyle = `${crack.color}${opacity})`;
                ctx.beginPath();
                ctx.arc(crack.x, crack.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const leaf of vfx.xdrakeFootworkLeaves){
                const f = 1 - leaf.t/leaf.life; const a = f*0.8;
                ctx.fillStyle = `${leaf.color}${a})`;
                ctx.beginPath(); ctx.ellipse(leaf.x, leaf.y, leaf.r * 1.5, leaf.r * 0.8, leaf.vx > 0 ? 0.3 : -0.3, 0, Math.PI*2); ctx.fill();
            }

            for(const burst of vfx.xdrakeAncientApexGroundBurst){
                const f = 1 - burst.t/burst.life; 
                const a = f * 0.9;
                const earthPulse = Math.sin(burst.t * 0.05) * 0.4 + 0.6;
                const currentRadius = burst.r * earthPulse;
                
                ctx.save();
                
                ctx.shadowBlur = 25;
                ctx.shadowColor = 'rgba(139, 69, 19, 0.8)';
                const outerGrad = ctx.createRadialGradient(burst.x, burst.y, 0, burst.x, burst.y, currentRadius * 2);
                outerGrad.addColorStop(0, `rgba(160, 82, 45, ${a * 0.8})`);
                outerGrad.addColorStop(0.5, `${burst.color}${a * 0.6})`);
                outerGrad.addColorStop(1, 'rgba(139, 69, 19, 0)');
                ctx.fillStyle = outerGrad;
                ctx.beginPath();
                ctx.arc(burst.x, burst.y, currentRadius * 1.8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 15;
                const coreGrad = ctx.createRadialGradient(burst.x, burst.y, 0, burst.x, burst.y, currentRadius);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.6})`);
                coreGrad.addColorStop(0.4, `${burst.color}${a})`);
                coreGrad.addColorStop(1, `rgba(101, 67, 33, 0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(burst.x, burst.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI * 2 * i / 4) + burst.t * 0.01;
                    const debrisRadius = currentRadius * 1.3;
                    const debrisX = burst.x + Math.cos(angle) * debrisRadius;
                    const debrisY = burst.y + Math.sin(angle) * debrisRadius;
                    const debrisSize = 2 * f;
                    
                    ctx.fillStyle = `rgba(139, 69, 19, ${a * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(debrisX, debrisY, debrisSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            for(const exp of vfx.gojoRedExplosion){
                const progress = exp.t / exp.life;
                const opacity = (1 - progress) * 0.9;
                const radius = exp.radius * (1 + progress * 2);
                const pulseIntensity = 1 + Math.sin(exp.t * 0.1) * 0.3;

                ctx.save();
                
                ctx.shadowBlur = 35;
                ctx.shadowColor = 'rgba(229, 62, 62, 0.9)';
                const outerGrad = ctx.createRadialGradient(exp.x, exp.y, 0, exp.x, exp.y, radius * 2 * pulseIntensity);
                outerGrad.addColorStop(0, `rgba(255, 100, 100, ${opacity * 0.4})`);
                outerGrad.addColorStop(0.3, `${exp.color}${opacity * 0.7})`);
                outerGrad.addColorStop(0.7, `rgba(139, 0, 0, ${opacity * 0.4})`);
                outerGrad.addColorStop(1, 'rgba(139, 0, 0, 0)');
                ctx.fillStyle = outerGrad;
                ctx.beginPath();
                ctx.arc(exp.x, exp.y, radius * 1.8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 25;
                const coreGrad = ctx.createRadialGradient(exp.x, exp.y, 0, exp.x, exp.y, radius);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.8})`);
                coreGrad.addColorStop(0.4, `${exp.color}${opacity})`);
                coreGrad.addColorStop(1, `${exp.color.split(',')[0]},${exp.color.split(',')[1]},${exp.color.split(',')[2]},0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(exp.x, exp.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                ctx.lineWidth = 3 * (1 - progress);
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i / 8) + exp.t * 0.02;
                    const boltLength = radius * (1.2 + Math.sin(exp.t * 0.07 + i) * 0.4);
                    const midX = exp.x + Math.cos(angle) * boltLength * 0.6;
                    const midY = exp.y + Math.sin(angle) * boltLength * 0.6;
                    const endX = exp.x + Math.cos(angle) * boltLength;
                    const endY = exp.y + Math.sin(angle) * boltLength;
                    
                    ctx.beginPath();
                    ctx.moveTo(exp.x, exp.y);
                    ctx.quadraticCurveTo(
                        midX + (Math.random() - 0.5) * 20, 
                        midY + (Math.random() - 0.5) * 20, 
                        endX, endY
                    );
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            for(const p of vfx.gojoLapseBluePullEffect){
                const f = 1 - p.t/p.life; const a = f*0.7;
                ctx.fillStyle = `${p.color}${a})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
            }

            for(const arc of vfx.gojoPurpleArcs){
                const progress = arc.t / arc.life;
                const opacity = (1 - progress) * 0.9;
                const currentRadius = arc.radius * (1 + progress * 2);

                ctx.strokeStyle = `${arc.color}${opacity})`;
                ctx.lineWidth = 3 * (1 - progress * 0.5);
                ctx.beginPath();
                ctx.arc(arc.x, arc.y, currentRadius, arc.initialAngle, arc.initialAngle + Math.PI / 4 * (1 - progress));
                ctx.stroke();
            }

            for(const ripple of vfx.eddieWeAreRipples){
                const progress = ripple.t / ripple.life;
                const opacity = (1 - progress) * 0.5;
                const radius = lerp(ripple.initialRadius, ripple.maxRadius, progress);

                ctx.strokeStyle = `${ripple.color}${opacity})`;
                ctx.lineWidth = 2 * (1 - progress);
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);
                ctx.stroke();
            }

            for(const p of vfx.eddieVenomBallSwirl){
                const f = 1 - p.t/p.life; const a = f*0.7;
                
                const outerGlow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 3);
                outerGlow.addColorStop(0, `${p.color}${a * 0.4})`);
                outerGlow.addColorStop(0.5, `${p.color}${a * 0.2})`);
                outerGlow.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 3, 0, Math.PI * 2);
                ctx.fill();
                
                const pulse = Math.sin(p.t * 0.02) * 0.3 + 0.7;
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * pulse);
                coreGrad.addColorStop(0, `rgba(20, 20, 20, ${a})`);
                coreGrad.addColorStop(0.7, `${p.color}${a * 0.9})`);
                coreGrad.addColorStop(1, `rgba(0, 0, 0, ${a * 0.3})`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                if(Math.random() < 0.3) {
                    ctx.save();
                    ctx.strokeStyle = `${p.color}${a * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `${p.color}${a * 0.8})`;
                    for(let i = 0; i < 3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const length = p.r * (1.5 + Math.random() * 2);
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x + Math.cos(angle) * length, p.y + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            for(const flicker of vfx.eddieTeleportFlicker){
                const progress = flicker.t / flicker.life;
                const opacity = Math.sin(progress * Math.PI) * 0.8;
                const radius = flicker.radius * (1 + progress * 0.2);

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                const riftGrad = ctx.createRadialGradient(flicker.x, flicker.y, 0, flicker.x, flicker.y, radius * 2);
                riftGrad.addColorStop(0, `rgba(139, 69, 19, ${opacity * 0.3})`);
                riftGrad.addColorStop(0.3, `rgba(20, 20, 20, ${opacity * 0.5})`);
                riftGrad.addColorStop(0.7, `${flicker.color}${opacity * 0.4})`);
                riftGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = riftGrad;
                ctx.beginPath();
                ctx.arc(flicker.x, flicker.y, radius * 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                for(let layer = 0; layer < 3; layer++) {
                    const layerOpacity = opacity * (0.8 - layer * 0.2);
                    const layerRadius = radius * (1 - layer * 0.2);
                    const flicker_intensity = Math.sin((progress + layer * 0.3) * Math.PI * 4) * 0.5 + 0.5;
                    
                    const grd = ctx.createRadialGradient(flicker.x, flicker.y, 0, flicker.x, flicker.y, layerRadius);
                    grd.addColorStop(0, `${flicker.color}${layerOpacity * flicker_intensity})`);
                    grd.addColorStop(0.5, `rgba(20, 20, 20, ${layerOpacity * 0.8 * flicker_intensity})`);
                    grd.addColorStop(1, `${flicker.color.split(',')[0]},${flicker.color.split(',')[1]},${flicker.color.split(',')[2]},0)`);
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(flicker.x, flicker.y, layerRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if(Math.random() < 0.4) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
                    ctx.lineWidth = 1 + Math.random() * 2;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = `${flicker.color}${opacity})`;
                    for(let i = 0; i < 4; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const length = radius * (0.8 + Math.random() * 0.4);
                        ctx.beginPath();
                        ctx.moveTo(flicker.x, flicker.y);
                        const endX = flicker.x + Math.cos(angle) * length;
                        const endY = flicker.y + Math.sin(angle) * length;
                        ctx.lineTo(endX + (Math.random() - 0.5) * 10, endY + (Math.random() - 0.5) * 10);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }


            for(const line of vfx.hudsonSpeedLines) {
                const progress = line.t / line.life;
                const opacity = (1 - progress) * 0.9;
                const currentLength = line.length * (1 + progress * 2);

                ctx.save();
                ctx.translate(line.x, line.y);
                ctx.rotate(line.dir);
                
                ctx.shadowBlur = 20;
                ctx.shadowColor = `${line.color}1)`;
                ctx.strokeStyle = `${line.color}${opacity})`;
                ctx.lineWidth = 4 * (1 - progress * 0.3);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(currentLength, 0);
                ctx.stroke();
                
                ctx.shadowBlur = 8;
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                ctx.lineWidth = 2 * (1 - progress * 0.3);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(currentLength, 0);
                ctx.stroke();
                
                for (let i = 0; i < 3; i++) {
                    const sparklePos = (currentLength * (0.3 + i * 0.2));
                    const sparkleSize = (2 + Math.sin(line.t * 0.01 + i) * 1) * (1 - progress);
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(sparklePos, Math.sin(line.t * 0.02 + i) * 2, sparkleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            for(const wave of vfx.hudsonEnergyWaves) {
                const progress = wave.t / wave.life;
                const opacity = (1 - progress) * 0.8;
                const radius = lerp(wave.initialRadius, wave.maxRadius, progress);
                const pulseEffect = 1 + Math.sin(wave.t * 0.05) * 0.2;

                ctx.save();
                
                ctx.shadowBlur = 25;
                ctx.shadowColor = `${wave.color}0.8)`;
                ctx.strokeStyle = `${wave.color}${opacity * 0.6})`;
                ctx.lineWidth = 8 * (1 - progress * 0.5) * pulseEffect;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius * 1.2, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.shadowBlur = 15;
                ctx.strokeStyle = `${wave.color}${opacity})`;
                ctx.lineWidth = 5 * (1 - progress * 0.3);
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.shadowBlur = 8;
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();
                
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 * i / 6) + wave.t * 0.01;
                    const crackleRadius = radius + Math.sin(wave.t * 0.03 + i) * 10;
                    const crackleX = wave.x + Math.cos(angle) * crackleRadius;
                    const crackleY = wave.y + Math.sin(angle) * crackleRadius;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(crackleX, crackleY, 2 * (1 - progress), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            for(const trail of vfx.hudsonEmperorDribbleTrail) {
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * 0.8;
                const size = trail.width * (1 - progress * 0.3);

                ctx.fillStyle = `${trail.color.replace(')', `, ${opacity})`)}`;
                ctx.beginPath();
                ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const particle of vfx.hudsonEmperorDribbleParticles) {
                const progress = particle.t / particle.life;
                const opacity = (1 - progress) * 0.9;
                const size = particle.r * (1 + progress * 0.2);

                ctx.fillStyle = `${particle.color.replace('0.8', opacity.toString())}`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const aura of vfx.hudsonEmperorDribbleAura) {
                const progress = aura.t / aura.life;
                const opacity = (1 - progress) * 0.4;
                const radius = aura.radius * (1 + progress * 0.5);

                const grd = ctx.createRadialGradient(aura.x, aura.y, 0, aura.x, aura.y, radius);
                grd.addColorStop(0, `rgba(200, 50, 150, ${opacity})`);
                grd.addColorStop(1, `rgba(150, 100, 200, 0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(aura.x, aura.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const clone of vfx.robsanShadowClones) {
                const progress = clone.t / clone.life;
                const opacity = (1 - progress) * clone.opacity;

                ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                ctx.beginPath();
                ctx.arc(clone.x, clone.y, clone.r, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const rift of vfx.robsanVoidRifts) {
                const progress = rift.t / rift.life;
                const opacity = (1 - progress) * 0.8;
                const width = lerp(rift.width, rift.maxWidth, progress);

                ctx.fillStyle = `${rift.color}${opacity})`;
                ctx.fillRect(rift.x - width/2, rift.y - rift.height/2, width, rift.height);
            }

            for(const spirit of vfx.xdrakeNatureSpirits) {
                const f = 1 - spirit.t / spirit.life;
                const a = f * 0.8;
                ctx.fillStyle = `${spirit.color}${a})`;
                ctx.beginPath();
                ctx.arc(spirit.x, spirit.y, spirit.r, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const terra of vfx.xdrakeTerraforms) {
                const progress = terra.t / terra.life;
                const opacity = (1 - progress) * 0.7;
                const height = terra.height * (1 + progress * 0.5);

                ctx.fillStyle = `${terra.color}${opacity})`;
                ctx.fillRect(terra.x - 5, terra.y - height, 10, height);
            }

            for(const barrier of vfx.gojoInfinityBarriers) {
                const progress = barrier.t / barrier.life;
                const opacity = (1 - progress) * 0.6;

                ctx.save();
                ctx.translate(barrier.x, barrier.y);
                ctx.rotate(barrier.angle + progress * Math.PI);
                ctx.strokeStyle = `${barrier.color}${opacity})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-barrier.length/2, 0);
                ctx.lineTo(barrier.length/2, 0);
                ctx.stroke();
                ctx.restore();
            }

            for(const domain of vfx.gojoDomainExpansions) {
                const progress = domain.t / domain.life;
                const opacity = (1 - progress) * domain.intensity * 0.3;
                const radius = lerp(domain.initialRadius, domain.maxRadius, progress);

                const grd = ctx.createRadialGradient(domain.x, domain.y, 0, domain.x, domain.y, radius);
                grd.addColorStop(0, `${domain.color}${opacity})`);
                grd.addColorStop(1, `${domain.color.split(',')[0]},${domain.color.split(',')[1]},${domain.color.split(',')[2]},0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(domain.x, domain.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            for(const spike of vfx.eddieSymbioteSpikes) {
                const progress = spike.t / spike.life;
                const opacity = (1 - progress) * 0.8;
                const length = spike.length * (1 + progress);

                ctx.save();
                ctx.translate(spike.x, spike.y);
                ctx.rotate(spike.dir);
                ctx.strokeStyle = `${spike.color}${opacity})`;
                ctx.lineWidth = 4 * (1 - progress * 0.5);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(length, 0);
                ctx.stroke();
                ctx.restore();
            }

            for(const drop of vfx.eddieVenomDrops) {
                const f = 1 - drop.t / drop.life;
                const a = f * 0.8;
                
                const splashRadius = drop.r * (2 + Math.sin(drop.t * 0.03) * 0.5);
                const splashGrad = ctx.createRadialGradient(drop.x, drop.y, 0, drop.x, drop.y, splashRadius);
                splashGrad.addColorStop(0, `rgba(0, 0, 0, ${a * 0.3})`);
                splashGrad.addColorStop(0.4, `${drop.color}${a * 0.5})`);
                splashGrad.addColorStop(0.8, `rgba(20, 20, 20, ${a * 0.2})`);
                splashGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = splashGrad;
                ctx.beginPath();
                ctx.arc(drop.x, drop.y, splashRadius, 0, Math.PI * 2);
                ctx.fill();
                
                const coreGrad = ctx.createRadialGradient(drop.x, drop.y - drop.r * 0.3, 0, drop.x, drop.y, drop.r);
                coreGrad.addColorStop(0, `rgba(40, 40, 40, ${a})`);
                coreGrad.addColorStop(0.3, `${drop.color}${a})`);
                coreGrad.addColorStop(0.8, `rgba(20, 20, 20, ${a * 0.9})`);
                coreGrad.addColorStop(1, `rgba(0, 0, 0, ${a * 0.7})`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(drop.x, drop.y, drop.r, 0, Math.PI * 2);
                ctx.fill();
                
                const shineGrad = ctx.createRadialGradient(drop.x - drop.r * 0.3, drop.y - drop.r * 0.3, 0, drop.x, drop.y, drop.r * 0.6);
                shineGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.4})`);
                shineGrad.addColorStop(0.5, `rgba(128, 128, 128, ${a * 0.2})`);
                shineGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = shineGrad;
                ctx.beginPath();
                ctx.arc(drop.x - drop.r * 0.2, drop.y - drop.r * 0.2, drop.r * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                if(drop.vy > 0) {
                    ctx.save();
                    ctx.fillStyle = `${drop.color}${a * 0.6})`;
                    ctx.beginPath();
                    ctx.ellipse(drop.x, drop.y + drop.r * 0.8, drop.r * 0.3, drop.r * 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            for(const cloud of vfx.zeusThunderClouds) {
                const progress = cloud.t / cloud.life;
                const opacity = (1 - progress) * cloud.opacity;
                const storm_pulse = Math.sin(cloud.t * 0.015) * 0.4 + 0.6;
                
                const stormGrad = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.r * 2.5);
                stormGrad.addColorStop(0, `rgba(70, 70, 90, ${opacity * 0.3})`);
                stormGrad.addColorStop(0.4, `${cloud.color}${opacity * 0.6})`);
                stormGrad.addColorStop(0.7, `rgba(30, 30, 50, ${opacity * 0.4})`);
                stormGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = stormGrad;
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.r * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                const cloudGrad = ctx.createRadialGradient(cloud.x - cloud.r * 0.3, cloud.y - cloud.r * 0.3, 0, cloud.x, cloud.y, cloud.r * storm_pulse);
                cloudGrad.addColorStop(0, `rgba(200, 200, 255, ${opacity * 0.8})`);
                cloudGrad.addColorStop(0.3, `${cloud.color}${opacity})`);
                cloudGrad.addColorStop(0.7, `rgba(40, 40, 60, ${opacity * 0.9})`);
                cloudGrad.addColorStop(1, `rgba(20, 20, 30, ${opacity * 0.7})`);
                ctx.fillStyle = cloudGrad;
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.r * storm_pulse, 0, Math.PI * 2);
                ctx.fill();
                
                if(Math.random() < 0.2) {
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `rgba(255, 255, 255, ${opacity})`;
                    for(let i = 0; i < 3; i++) {
                        const flashX = cloud.x + (Math.random() - 0.5) * cloud.r * 1.5;
                        const flashY = cloud.y + (Math.random() - 0.5) * cloud.r * 1.5;
                        ctx.beginPath();
                        ctx.arc(flashX, flashY, 2 + Math.random() * 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
            }

            for(const bolt of vfx.zeusLightningBolts) {
                const progress = bolt.t / bolt.life;
                const opacity = (1 - progress) * 0.9;
                const electrical_pulse = Math.sin(bolt.t * 0.1) * 0.5 + 0.5;
                
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(135, 206, 250, ${opacity * 0.4})`;
                ctx.lineWidth = bolt.thickness * 3 * electrical_pulse;
                ctx.shadowBlur = 25;
                ctx.shadowColor = `rgba(255, 255, 255, ${opacity * 0.6})`;
                
                for(const segment of bolt.segments) {
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y);
                    ctx.lineTo(segment.x2, segment.y2);
                    ctx.stroke();
                }
                ctx.restore();
                
                ctx.save();
                ctx.strokeStyle = `${bolt.color}${opacity})`;
                ctx.lineWidth = bolt.thickness * (1 - progress * 0.5) * electrical_pulse;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(255, 255, 255, ${opacity})`;

                for(const segment of bolt.segments) {
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y);
                    ctx.lineTo(segment.x2, segment.y2);
                    ctx.stroke();
                    
                    if(Math.random() < 0.3) {
                        const midX = (segment.x + segment.x2) / 2;
                        const midY = (segment.y + segment.y2) / 2;
                        const branchAngle = Math.random() * Math.PI * 2;
                        const branchLength = bolt.thickness * (2 + Math.random() * 3);
                        
                        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                        ctx.lineWidth = bolt.thickness * 0.3;
                        ctx.beginPath();
                        ctx.moveTo(midX, midY);
                        ctx.lineTo(midX + Math.cos(branchAngle) * branchLength, 
                                  midY + Math.sin(branchAngle) * branchLength);
                        ctx.stroke();
                    }
                }
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                ctx.lineWidth = bolt.thickness * 0.3;
                ctx.shadowBlur = 8;
                ctx.shadowColor = `rgba(200, 200, 255, ${opacity})`;
                
                for(const segment of bolt.segments) {
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y);
                    ctx.lineTo(segment.x2, segment.y2);
                    ctx.stroke();
                }
                ctx.restore();
            }


for (const aura of vfx.sajaJinDemonicAura) {
const progress = aura.t / aura.life;
const opacity = (1 - progress) * 0.9;
const pulse = Math.sin(progress * Math.PI * 12) * 0.3;
const currentRadius = aura.radius * (1 + pulse);

const x = aura.followPlayer ? player.x : aura.x;
const y = aura.followPlayer ? player.y : aura.y;

const grd = ctx.createRadialGradient(x, y, 0, x, y, currentRadius);
grd.addColorStop(0, `rgba(255, 69, 0, ${opacity * 0.9})`);
grd.addColorStop(0.4, `rgba(139, 0, 139, ${opacity * 0.6})`);
grd.addColorStop(0.8, `rgba(75, 0, 130, ${opacity * 0.3})`);
grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
ctx.globalCompositeOperation = 'lighter';
ctx.fillStyle = grd;
ctx.beginPath();
ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
ctx.fill();

for (let i = 0; i < 3; i++) {
const angle = Math.random() * Math.PI * 2;
const dist = currentRadius * Math.random();
const px = x + Math.cos(angle) * dist;
const py = y + Math.sin(angle) * dist;
ctx.fillStyle = `rgba(255, 215, 0, ${opacity * 0.5})`;
ctx.beginPath();
ctx.arc(px, py, 2 + Math.random() * 2, 0, Math.PI * 2);
ctx.fill();
}
}

for (const trail of vfx.sajaJinSoulTrail) {
if (performance.now() <= trail.end) {
const progress = (now - (trail.end - 3000)) / 3000;
const opacity = Math.max(0, 1 - progress);

ctx.save();
ctx.globalCompositeOperation = 'screen';
ctx.strokeStyle = `rgba(${100 + Math.sin(progress * 5) * 50}, 149, 237, ${opacity * 0.9})`;
ctx.lineWidth = trail.w * (1.2 - progress * 0.3);
ctx.shadowBlur = 25;
ctx.shadowColor = `rgba(173, 216, 230, ${opacity * 0.8})`;

ctx.beginPath();
const trailLength = 120;
for (let i = 0; i < trailLength; i++) {
const t = i / trailLength;
const waveOffset = Math.sin(progress * Math.PI * 6 + t * Math.PI * 3) * 10;
const x = ball.x - ball.vx * t * 0.7 + waveOffset;
const y = ball.y - ball.vy * t * 0.7 + Math.cos(t * Math.PI * 4) * 6;
if (i === 0) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
}
ctx.stroke();
ctx.restore();
}
}

for (const particle of vfx.sajaJinSoulParticles) {
const progress = particle.t / particle.life;
const opacity = (1 - progress) * 0.8;

particle.x += particle.vx;
particle.y += particle.vy;
particle.vx *= 0.96;
particle.vy *= 0.96;

const flicker = Math.sin(progress * Math.PI * 10) * 0.2 + 1;
const grd = ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.size * flicker);
grd.addColorStop(0, `rgba(173, 216, 230, ${opacity})`);
grd.addColorStop(0.5, `rgba(138, 43, 226, ${opacity * 0.7})`);
grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
ctx.globalCompositeOperation = 'lighter';
ctx.fillStyle = grd;
ctx.beginPath();
ctx.arc(particle.x, particle.y, particle.size * flicker, 0, Math.PI * 2);
ctx.fill();
}

for (const glow of vfx.sajaJinHypnoticGlow) {
    const progress = glow.t / glow.life;
    const opacity = (1 - progress) * 0.8;
    
    if (!isFinite(glow.x) || !isFinite(glow.y) || !isFinite(glow.radius) || 
        !isFinite(progress) || !isFinite(opacity) || glow.radius <= 0) {
        continue;
    }
    
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    
    if (glow.type === 'pulse_ring') {
        const ringRadius = glow.radius * progress * 2;
        const ringOpacity = opacity * (1 - progress) * 0.6;
        
        if (!isFinite(ringRadius) || !isFinite(ringOpacity) || ringRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        for (let ring = 0; ring < 3; ring++) {
            const currentRadius = ringRadius + (ring * 15);
            const ringGrd = ctx.createRadialGradient(glow.x, glow.y, currentRadius * 0.7, glow.x, glow.y, currentRadius);
            ringGrd.addColorStop(0, 'rgba(0, 0, 0, 0)');
            ringGrd.addColorStop(0.8, `rgba(168, 85, 247, ${ringOpacity * (1 - ring * 0.3)})`);
            ringGrd.addColorStop(0.95, `rgba(255, 100, 255, ${ringOpacity * (1 - ring * 0.2)})`);
            ringGrd.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = ringGrd;
            ctx.beginPath();
            ctx.arc(glow.x, glow.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    } else if (glow.type === 'moving_aura') {
        const pulseRadius = glow.radius * (1 + Math.sin(progress * Math.PI * 12) * 0.4);
        
        if (!isFinite(pulseRadius) || pulseRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        for (let layer = 0; layer < 3; layer++) {
            const layerRadius = pulseRadius * (1 + layer * 0.3);
            const layerOpacity = opacity * (1 - layer * 0.25);
            
            if (!isFinite(layerRadius) || !isFinite(layerOpacity) || layerRadius <= 0) {
                continue;
            }
            
            const grd = ctx.createRadialGradient(glow.x, glow.y, 0, glow.x, glow.y, layerRadius);
            grd.addColorStop(0, `rgba(255, 120, 255, ${layerOpacity * 0.8})`);
            grd.addColorStop(0.4, `rgba(168, 85, 247, ${layerOpacity * 0.6})`);
            grd.addColorStop(0.7, `rgba(138, 43, 226, ${layerOpacity * 0.4})`);
            grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(glow.x, glow.y, layerRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    } else {
        const pulseRadius = glow.radius * (1 + Math.sin(progress * Math.PI * 16) * 0.5);
        
        if (!isFinite(pulseRadius) || pulseRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        const grd = ctx.createRadialGradient(glow.x, glow.y, 0, glow.x, glow.y, pulseRadius);
        grd.addColorStop(0, `rgba(255, 120, 255, ${opacity * 0.9})`);
        grd.addColorStop(0.3, `rgba(168, 85, 247, ${opacity * 0.7})`);
        grd.addColorStop(0.6, `rgba(138, 43, 226, ${opacity * 0.5})`);
        grd.addColorStop(0.8, `rgba(75, 0, 130, ${opacity * 0.3})`);
        grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(glow.x, glow.y, pulseRadius, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
}

for (const trail of vfx.sajaJinHypnoticSpinTrail) {
    const progress = trail.t / trail.life;
    const opacity = (1 - progress) * (trail.intensity || 0.9);
   
    if (!isFinite(trail.x) || !isFinite(trail.y) || !isFinite(progress) || !isFinite(opacity) ||
        !isFinite(trail.layer) || !isFinite(trail.angle)) {
        continue;
    }
   
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    
    if (trail.layer >= 0) {
        const baseRadius = 20 + (trail.layer * 5);
        const currentRadius = baseRadius * (1 - progress * 0.2);
        
        if (!isFinite(baseRadius) || !isFinite(currentRadius) || currentRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        const spinGlow = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, currentRadius);
        const hue = trail.layer * 30;
        spinGlow.addColorStop(0, `hsla(${280 + hue}, 100%, 70%, ${opacity})`);
        spinGlow.addColorStop(0.4, `hsla(${260 + hue}, 80%, 60%, ${opacity * 0.7})`);
        spinGlow.addColorStop(0.8, `hsla(${240 + hue}, 60%, 40%, ${opacity * 0.4})`);
        spinGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = spinGlow;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, currentRadius, 0, Math.PI * 2);
        ctx.fill();
        
        if (trail.layer > 0) {
            ctx.strokeStyle = `hsla(${270 + hue}, 100%, 70%, ${opacity * 0.5})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            const lineLength = currentRadius * 0.8;
            const angle = trail.angle + (progress * Math.PI * 4);
            ctx.moveTo(trail.x - Math.cos(angle) * lineLength, trail.y - Math.sin(angle) * lineLength);
            ctx.lineTo(trail.x + Math.cos(angle) * lineLength, trail.y + Math.sin(angle) * lineLength);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    } else if (trail.type === 'goal_spiral') {
        const spiralRadius = 15 * (1 - progress * 0.4);
        const spiralGlow = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, spiralRadius);
        spiralGlow.addColorStop(0, `rgba(255, 150, 255, ${opacity})`);
        spiralGlow.addColorStop(0.5, `rgba(200, 100, 255, ${opacity * 0.7})`);
        spiralGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = spiralGlow;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, spiralRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = `rgba(255, 120, 255, ${opacity * 0.6})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        const spiralAngle = trail.angle + (progress * Math.PI * 6);
        const spiralLength = spiralRadius * 1.5;
        ctx.moveTo(trail.x, trail.y);
        ctx.lineTo(
            trail.x + Math.cos(spiralAngle) * spiralLength,
            trail.y + Math.sin(spiralAngle) * spiralLength
        );
        ctx.stroke();
    } else {
        const mainRadius = 30 * (1 - progress * 0.3);
        const mainGlow = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, mainRadius);
        mainGlow.addColorStop(0, `rgba(255, 120, 255, ${opacity * 1.2})`);
        mainGlow.addColorStop(0.3, `rgba(200, 80, 255, ${opacity * 0.9})`);
        mainGlow.addColorStop(0.6, `rgba(150, 50, 200, ${opacity * 0.6})`);
        mainGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = mainGlow;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, mainRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = `rgba(255, 150, 255, ${opacity * 0.8})`;
        ctx.lineWidth = 4;
        const angle = trail.angle;
        const lineLength = mainRadius * 0.8;
        
        ctx.beginPath();
        ctx.moveTo(trail.x - Math.cos(angle) * lineLength, trail.y - Math.sin(angle) * lineLength);
        ctx.lineTo(trail.x + Math.cos(angle) * lineLength, trail.y + Math.sin(angle) * lineLength);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(trail.x - Math.cos(angle + Math.PI/2) * lineLength * 0.7, trail.y - Math.sin(angle + Math.PI/2) * lineLength * 0.7);
        ctx.lineTo(trail.x + Math.cos(angle + Math.PI/2) * lineLength * 0.7, trail.y + Math.sin(angle + Math.PI/2) * lineLength * 0.7);
        ctx.stroke();
    }
    
    ctx.restore();
}

for (const trail of vfx.sajaJinHypnoticTrail) {
    const progress = trail.t / trail.life;
    const opacity = (1 - progress) * 0.8;
    
    if (!isFinite(trail.x) || !isFinite(trail.y) || !isFinite(progress) || !isFinite(opacity)) {
        continue;
    }
    
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    
    if (trail.type === 'goal_spiral') {
        const trailRadius = 12 * (1 - progress * 0.3);
        
        if (!isFinite(trailRadius) || trailRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        const spiralGlow = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, trailRadius);
        spiralGlow.addColorStop(0, `rgba(255, 180, 255, ${opacity * 1.1})`);
        spiralGlow.addColorStop(0.5, `rgba(200, 120, 255, ${opacity * 0.8})`);
        spiralGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = spiralGlow;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, trailRadius, 0, Math.PI * 2);
        ctx.fill();
        
        if (trail.angle !== undefined && isFinite(trail.angle)) {
            ctx.strokeStyle = `rgba(255, 150, 255, ${opacity * 0.7})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            const lineLength = trailRadius * 1.8;
            
            if (isFinite(lineLength) && lineLength > 0) {
                const startAngle = trail.angle - 0.5;
                const endAngle = trail.angle + 0.5;
                
                ctx.arc(trail.x, trail.y, lineLength, startAngle, endAngle);
                ctx.stroke();
            }
        }
    }
    
    ctx.restore();
}

for (const caption of vfx.sajaJinHypnoticCaption) {
    const progress = caption.t / caption.life;
    const opacity = Math.sin(progress * Math.PI) * 0.9;
   
    ctx.save();
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
   
    ctx.shadowBlur = 15;
    ctx.shadowColor = 'rgba(255, 0, 255, 0.8)';
    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
    ctx.strokeStyle = `rgba(255, 0, 255, ${opacity * 0.8})`;
    ctx.lineWidth = 2;
   
    const scale = 1 + Math.sin(progress * Math.PI * 8) * 0.1;
    ctx.save();
    ctx.translate(caption.x, caption.y);
    ctx.scale(scale, scale);
    ctx.strokeText(caption.text, 0, 0);
    ctx.fillText(caption.text, 0, 0);
    ctx.restore();
   
    ctx.restore();
}

for (const burst of vfx.sajaJinHypnoticBurst) {
    const progress = burst.t / burst.life;
    const opacity = (1 - progress) * 0.9;
    const currentRadius = burst.radius * progress;
   
    if (!isFinite(burst.x) || !isFinite(burst.y) || !isFinite(burst.radius) || 
        !isFinite(progress) || !isFinite(opacity) || !isFinite(currentRadius) || 
        burst.radius <= 0 || currentRadius <= 0) {
        continue;
    }
   
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
   
    if (burst.type === 'main_burst') {
        const pulseEffect = 1 + Math.sin(progress * Math.PI * 8) * 0.2;
        const effectiveRadius = currentRadius * pulseEffect;
        
        if (!isFinite(pulseEffect) || !isFinite(effectiveRadius) || effectiveRadius <= 0) {
            ctx.restore();
            continue;
        }
        
        const outerGrad = ctx.createRadialGradient(burst.x, burst.y, effectiveRadius * 0.7, burst.x, burst.y, effectiveRadius);
        outerGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
        outerGrad.addColorStop(0.8, `rgba(255, 150, 255, ${opacity * 0.6})`);
        outerGrad.addColorStop(0.95, `rgba(255, 200, 255, ${opacity * 0.8})`);
        outerGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = outerGrad;
        ctx.beginPath();
        ctx.arc(burst.x, burst.y, effectiveRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const coreRadius = effectiveRadius * 0.4;
        const coreGrad = ctx.createRadialGradient(burst.x, burst.y, 0, burst.x, burst.y, coreRadius);
        coreGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
        coreGrad.addColorStop(0.3, `rgba(255, 180, 255, ${opacity * 0.9})`);
        coreGrad.addColorStop(0.6, `rgba(200, 100, 255, ${opacity * 0.7})`);
        coreGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = coreGrad;
        ctx.beginPath();
        ctx.arc(burst.x, burst.y, coreRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = `rgba(255, 200, 255, ${opacity * 0.8})`;
        ctx.lineWidth = 5;
        for (let spiral = 0; spiral < 3; spiral++) {
            ctx.beginPath();
            for (let i = 0; i <= 50; i++) {
                const angle = (i / 50) * Math.PI * 6 + (progress * Math.PI * 4) + (spiral * Math.PI * 0.67);
                const radius = (i / 50) * effectiveRadius * 0.8;
                const x = burst.x + Math.cos(angle) * radius;
                const y = burst.y + Math.sin(angle) * radius;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }
        
    } else if (burst.type === 'ring_burst') {
        const delayProgress = Math.max(0, (burst.t - (burst.delay || 0)) / burst.life);
        if (delayProgress > 0) {
            const ringOpacity = opacity * (1 - delayProgress) * 0.7;
            const ringRadius = burst.radius * delayProgress * 1.2;
            
            const ringGrad = ctx.createRadialGradient(burst.x, burst.y, ringRadius * 0.8, burst.x, burst.y, ringRadius);
            ringGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
            ringGrad.addColorStop(0.7, `rgba(168, 85, 247, ${ringOpacity})`);
            ringGrad.addColorStop(0.9, `rgba(255, 150, 255, ${ringOpacity * 1.2})`);
            ringGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = ringGrad;
            ctx.beginPath();
            ctx.arc(burst.x, burst.y, ringRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    } else {
        const burstGrad = ctx.createRadialGradient(burst.x, burst.y, 0, burst.x, burst.y, currentRadius);
        burstGrad.addColorStop(0, `rgba(255, 200, 255, ${opacity})`);
        burstGrad.addColorStop(0.3, `rgba(200, 100, 255, ${opacity * 0.8})`);
        burstGrad.addColorStop(0.6, `rgba(150, 50, 200, ${opacity * 0.5})`);
        burstGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = burstGrad;
        ctx.beginPath();
        ctx.arc(burst.x, burst.y, currentRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = `rgba(255, 150, 255, ${opacity * 0.8})`;
        ctx.lineWidth = 3;
        for (let i = 0; i < 16; i++) {
            const angle = (Math.PI * 2 * i / 16) + (progress * Math.PI * 6);
            const innerRadius = currentRadius * 0.1;
            const outerRadius = currentRadius * 0.95;
            
            ctx.beginPath();
            ctx.moveTo(
                burst.x + Math.cos(angle) * innerRadius,
                burst.y + Math.sin(angle) * innerRadius
            );
            
            const midAngle = angle + 0.3;
            const midRadius = currentRadius * 0.5;
            const midX = burst.x + Math.cos(midAngle) * midRadius;
            const midY = burst.y + Math.sin(midAngle) * midRadius;
            
            ctx.quadraticCurveTo(
                midX, midY,
                burst.x + Math.cos(angle + 0.2) * outerRadius,
                burst.y + Math.sin(angle + 0.2) * outerRadius
            );
            ctx.stroke();
        }
    }
   
    ctx.restore();
}

if (ball._sajaJinGhostTrail && ball._sajaJinGhostTrail.length > 1) {
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    for (let i = 0; i < ball._sajaJinGhostTrail.length - 1; i++) {
        const p = ball._sajaJinGhostTrail[i], n = ball._sajaJinGhostTrail[i+1];
        const age = (performance.now() - p.time);
        const a = clamp(1 - age / 2000, 0, 1) * 0.7;
        const w = lerp(15, 3, i / ball._sajaJinGhostTrail.length);

        const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
        g.addColorStop(0, `rgba(59, 130, 246, ${a * 0.8})`);
        g.addColorStop(0.5, `rgba(147, 51, 234, ${a * 0.6})`);
        g.addColorStop(1, `rgba(30, 27, 75, ${a * 0.3})`);
       
        ctx.strokeStyle = g;
        ctx.lineWidth = w;
        ctx.lineCap = 'round';
        ctx.shadowBlur = 8;
        ctx.shadowColor = 'rgba(59, 130, 246, 0.5)';
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(n.x, n.y);
        ctx.stroke();
    }
    ctx.restore();
}

for (const wisp of vfx.sajaJinGhostTrail) {
    const progress = wisp.t / wisp.life;
    const opacity = (1 - progress) * 0.8;
    const flicker = Math.sin(wisp.phase + progress * Math.PI * 12) * 0.3 + 0.7;
   
    wisp.x += wisp.vx;
    wisp.y += wisp.vy;
    wisp.vx *= 0.98;
    wisp.vy *= 0.98;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const grd = ctx.createRadialGradient(wisp.x, wisp.y, 0, wisp.x, wisp.y, wisp.r * flicker);
    grd.addColorStop(0, `rgba(59, 130, 246, ${opacity * flicker})`);
    grd.addColorStop(0.5, `rgba(147, 51, 234, ${opacity * 0.6 * flicker})`);
    grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(wisp.x, wisp.y, wisp.r * flicker, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
}

for (const trail of vfx.sajaJinHypnoticTrail) {
const progress = trail.t / trail.life;
const opacity = (1 - progress) * 0.9;

trail.x += trail.vx;
trail.y += trail.vy;
trail.vx *= 0.93;
trail.vy *= 0.93;

const sizePulse = trail.size * (1 + Math.sin(progress * Math.PI * 6) * 0.3);
ctx.globalCompositeOperation = 'lighter';
ctx.fillStyle = `rgba(255, 20, 147, ${opacity})`;
ctx.shadowBlur = 12;
ctx.shadowColor = `rgba(255, 20, 147, ${opacity * 0.6})`;
ctx.beginPath();
ctx.arc(trail.x, trail.y, sizePulse, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
}

            
            for(const trail of vfx.abbyColossalCalvesTrail){
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * 0.8;
                const pulse = Math.sin(progress * Math.PI * 8) * 0.3 + 0.7;
                const musclePower = Math.sin(trail.t * 0.02) * 0.4 + 0.6;
                
                trail.x += trail.vx;
                trail.y += trail.vy;
                trail.vx *= 0.95;
                trail.vy *= 0.95;
                
                ctx.save();
                
                ctx.globalCompositeOperation = 'screen';
                const powerGrd = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, trail.size * 4 * musclePower);
                powerGrd.addColorStop(0, `rgba(255, 20, 147, ${opacity * 0.4})`);
                powerGrd.addColorStop(0.3, `rgba(255, 105, 180, ${opacity * 0.6})`);
                powerGrd.addColorStop(0.7, `rgba(255, 192, 203, ${opacity * 0.3})`);
                powerGrd.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = powerGrd;
                ctx.beginPath();
                ctx.arc(trail.x, trail.y, trail.size * 4 * musclePower, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalCompositeOperation = 'lighter';
                
                const coreGrd = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, trail.size * pulse);
                coreGrd.addColorStop(0, `rgba(255, 255, 255, ${opacity * pulse * 0.8})`);
                coreGrd.addColorStop(0.3, `rgba(255, 20, 147, ${opacity * pulse})`);
                coreGrd.addColorStop(0.6, `rgba(255, 105, 180, ${opacity * 0.8})`);
                coreGrd.addColorStop(1, `rgba(255, 192, 203, 0)`);
                ctx.fillStyle = coreGrd;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(255, 20, 147, ${opacity * 0.7})`;
                ctx.beginPath();
                ctx.arc(trail.x, trail.y, trail.size * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                if(Math.random() < 0.4) {
                    ctx.strokeStyle = `rgba(255, 105, 180, ${opacity * 0.8})`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = `rgba(255, 20, 147, ${opacity})`;
                    
                    for(let fiber = 0; fiber < 4; fiber++) {
                        const angle = (fiber / 4) * Math.PI * 2 + trail.t * 0.01;
                        const length = trail.size * (1.5 + Math.sin(trail.t * 0.03 + fiber) * 0.5);
                        ctx.beginPath();
                        ctx.moveTo(trail.x, trail.y);
                        ctx.lineTo(trail.x + Math.cos(angle) * length, trail.y + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            for(const spark of vfx.abbyPowerPinSparks){
                const progress = spark.t / spark.life;
                const opacity = (1 - progress) * 0.9;
                const flicker = Math.sin(progress * Math.PI * 15) * 0.4 + 0.6;
                const wrestlingForce = Math.sin(spark.t * 0.025) * 0.3 + 0.7;
                
                spark.x += spark.vx;
                spark.y += spark.vy;
                spark.vx *= 0.92;
                spark.vy *= 0.92;
                
                ctx.save();
                
                ctx.globalCompositeOperation = 'screen';
                const impactGrd = ctx.createRadialGradient(spark.x, spark.y, 0, spark.x, spark.y, spark.size * 3 * wrestlingForce);
                impactGrd.addColorStop(0, `rgba(255, 69, 0, ${opacity * 0.4})`);
                impactGrd.addColorStop(0.4, `rgba(255, 20, 147, ${opacity * 0.6})`);
                impactGrd.addColorStop(0.8, `rgba(255, 105, 180, ${opacity * 0.3})`);
                impactGrd.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = impactGrd;
                ctx.beginPath();
                ctx.arc(spark.x, spark.y, spark.size * 3 * wrestlingForce, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalCompositeOperation = 'lighter';
                
                const coreGrd = ctx.createRadialGradient(spark.x, spark.y, 0, spark.x, spark.y, spark.size * flicker);
                coreGrd.addColorStop(0, `rgba(255, 255, 255, ${opacity * flicker})`);
                coreGrd.addColorStop(0.3, `rgba(255, 69, 0, ${opacity * flicker})`);
                coreGrd.addColorStop(0.7, `rgba(255, 20, 147, ${opacity * 0.8})`);
                coreGrd.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = coreGrd;
                ctx.shadowBlur = 12;
                ctx.shadowColor = `rgba(255, 69, 0, ${opacity * 0.8})`;
                ctx.beginPath();
                ctx.arc(spark.x, spark.y, spark.size * flicker, 0, Math.PI * 2);
                ctx.fill();
                
                if(Math.random() < 0.5) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                    ctx.lineWidth = 1 + Math.random();
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = `rgba(255, 20, 147, ${opacity})`;
                    
                    for(let ring = 0; ring < 3; ring++) {
                        const angle = Math.random() * Math.PI * 2;
                        const length = spark.size * (1 + Math.random() * 1.5);
                        ctx.beginPath();
                        ctx.moveTo(spark.x, spark.y);
                        const endX = spark.x + Math.cos(angle) * length;
                        const endY = spark.y + Math.sin(angle) * length;
                        ctx.lineTo(endX + (Math.random() - 0.5) * 3, endY + (Math.random() - 0.5) * 3);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            for(const aura of vfx.abbyDemonDriveAura){
                const progress = aura.t / aura.life;
                const opacity = (1 - progress) * 0.7;
                const pulse = Math.sin(progress * Math.PI * 10) * 0.4 + 0.6;
                const currentRadius = aura.radius * (1 + pulse * 0.3);
                
                const x = aura.followPlayer ? player.x : aura.x;
                const y = aura.followPlayer ? player.y : aura.y;
                
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                const grd = ctx.createRadialGradient(x, y, 0, x, y, currentRadius);
                grd.addColorStop(0, `rgba(139, 0, 139, ${opacity * pulse})`);
                grd.addColorStop(0.4, `rgba(255, 0, 255, ${opacity * 0.7})`);
                grd.addColorStop(0.7, `rgba(75, 0, 130, ${opacity * 0.5})`);
                grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                for(let i = 0; i < 5; i++){
                    const angle = (progress * Math.PI * 4) + (i * Math.PI * 2 / 5);
                    const wispX = x + Math.cos(angle) * currentRadius * 0.7;
                    const wispY = y + Math.sin(angle) * currentRadius * 0.7;
                    const wispGrd = ctx.createRadialGradient(wispX, wispY, 0, wispX, wispY, 6);
                    wispGrd.addColorStop(0, `rgba(25, 0, 25, ${opacity * 0.8})`);
                    wispGrd.addColorStop(1, 'rgba(75, 0, 130, 0)');
                    ctx.fillStyle = wispGrd;
                    ctx.beginPath();
                    ctx.arc(wispX, wispY, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            for(const residue of vfx.energyResidue) {
                const f = 1 - residue.t / residue.life;
                const a = f * 0.6;
                ctx.fillStyle = `${residue.color}${a})`;
                ctx.beginPath();
                ctx.arc(residue.x, residue.y, residue.r * f, 0, Math.PI * 2);
                ctx.fill();
            }


            vfx.shockwaves = vfx.shockwaves.filter(s=> (s.t+=dt) < s.life);
            for(const s of vfx.shockwaves){
                const t = s.t/s.life; const r = s.r + t*80;
                const a = (1-t)*0.8;

                const sColor1 = getRGBA(s.color1, a);
                const sColor2 = getRGBA(s.color2, a * 0.8);

                ctx.strokeStyle=sColor1;
                ctx.lineWidth=3; ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.stroke();
                ctx.strokeStyle=sColor2;
                ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(s.x,s.y,r*1.12,0,Math.PI*2); ctx.stroke();
            }
            for(const l of vfx.lines){
                const t=l.t/l.life; const a=(1-t)*0.6;
                const x2 = l.x + Math.cos(l.a)*l.len;
                const y2 = l.y + Math.sin(l.a)*l.len;
                ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=2;
                ctx.beginPath(); ctx.moveTo(l.x,l.y); ctx.lineTo(x2,y2); ctx.stroke();
            }

            for(const a of vfx.robsanAura){
                const progress = a.t / a.life;
                const currentRadius = lerp(a.radius * 0.5, a.radius * 2, progress);
                const opacity = (1 - progress) * 0.7;

                const grd = ctx.createRadialGradient(a.x, a.y, a.radius * 0.5, a.x, a.y, currentRadius);
                grd.addColorStop(0, `rgba(49, 46, 129, ${opacity * 0.8})`);
                grd.addColorStop(0.7, `rgba(76, 29, 149, ${opacity * 0.4})`);
                grd.addColorStop(1, `rgba(0,0,0,0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(a.x, a.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            if (vfx.voidTrails.length && player._voidDashTrail && player._voidDashTrail.length > 1) {
                for(let i=0;i<player._voidDashTrail.length-1;i++){
                    const p=player._voidDashTrail[i], n=player._voidDashTrail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/(VOID_DASH_DURATION + 100), 0, 1)*0.9;
                    const w = lerp(vfx.voidTrails[0].w,2,i/player._voidDashTrail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,getRGBA(vfx.voidTrails[0].trailColorStart,a));
                    g.addColorStop(1,getRGBA(vfx.voidTrails[0].trailColorEnd,a*0.6));
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }
            }

            if (vfx.xdrakeSupernovaTrails.length && player._xdrakeSupernovaTrail && player._xdrakeSupernovaTrail.length > 1) {
                for(let i=0;i<player._xdrakeSupernovaTrail.length-1;i++){
                    const p=player._xdrakeSupernovaTrail[i], n=player._xdrakeSupernovaTrail[i+1];
                    const age = (performance.now()-p.time);
                    const a = clamp(1-age/(XDRAKE_SUPERNOVA_DASH_DURATION + 100), 0, 1)*0.9;
                    const w = lerp(vfx.xdrakeSupernovaTrails[0].w,2,i/player._xdrakeSupernovaTrail.length);
                    const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                    g.addColorStop(0,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorStart,a));
                    g.addColorStop(1,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorEnd,a*0.6));
                    ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                }
            }



            if (vfx.asherStarTrail.length && ball._asherStarTrail && ball._asherStarTrail.length > 1) {
                for (let i = 0; i < ball._asherStarTrail.length - 1; i++) {
                    const p = ball._asherStarTrail[i], n = ball._asherStarTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / ASHER_HOMING_SHOT_DURATION, 0, 1) * 0.9;
                    const w = lerp(vfx.asherStarTrail[0].w, 2, i / ball._asherStarTrail.length);
                    const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                    g.addColorStop(0, getRGBA(vfx.asherStarTrail[0].colorStart, a));
                    g.addColorStop(1, getRGBA(vfx.asherStarTrail[0].colorEnd, a * 0.7));
                    ctx.strokeStyle = g;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                    if (Math.random() < 0.3) {
                        vfx.sparks.push({
                            x: p.x, y: p.y,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            life: 200 + Math.random() * 200,
                            t: 0, r: 1 + Math.random() * 2,
                            color: 'rgba(233, 213, 255,'
                        });
                    }
                }
            }

            if (ball._diddyOilTrail && ball._diddyOilTrail.length > 1) {
                for (let i = 0; i < ball._diddyOilTrail.length - 1; i++) {
                    const p = ball._diddyOilTrail[i], n = ball._diddyOilTrail[i+1];
                    const age = (performance.now() - p.time);
                    const a = clamp(1 - age / 3000, 0, 1) * 0.8;
                    const w = lerp(12, 2, i / ball._diddyOilTrail.length);

                    if (oilImageLoaded) {
                        const segments = Math.max(1, Math.floor(w / 6));
                        for(let s = 0; s < segments; s++) {
                            const t = s / Math.max(1, segments - 1);
                            const x = lerp(p.x, n.x, t);
                            const y = lerp(p.y, n.y, t);
                            const scale = (w / 40) * (0.6 + Math.random() * 0.3);

                            ctx.save();
                            ctx.globalAlpha = a * (0.7 + Math.random() * 0.3);
                            ctx.translate(x, y);
                            ctx.rotate(Math.random() * Math.PI * 2);
                            ctx.scale(scale, scale);
                            ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                            ctx.restore();
                        }
                    } else {
                        const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                        g.addColorStop(0, `rgba(184, 134, 11, ${a})`);
                        g.addColorStop(0.5, `rgba(139, 69, 19, ${a * 0.8})`);
                        g.addColorStop(1, `rgba(101, 67, 33, ${a * 0.5})`);

                        ctx.strokeStyle = g;
                        ctx.lineWidth = w;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(n.x, n.y);
                        ctx.stroke();

                        if (Math.random() < 0.2) {
                            ctx.fillStyle = `rgba(255, 215, 0, ${a * 0.6})`;
                            ctx.beginPath();
                            ctx.arc(p.x + (Math.random() - 0.5) * w, p.y + (Math.random() - 0.5) * w, 1 + Math.random(), 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            for(const p of vfx.asherTeleportBurst){
                const f = 1 - p.t/p.life;
                const a = f * 0.9;
                const r = p.r * (1 + (1-f)*3);
                const pulseEffect = 1 + Math.sin(p.t * 0.1) * 0.3;
                
                ctx.save();
                
                ctx.shadowBlur = 30;
                ctx.shadowColor = p.color + '0.8)';
                const outerGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 1.5 * pulseEffect);
                outerGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.3})`);
                outerGrad.addColorStop(0.3, `${p.color}${a * 0.6})`);
                outerGrad.addColorStop(0.7, `rgba(138, 43, 226, ${a * 0.4})`);
                outerGrad.addColorStop(1, 'rgba(138, 43, 226, 0)');
                ctx.fillStyle = outerGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r * 1.4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 20;
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                coreGrad.addColorStop(0.4, `${p.color}${a * 0.8})`);
                coreGrad.addColorStop(1, `${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${a * 0.8})`;
                ctx.lineWidth = 3 * f;
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i / 8) + p.t * 0.02;
                    const burstLength = r * 1.5 * (0.5 + Math.sin(p.t * 0.05 + i) * 0.5);
                    ctx.beginPath();
                    ctx.moveTo(p.x + Math.cos(angle) * r * 0.3, p.y + Math.sin(angle) * r * 0.3);
                    ctx.lineTo(p.x + Math.cos(angle) * burstLength, p.y + Math.sin(angle) * burstLength);
                    ctx.stroke();
                }
                
                ctx.restore();
            }


            for(const p of vfx.asherArrivalGlimmer){
                const f = 1 - p.t/p.life;
                const a = Math.sin(f * Math.PI) * 0.9;
                const r = p.r * (1 + Math.sin(f * Math.PI * 3) * 0.7);
                const sparkleIntensity = Math.sin(p.t * 0.2) * 0.5 + 0.5;
                
                ctx.save();
                
                ctx.shadowBlur = 25;
                ctx.shadowColor = p.color + '0.9)';
                
                const haloGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 2);
                haloGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.4})`);
                haloGrad.addColorStop(0.3, `${p.color}${a * 0.6})`);
                haloGrad.addColorStop(0.7, `rgba(255, 215, 0, ${a * 0.3})`);
                haloGrad.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = haloGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r * 1.8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 15;
                const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                coreGrad.addColorStop(0.5, `${p.color}${a})`);
                coreGrad.addColorStop(1, `${p.color}0)`);
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${a * sparkleIntensity})`;
                ctx.lineWidth = 2 * f;
                const crossSize = r * 2;
                ctx.beginPath();
                ctx.moveTo(p.x - crossSize, p.y);
                ctx.lineTo(p.x + crossSize, p.y);
                ctx.moveTo(p.x, p.y - crossSize);
                ctx.lineTo(p.x, p.y + crossSize);
                ctx.stroke();
                
                const diagonalSize = crossSize * 0.7;
                ctx.lineWidth = 1 * f;
                ctx.beginPath();
                ctx.moveTo(p.x - diagonalSize, p.y - diagonalSize);
                ctx.lineTo(p.x + diagonalSize, p.y + diagonalSize);
                ctx.moveTo(p.x + diagonalSize, p.y - diagonalSize);
                ctx.lineTo(p.x - diagonalSize, p.y + diagonalSize);
                ctx.stroke();
                
                ctx.restore();
            }

            for(const p of vfx.diddyOilParticles){
                p.t += dt;
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;
                p.vy *= 0.98;

                const f = 1 - p.t / p.life;
                const a = f * p.opacity;
                const r = p.r * (1 + (1-f) * 0.3);
                const viscosity = Math.sin(p.t * 0.015) * 0.3 + 0.7;

                if (oilImageLoaded) {
                    ctx.save();
                    
                    ctx.globalAlpha = a * 0.6;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `rgba(255, 215, 0, ${a * 0.8})`;
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.t * 0.01 * viscosity);
                    ctx.scale((r / 20) * viscosity, (r / 20) * viscosity);
                    ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                    
                    ctx.globalAlpha = a;
                    ctx.shadowBlur = 0;
                    ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                    
                    ctx.restore();
                    
                    const shineGrad = ctx.createRadialGradient(p.x - r * 0.3, p.y - r * 0.3, 0, p.x, p.y, r * 0.8);
                    shineGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.6})`);
                    shineGrad.addColorStop(0.5, `rgba(255, 215, 0, ${a * 0.3})`);
                    shineGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = shineGrad;
                    ctx.beginPath();
                    ctx.arc(p.x - r * 0.2, p.y - r * 0.2, r * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else {
                    const baseGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 2);
                    baseGrad.addColorStop(0, `rgba(255, 215, 0, ${a})`);
                    baseGrad.addColorStop(0.3, `rgba(184, 134, 11, ${a * 0.9})`); 
                    baseGrad.addColorStop(0.7, `rgba(139, 69, 19, ${a * 0.7})`);
                    baseGrad.addColorStop(1, `rgba(120, 53, 15, ${a * 0.3})`);
                    ctx.fillStyle = baseGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    const shineGrad = ctx.createRadialGradient(p.x - r * 0.3, p.y - r * 0.3, 0, p.x, p.y, r);
                    shineGrad.addColorStop(0, `rgba(255, 255, 255, ${a * 0.7})`);
                    shineGrad.addColorStop(0.6, `rgba(255, 215, 0, ${a * 0.4})`);
                    shineGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = shineGrad;
                    ctx.beginPath();
                    ctx.arc(p.x - r * 0.2, p.y - r * 0.2, r * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            vfx.diddyOilParticles = vfx.diddyOilParticles.filter(p => p.t < p.life);

            for(const p of vfx.diddyAscensionVFX){
                p.t += dt;
                p.y -= p.speed;

                const f = 1 - p.t / p.life;
                const a = Math.sin(f * Math.PI) * 0.9;
                const r = p.r * (1 + Math.sin(p.t * 0.01) * 0.2);

                if (oilImageLoaded) {
                    ctx.save();

                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 3);
                    g.addColorStop(0, `rgba(255, 223, 0, ${a * 0.6})`);
                    g.addColorStop(0.4, `rgba(255, 193, 7, ${a * 0.4})`);
                    g.addColorStop(1, `rgba(255, 193, 7, 0)`);
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r * 2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalAlpha = a * 0.9;
                    ctx.globalCompositeOperation = 'screen';
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.t * 0.02);
                    ctx.scale(r / 20, r / 20);
                    ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                    ctx.restore();
                } else {
                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 2);
                    g.addColorStop(0, `rgba(255, 223, 0, ${a})`);
                    g.addColorStop(0.4, `rgba(255, 193, 7, ${a * 0.7})`);
                    g.addColorStop(1, `rgba(255, 193, 7, 0)`);

                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (Math.random() < 0.4) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${a * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(p.x + (Math.random() - 0.5) * r, p.y + (Math.random() - 0.5) * r, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            vfx.diddyAscensionVFX = vfx.diddyAscensionVFX.filter(p => p.t < p.life);

            for(const slick of vfx.diddyOilSlicks){
                slick.t += dt;

                const f = 1 - slick.t / slick.life;
                const a = f * slick.opacity;
                const r = slick.radius * (0.8 + f * 0.2);

                if (oilImageLoaded) {
                    const oilPatches = 8;
                    for(let i = 0; i < oilPatches; i++){
                        const angle = (Math.PI * 2 * i) / oilPatches;
                        const distance = r * (0.3 + Math.random() * 0.4);
                        const x = slick.x + Math.cos(angle) * distance;
                        const y = slick.y + Math.sin(angle) * distance;
                        const scale = (0.8 + Math.random() * 0.4) * (r / 60);

                        ctx.save();
                        ctx.globalAlpha = a * (0.6 + Math.random() * 0.4);
                        ctx.translate(x, y);
                        ctx.rotate(angle + slick.t * 0.001);
                        ctx.scale(scale, scale);
                        ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                        ctx.restore();
                    }

                    ctx.save();
                    ctx.globalAlpha = a * 0.8;
                    ctx.translate(slick.x, slick.y);
                    ctx.rotate(slick.t * 0.002);
                    ctx.scale(r / 40, r / 40);
                    ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                    ctx.restore();
                } else {
                    const ripples = 3;
                    for(let i = 0; i < ripples; i++){
                        const rippleF = (slick.t * 0.003 + i * 0.33) % 1;
                        const rippleR = r * (0.3 + rippleF * 0.7);
                        const rippleA = a * (1 - rippleF) * 0.5;

                        const g = ctx.createRadialGradient(slick.x, slick.y, 0, slick.x, slick.y, rippleR);
                        g.addColorStop(0, `rgba(139, 69, 19, ${rippleA})`);
                        g.addColorStop(0.6, `rgba(160, 82, 45, ${rippleA * 0.7})`);
                        g.addColorStop(1, `rgba(160, 82, 45, 0)`);

                        ctx.fillStyle = g;
                        ctx.beginPath();
                        ctx.arc(slick.x, slick.y, rippleR, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            vfx.diddyOilSlicks = vfx.diddyOilSlicks.filter(slick => slick.t < slick.life);

            for(const trail of vfx.diddySlickTrail){
                trail.t += dt;
                trail.x += trail.vx;
                trail.y += trail.vy;
                trail.vy += 0.1;

                const f = 1 - trail.t / trail.life;
                const a = f * 0.8;
                const r = trail.r * (1 + (1-f) * 0.5);

                if (oilImageLoaded) {
                    ctx.save();
                    ctx.globalAlpha = a;
                    ctx.translate(trail.x, trail.y);
                    ctx.rotate(trail.t * 0.005);
                    ctx.scale(r / 35, r / 35);
                    ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                    ctx.restore();
                } else {
                    const g = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, r);
                    g.addColorStop(0, `rgba(184, 134, 11, ${a})`);
                    g.addColorStop(0.7, `rgba(139, 69, 19, ${a * 0.6})`);
                    g.addColorStop(1, `rgba(101, 67, 33, ${a * 0.2})`);

                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            vfx.diddySlickTrail = vfx.diddySlickTrail.filter(trail => trail.t < trail.life);


            for (const aura of vfx.lincolnGyattAura) {
                const progress = aura.t / aura.life;
                const opacity = 1 - progress;
                
                if (isFinite(aura.x) && isFinite(aura.y) && isFinite(aura.radius) && aura.radius > 0) {
                    ctx.save();
                    
                    const gradient = ctx.createRadialGradient(
                        aura.x, aura.y, 0,
                        aura.x, aura.y, aura.radius
                    );
                    gradient.addColorStop(0, `rgba(255, 100, 255, ${opacity * 0.8})`);
                    gradient.addColorStop(0.5, `rgba(100, 255, 255, ${opacity * 0.6})`);
                    gradient.addColorStop(1, `rgba(255, 255, 100, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(aura.x, aura.y, aura.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (aura.t * 0.05 + i * Math.PI / 4) % (Math.PI * 2);
                        const sparkleX = aura.x + Math.cos(angle) * aura.radius * 0.8;
                        const sparkleY = aura.y + Math.sin(angle) * aura.radius * 0.8;
                        
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, 3, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            }

            for (const trail of vfx.lincolnGyattTrail) {
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * 0.7;
                
                if (isFinite(trail.x) && isFinite(trail.y) && isFinite(trail.size) && trail.size > 0) {
                    ctx.save();
                    
                    const pulseSize = trail.size * (1 + Math.sin(trail.t * 0.2) * 0.3);
                    
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(255, 100, 255, 0.8)';
                    
                    const trailGradient = ctx.createRadialGradient(
                        trail.x, trail.y, 0,
                        trail.x, trail.y, pulseSize
                    );
                    trailGradient.addColorStop(0, `rgba(255, 200, 255, ${opacity})`);
                    trailGradient.addColorStop(0.7, `rgba(100, 255, 255, ${opacity * 0.5})`);
                    trailGradient.addColorStop(1, `rgba(255, 255, 100, 0)`);
                    
                    ctx.fillStyle = trailGradient;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            for (const particle of vfx.lincolnGyattParticles) {
                const progress = particle.t / particle.life;
                const opacity = 1 - progress;
                
                if (isFinite(particle.x) && isFinite(particle.y) && isFinite(particle.size) && particle.size > 0) {
                    ctx.save();
                    
                    const spin = particle.t * 0.1;
                    const currentSize = particle.size * (1 - progress * 0.5);
                    
                    ctx.translate(particle.x, particle.y);
                    ctx.rotate(spin);
                    
                    ctx.shadowBlur = 10;
                    
                    const hue = particle.hue || 280;
                    const saturation = 100;
                    const lightness = 60;
                    const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    
                    ctx.shadowColor = color;
                    ctx.fillStyle = color.replace('hsl', 'hsla').replace(')', `, ${opacity})`);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                    ctx.lineWidth = 1;
                    
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2) / 5;
                        const outerRadius = currentSize;
                        const innerRadius = currentSize * 0.4;
                        
                        if (i === 0) {
                            ctx.moveTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                        } else {
                            ctx.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                        }
                        
                        const innerAngle = angle + Math.PI / 5;
                        ctx.lineTo(Math.cos(innerAngle) * innerRadius, Math.sin(innerAngle) * innerRadius);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }


            for (const flame of vfx.korbinFireApocalypseFlames) {
                const progress = flame.t / flame.life;
                const opacity = (1 - progress) * flame.intensity;
                
                if (isFinite(flame.x) && isFinite(flame.y) && isFinite(flame.size) && flame.size > 0) {
                    ctx.save();
                    
                    const flicker = Math.sin(flame.t * 0.08) * 0.3 + 0.7;
                    const loopEffect = flame.loop ? Math.sin(flame.t * 0.02) * flame.loop : 0;
                    const currentSize = Math.max(0.1, flame.size * flicker * (1 + progress * 0.5 + loopEffect));
                    
                    ctx.translate(flame.x, flame.y);
                    ctx.rotate(flame.t * 0.03 + loopEffect);
                    
                    const loopBrightness = Math.max(0.3, 1 + (flame.loop ? Math.cos(flame.t * 0.05) * 0.2 : 0));
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
                    gradient.addColorStop(0, `hsla(${flame.hue}, 100%, ${Math.max(20, 70 * loopBrightness)}%, ${opacity})`);
                    gradient.addColorStop(0.3, `hsla(${flame.hue + 20}, 100%, ${Math.max(15, 60 * loopBrightness)}%, ${opacity * 0.8})`);
                    gradient.addColorStop(0.6, `hsla(${flame.hue + 40}, 90%, ${Math.max(10, 50 * loopBrightness)}%, ${opacity * 0.5})`);
                    gradient.addColorStop(1, `hsla(${flame.hue + 60}, 80%, 30%, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-currentSize/2, -currentSize/2, currentSize, currentSize);
                    
                    ctx.restore();
                }
            }

            for (const ember of vfx.korbinFireApocalypseEmbers) {
                const progress = ember.t / ember.life;
                const opacity = (1 - progress) * ember.intensity;
                
                if (isFinite(ember.x) && isFinite(ember.y) && isFinite(ember.size) && ember.size > 0) {
                    ctx.save();
                    
                    const twinkle = Math.sin(ember.t * 0.12) * 0.5 + 0.5;
                    const loopEffect = ember.loop ? Math.sin(ember.t * 0.04) * ember.loop : 0;
                    const currentSize = Math.max(0.1, ember.size * (twinkle + loopEffect));
                    
                    const loopBrightness = Math.max(0.3, 1 + (ember.loop ? Math.cos(ember.t * 0.06) * 0.3 : 0));
                    ctx.shadowBlur = Math.max(0, currentSize * (2 + Math.abs(loopEffect || 0)));
                    ctx.shadowColor = `hsl(${ember.hue}, 100%, ${Math.max(10, 60 * loopBrightness)}%)`;
                    ctx.fillStyle = `hsla(${ember.hue}, 100%, ${Math.max(20, 70 * loopBrightness)}%, ${opacity})`;
                    
                    ctx.beginPath();
                    ctx.arc(ember.x, ember.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            for (const explosion of vfx.korbinFireApocalypseExplosion) {
                const progress = explosion.t / explosion.life;
                const opacity = (1 - progress) * explosion.intensity;
                
                if (isFinite(explosion.x) && isFinite(explosion.y) && isFinite(explosion.size) && explosion.size > 0) {
                    ctx.save();
                    
                    const pulse = Math.sin(progress * Math.PI * 4) * 0.5 + 0.5;
                    const loopEffect = explosion.loop ? Math.sin(explosion.t * 0.03) * explosion.loop : 0;
                    const currentSize = Math.max(0.1, explosion.size * (1 + pulse * 2 + loopEffect));
                    
                    const loopBrightness = Math.max(0.3, 1 + (explosion.loop ? Math.cos(explosion.t * 0.05) * 0.25 : 0));
                    const gradient = ctx.createRadialGradient(explosion.x, explosion.y, 0, explosion.x, explosion.y, currentSize);
                    gradient.addColorStop(0, `hsla(${explosion.hue}, 100%, ${Math.max(20, 80 * loopBrightness)}%, ${opacity})`);
                    gradient.addColorStop(0.5, `hsla(${explosion.hue + 30}, 100%, ${Math.max(15, 60 * loopBrightness)}%, ${opacity * 0.7})`);
                    gradient.addColorStop(1, `hsla(${explosion.hue + 60}, 80%, 40%, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            for (const trail of vfx.korbinFireApocalypseTrail) {
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * trail.intensity;
                
                if (isFinite(trail.x) && isFinite(trail.y) && isFinite(trail.size) && trail.size > 0) {
                    ctx.save();
                    
                    const flow = Math.sin(trail.t * 0.1) * 0.4 + 0.6;
                    const loopEffect = trail.loop ? Math.sin(trail.t * 0.02) * trail.loop : 0;
                    const currentSize = Math.max(0.1, trail.size * (flow + loopEffect));
                    
                    const loopBrightness = Math.max(0.3, 1 + (trail.loop ? Math.cos(trail.t * 0.04) * 0.2 : 0));
                    ctx.shadowBlur = Math.max(0, currentSize * (1 + Math.abs(loopEffect || 0)));
                    ctx.shadowColor = `hsl(${trail.hue}, 100%, ${Math.max(10, 50 * loopBrightness)}%)`;
                    
                    const gradient = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, currentSize);
                    gradient.addColorStop(0, `hsla(${trail.hue}, 100%, ${Math.max(20, 70 * loopBrightness)}%, ${opacity})`);
                    gradient.addColorStop(0.4, `hsla(${trail.hue + 25}, 100%, ${Math.max(15, 60 * loopBrightness)}%, ${opacity * 0.6})`);
                    gradient.addColorStop(1, `hsla(${trail.hue + 50}, 90%, 40%, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            for (const shock of vfx.korbinFireApocalypseShockwave) {
                if (shock.delay && shock.delay > 0) continue;
                
                const progress = shock.t / shock.life;
                const opacity = (1 - progress) * shock.intensity;
                
                if (isFinite(shock.x) && isFinite(shock.y) && isFinite(shock.size) && shock.size > 0) {
                    ctx.save();
                    
                    const loopEffect = shock.loop ? Math.sin(shock.t * 0.02) * shock.loop * 20 : 0;
                    const expandSize = Math.max(0.1, shock.size * (1 + progress * 12 + Math.abs(loopEffect) * 0.3));
                    
                    const loopBrightness = Math.max(0.3, 1 + (shock.loop ? Math.cos(shock.t * 0.05) * 0.3 : 0));
                    ctx.strokeStyle = `hsla(${shock.hue}, 100%, ${Math.max(10, 60 * loopBrightness)}%, ${opacity})`;
                    ctx.lineWidth = Math.max(0.5, (4 * (1 - progress)) * (1 + Math.abs(loopEffect || 0) * 0.1));
                    ctx.shadowBlur = Math.max(0, 20 * (1 + Math.abs(loopEffect || 0) * 0.5));
                    ctx.shadowColor = `hsl(${shock.hue}, 100%, ${Math.max(10, 50 * loopBrightness)}%)`;
                    
                    ctx.beginPath();
                    ctx.arc(shock.x, shock.y, expandSize, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }

            for (const particle of vfx.korbinBigShotWindParticles) {
                const progress = particle.t / particle.life;
                const opacity = (1 - progress) * particle.opacity;
                
                if (opacity > 0.01) {
                    ctx.save();
                    
                    const swirlOffset = Math.sin(particle.t * 0.01 + particle.swirl) * 5;
                    const size = particle.size * (1 + Math.sin(particle.t * 0.008) * 0.3);
                    
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = `rgba(200, 230, 255, ${opacity})`;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `rgba(150, 200, 255, ${opacity * 0.8})`;
                    
                    ctx.beginPath();
                    ctx.arc(particle.x + swirlOffset, particle.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            for (const swirl of vfx.korbinBigShotWindSwirls) {
                const progress = swirl.t / swirl.life;
                const opacity = (1 - progress) * swirl.opacity;
                
                if (opacity > 0.01) {
                    ctx.save();
                    
                    ctx.globalAlpha = opacity;
                    ctx.translate(swirl.x, swirl.y);
                    ctx.rotate(swirl.rotation);
                    
                    const size = swirl.size * (1.2 - progress * 0.3);
                    
                    ctx.strokeStyle = `rgba(180, 220, 255, ${opacity})`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `rgba(180, 220, 255, ${opacity * 0.6})`;
                    
                    ctx.beginPath();
                    for (let i = 0; i < 3; i++) {
                        const spiralRadius = size * (0.3 + i * 0.3);
                        const startAngle = (i * Math.PI * 2) / 3;
                        ctx.moveTo(Math.cos(startAngle) * spiralRadius * 0.2, Math.sin(startAngle) * spiralRadius * 0.2);
                        ctx.lineTo(Math.cos(startAngle + Math.PI) * spiralRadius, Math.sin(startAngle + Math.PI) * spiralRadius);
                    }
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }

            for (const trail of vfx.korbinBigShotWindTrail) {
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * trail.opacity;
                
                if (opacity > 0.01) {
                    ctx.save();
                    
                    const size = trail.size * (1 - progress * 0.5);
                    const windStretch = 1 + trail.windForce * 2;
                    
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = `rgba(220, 240, 255, ${opacity})`;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `rgba(180, 220, 255, ${opacity * 0.7})`;
                    
                    ctx.beginPath();
                    ctx.ellipse(trail.x, trail.y, size * windStretch, size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }


            for(const explosion of vfx.epicExplosions){
                explosion.t += dt;
                const progress = explosion.t / explosion.life;
                const easeOut = 1 - Math.pow(1 - progress, 3);
                const radius = explosion.startRadius + (explosion.endRadius - explosion.startRadius) * easeOut;
                const opacity = Math.sin(progress * Math.PI) * explosion.maxOpacity;

                ctx.save();

                const shockwaveGrad = ctx.createRadialGradient(explosion.x, explosion.y, radius * 0.8, explosion.x, explosion.y, radius * 1.5);
                shockwaveGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.9})`);
                shockwaveGrad.addColorStop(0.3, `rgba(255, 100, 50, ${opacity * 0.7})`);
                shockwaveGrad.addColorStop(0.7, `rgba(255, 200, 0, ${opacity * 0.5})`);
                shockwaveGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = shockwaveGrad;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, radius * 1.2, 0, Math.PI * 2);
                ctx.fill();

                const coreGrad = ctx.createRadialGradient(explosion.x, explosion.y, 0, explosion.x, explosion.y, radius * 0.6);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                coreGrad.addColorStop(0.2, `rgba(255, 150, 100, ${opacity * 0.9})`);
                coreGrad.addColorStop(0.5, `rgba(255, 80, 80, ${opacity * 0.7})`);
                coreGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, radius * 0.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                ctx.lineWidth = 4;
                for(let i = 0; i < 24; i++){
                    const angle = (i / 24) * Math.PI * 2;
                    const spikeLength = radius * (0.8 + Math.sin(performance.now() * 0.02 + i) * 0.3);
                    ctx.beginPath();
                    ctx.moveTo(explosion.x + Math.cos(angle) * radius * 0.2, explosion.y + Math.sin(angle) * radius * 0.2);
                    ctx.lineTo(explosion.x + Math.cos(angle) * spikeLength, explosion.y + Math.sin(angle) * spikeLength);
                    ctx.stroke();
                }

                ctx.restore();
            }
            vfx.epicExplosions = vfx.epicExplosions.filter(e => e.t < e.life);

            for(const wave of vfx.massiveShockwaves){
                wave.t += dt;
                const progress = wave.t / wave.life;
                const radius = wave.startRadius + (wave.endRadius - wave.startRadius) * progress;
                const opacity = Math.sin(progress * Math.PI) * wave.maxOpacity;

                ctx.save();

                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                ctx.lineWidth = 8;
                ctx.shadowBlur = 20;
                ctx.shadowColor = `rgba(255, 255, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.strokeStyle = `rgba(100, 200, 255, ${opacity * 0.6})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius * 1.1, 0, Math.PI * 2);
                ctx.stroke();

                ctx.strokeStyle = `rgba(255, 100, 255, ${opacity * 0.4})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, radius * 1.2, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
            vfx.massiveShockwaves = vfx.massiveShockwaves.filter(w => w.t < w.life);

            for(const nova of vfx.energyNovas){
                nova.t += dt;
                const progress = nova.t / nova.life;
                const easeOut = 1 - Math.pow(1 - progress, 2);
                const radius = nova.startRadius + (nova.endRadius - nova.startRadius) * easeOut;
                const opacity = Math.sin(progress * Math.PI) * nova.maxOpacity;

                ctx.save();

                const pulse = Math.sin(performance.now() * 0.02) * 0.3 + 0.7;
                const novaGrad = ctx.createRadialGradient(nova.x, nova.y, 0, nova.x, nova.y, radius);
                novaGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity * pulse})`);
                novaGrad.addColorStop(0.1, `rgba(255, 200, 150, ${opacity * 0.8})`);
                novaGrad.addColorStop(0.3, `rgba(150, 100, 255, ${opacity * 0.6})`);
                novaGrad.addColorStop(0.6, `rgba(100, 150, 255, ${opacity * 0.4})`);
                novaGrad.addColorStop(1, 'rgba(50, 50, 255, 0)');
                ctx.fillStyle = novaGrad;
                ctx.beginPath();
                ctx.arc(nova.x, nova.y, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
                ctx.lineWidth = 3;
                for(let i = 0; i < 16; i++){
                    const angle = (i / 16) * Math.PI * 2 + performance.now() * 0.001;
                    const rayLength = radius * (1.2 + Math.sin(performance.now() * 0.01 + i) * 0.4);
                    ctx.beginPath();
                    ctx.moveTo(nova.x, nova.y);
                    ctx.lineTo(nova.x + Math.cos(angle) * rayLength, nova.y + Math.sin(angle) * rayLength);
                    ctx.stroke();
                }

                ctx.restore();
            }
            vfx.energyNovas = vfx.energyNovas.filter(n => n.t < n.life);

            for(const aura of vfx.sajaJinDemonicAura) { aura.t += dt; }
            vfx.sajaJinDemonicAura = vfx.sajaJinDemonicAura.filter(aura => aura.t < aura.life);

            for(const trail of vfx.sajaJinSoulTrail) { trail.t = performance.now(); }
            vfx.sajaJinSoulTrail = vfx.sajaJinSoulTrail.filter(trail => performance.now() <= trail.end);

            for(const particle of vfx.sajaJinSoulParticles) { particle.t += dt; }
            vfx.sajaJinSoulParticles = vfx.sajaJinSoulParticles.filter(particle => particle.t < particle.life);

            for(const glow of vfx.sajaJinHypnoticGlow) { glow.t += dt; }
            vfx.sajaJinHypnoticGlow = vfx.sajaJinHypnoticGlow.filter(glow => glow.t < glow.life);

            for(const trail of vfx.sajaJinHypnoticTrail) { trail.t += dt; }
            vfx.sajaJinHypnoticTrail = vfx.sajaJinHypnoticTrail.filter(trail => trail.t < trail.life);
           
            for(const trail of vfx.sajaJinHypnoticSpinTrail) { trail.t += dt; }
            vfx.sajaJinHypnoticSpinTrail = vfx.sajaJinHypnoticSpinTrail.filter(trail => trail.t < trail.life);
           
            for(const caption of vfx.sajaJinHypnoticCaption) { caption.t += dt; }
            vfx.sajaJinHypnoticCaption = vfx.sajaJinHypnoticCaption.filter(caption => caption.t < caption.life);
           
            for(const burst of vfx.sajaJinHypnoticBurst) { burst.t += dt; }
            vfx.sajaJinHypnoticBurst = vfx.sajaJinHypnoticBurst.filter(burst => burst.t < burst.life);

            for(const wisp of vfx.sajaJinGhostTrail) { wisp.t += dt; }
            vfx.sajaJinGhostTrail = vfx.sajaJinGhostTrail.filter(wisp => wisp.t < wisp.life);

            for(const trail of vfx.abbyColossalCalvesTrail){ trail.t = (trail.t||0) + dt; }
            vfx.abbyColossalCalvesTrail = vfx.abbyColossalCalvesTrail.filter(trail => !trail.life || trail.t < trail.life);
            for(const spark of vfx.abbyPowerPinSparks){ spark.t = (spark.t||0) + dt; }
            vfx.abbyPowerPinSparks = vfx.abbyPowerPinSparks.filter(spark => !spark.life || spark.t < spark.life);
            for(const aura of vfx.abbyDemonDriveAura){ aura.t = (aura.t||0) + dt; }
            vfx.abbyDemonDriveAura = vfx.abbyDemonDriveAura.filter(aura => !aura.life || aura.t < aura.life);

            for(const aura of vfx.lincolnGyattAura) { aura.t += dt; }
            vfx.lincolnGyattAura = vfx.lincolnGyattAura.filter(aura => aura.t < aura.life);
            
            for(const trail of vfx.lincolnGyattTrail) { trail.t += dt; }
            vfx.lincolnGyattTrail = vfx.lincolnGyattTrail.filter(trail => trail.t < trail.life);
            
            for(const particle of vfx.lincolnGyattParticles) { particle.t += dt; }
            vfx.lincolnGyattParticles = vfx.lincolnGyattParticles.filter(particle => particle.t < particle.life);

            for(const flame of vfx.korbinFireApocalypseFlames) {
                flame.t += dt;
                flame.x += flame.vx * (dt / 16);
                flame.y += flame.vy * (dt / 16);
                flame.vx *= 0.99;
                flame.vy *= 0.99;
            }
            vfx.korbinFireApocalypseFlames = vfx.korbinFireApocalypseFlames.filter(f => f.t < f.life);

            for(const ember of vfx.korbinFireApocalypseEmbers) {
                ember.t += dt;
                ember.x += ember.vx * (dt / 16);
                ember.y += ember.vy * (dt / 16);
                ember.vy += (ember.gravity || 0) * (dt / 16);
                ember.vx *= 0.995;
            }
            vfx.korbinFireApocalypseEmbers = vfx.korbinFireApocalypseEmbers.filter(e => e.t < e.life);

            for(const explosion of vfx.korbinFireApocalypseExplosion) {
                explosion.t += dt;
                explosion.x += explosion.vx * (dt / 16);
                explosion.y += explosion.vy * (dt / 16);
                explosion.vx *= 0.98;
                explosion.vy *= 0.98;
            }
            vfx.korbinFireApocalypseExplosion = vfx.korbinFireApocalypseExplosion.filter(e => e.t < e.life);

            for(const trail of vfx.korbinFireApocalypseTrail) {
                trail.t += dt;
                trail.x += trail.vx * (dt / 16);
                trail.y += trail.vy * (dt / 16);
                trail.vx *= 0.97;
                trail.vy *= 0.97;
            }
            vfx.korbinFireApocalypseTrail = vfx.korbinFireApocalypseTrail.filter(t => t.t < t.life);

            for(const shock of vfx.korbinFireApocalypseShockwave) {
                if (shock.delay && shock.delay > 0) {
                    shock.delay -= dt;
                    continue;
                }
                shock.t += dt;
                shock.x += shock.vx * (dt / 16);
                shock.y += shock.vy * (dt / 16);
                shock.vx *= 0.99;
                shock.vy *= 0.99;
            }
            vfx.korbinFireApocalypseShockwave = vfx.korbinFireApocalypseShockwave.filter(s => s.t < s.life);

            
            for (const trail of vfx.korbinBigBackPowerWindTrail) {
                trail.t += dt;
                const progress = trail.t / trail.life;
                const opacity = (1 - progress) * trail.intensity;
                const size = trail.size * (1 + progress * 0.5);
                
                if (isFinite(trail.x) && isFinite(trail.y) && trail.size > 0) {
                    ctx.save();
                    
                    trail.x += trail.vx * (dt / 16);
                    trail.y += trail.vy * (dt / 16);
                    
                    const swirl = Math.sin(trail.t * 0.05) * trail.spin;
                    ctx.translate(trail.x, trail.y);
                    ctx.rotate(swirl);
                    
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                    gradient.addColorStop(0, `rgba(220, 240, 255, ${opacity})`);
                    gradient.addColorStop(0.5, `rgba(180, 220, 255, ${opacity * 0.6})`);
                    gradient.addColorStop(1, `rgba(150, 200, 255, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-size/2, -size/2, size, size);
                    
                    ctx.restore();
                }
            }
            vfx.korbinBigBackPowerWindTrail = vfx.korbinBigBackPowerWindTrail.filter(t => t.t < t.life);
            
            for (const burst of vfx.korbinBigBackPowerWindBurst) {
                burst.t += dt;
                const progress = burst.t / burst.life;
                const opacity = (1 - progress) * burst.intensity;
                const size = burst.size * (1 + progress * 2);
                
                if (isFinite(burst.x) && isFinite(burst.y) && burst.size > 0) {
                    ctx.save();
                    
                    burst.x += burst.vx * (dt / 16);
                    burst.y += burst.vy * (dt / 16);
                    burst.vx *= 0.98;
                    burst.vy *= 0.98;
                    
                    burst.spiral += 0.1;
                    const spiralX = Math.cos(burst.spiral) * 5;
                    const spiralY = Math.sin(burst.spiral) * 5;
                    
                    ctx.translate(burst.x + spiralX, burst.y + spiralY);
                    ctx.rotate(burst.spiral);
                    
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                    gradient.addColorStop(0, `rgba(240, 250, 255, ${opacity})`);
                    gradient.addColorStop(0.3, `rgba(200, 230, 255, ${opacity * 0.7})`);
                    gradient.addColorStop(1, `rgba(160, 210, 255, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-size/2, -size/2, size, size);
                    
                    ctx.restore();
                }
            }
            vfx.korbinBigBackPowerWindBurst = vfx.korbinBigBackPowerWindBurst.filter(b => b.t < b.life);
            
            for (const shock of vfx.korbinBigBackPowerShockwave) {
                if (shock.delay > 0) {
                    shock.delay -= dt;
                    continue;
                }
                
                shock.t += dt;
                const progress = shock.t / shock.life;
                const opacity = (1 - progress) * shock.intensity;
                const expandSize = shock.size * (1 + progress * 8);
                
                if (isFinite(shock.x) && isFinite(shock.y) && expandSize > 0) {
                    ctx.save();
                    
                    shock.x += shock.vx * (dt / 16);
                    shock.y += shock.vy * (dt / 16);
                    shock.vx *= 0.95;
                    shock.vy *= 0.95;
                    
                    const loopEffect = shock.loop ? Math.cos(shock.t * 0.08) * shock.loop : 0;
                    const loopBrightness = Math.max(0.5, 1 + loopEffect);
                    
                    ctx.strokeStyle = `rgba(200, 240, 255, ${opacity * loopBrightness})`;
                    ctx.lineWidth = Math.max(1, 4 - progress * 2);
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `rgba(180, 220, 255, ${opacity * 0.8})`;
                    
                    ctx.beginPath();
                    ctx.arc(shock.x, shock.y, expandSize, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
            vfx.korbinBigBackPowerShockwave = vfx.korbinBigBackPowerShockwave.filter(s => s.t < s.life);

            
            for (const particle of vfx.korbinBigShotWindParticles) {
                particle.t += dt;
                particle.x += particle.vx * (dt / 16);
                particle.y += particle.vy * (dt / 16);
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                
                const swirlForce = Math.sin(particle.t * 0.01) * 0.3;
                particle.vx += swirlForce;
                particle.vy += Math.cos(particle.t * 0.01) * 0.3;
            }
            vfx.korbinBigShotWindParticles = vfx.korbinBigShotWindParticles.filter(p => p.t < p.life);
            
            for (const swirl of vfx.korbinBigShotWindSwirls) {
                swirl.t += dt;
                swirl.x += swirl.vx * (dt / 16);
                swirl.y += swirl.vy * (dt / 16);
                swirl.vx *= 0.96;
                swirl.vy *= 0.96;
                swirl.rotation += swirl.rotSpeed * (dt / 16);
                
                const expansionForce = 0.2;
                const centerDist = Math.hypot(swirl.vx, swirl.vy);
                if (centerDist > 0) {
                    swirl.vx += (swirl.vx / centerDist) * expansionForce;
                    swirl.vy += (swirl.vy / centerDist) * expansionForce;
                }
            }
            vfx.korbinBigShotWindSwirls = vfx.korbinBigShotWindSwirls.filter(s => s.t < s.life);
            
            for (const trail of vfx.korbinBigShotWindTrail) {
                trail.t += dt;
                trail.x += trail.vx * (dt / 16);
                trail.y += trail.vy * (dt / 16);
                trail.vx *= 0.95;
                trail.vy *= 0.95;
                
                trail.windForce *= 0.99;
            }
            vfx.korbinBigShotWindTrail = vfx.korbinBigShotWindTrail.filter(t => t.t < t.life);

            for (const t of vfx.wallyRocketTrail) {
                t.t += dt;
                const progress = t.t / t.life;
                const opacity = (1 - progress) * t.intensity;
                const size = t.size * (1 - progress * 0.5);
                
                const grd = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, size * 3);
                grd.addColorStop(0, `hsla(${t.hue}, 90%, 60%, ${opacity})`);
                grd.addColorStop(1, `hsla(${t.hue}, 90%, 60%, 0)`);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                t.x += t.vx;
                t.y += t.vy;
                t.vx *= 0.95;
                t.vy *= 0.95;
            }
            vfx.wallyRocketTrail = vfx.wallyRocketTrail.filter(t => t.t < t.life);

            for (const d of vfx.wallySpeedForceDome) {
                d.t += dt;
                const progress = d.t / d.life;
                const opacity = Math.sin(progress * Math.PI) * d.intensity;
                
                ctx.strokeStyle = `hsla(${d.hue}, 80%, 70%, ${opacity})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x, player.y, d.radius, d.angle, d.angle + Math.PI / 20);
                ctx.stroke();
            }
            vfx.wallySpeedForceDome = vfx.wallySpeedForceDome.filter(d => d.t < d.life);

            for (const a of vfx.wallyLightningAura) {
                a.t += dt;
                const progress = a.t / a.life;
                const opacity = (1 - progress) * a.intensity;
                const size = a.size * (1 + progress * 0.3);
                
                if (a.spark) {
                    ctx.strokeStyle = `hsla(${a.hue}, 100%, 90%, ${opacity})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(a.x - size, a.y);
                    ctx.lineTo(a.x + size, a.y);
                    ctx.moveTo(a.x, a.y - size);
                    ctx.lineTo(a.x, a.y + size);
                    ctx.stroke();
                } else {
                    const grd = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, size * 2);
                    grd.addColorStop(0, `hsla(${a.hue}, 100%, 80%, ${opacity})`);
                    grd.addColorStop(1, `hsla(${a.hue}, 100%, 80%, 0)`);
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(a.x, a.y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                a.x += a.vx;
                a.y += a.vy;
            }
            vfx.wallyLightningAura = vfx.wallyLightningAura.filter(a => a.t < a.life);

            for (const b of vfx.wallyLightningBolts) {
                b.t += dt;
                const progress = b.t / b.life;
                const opacity = (1 - progress) * b.intensity;
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.lineWidth = b.width;
                ctx.beginPath();
                
                const dx = b.targetX - b.x;
                const dy = b.targetY - b.y;
                const segments = b.segments;
                
                ctx.moveTo(b.x, b.y);
                for (let i = 1; i <= segments; i++) {
                    const segmentProgress = i / segments;
                    const baseX = b.x + dx * segmentProgress;
                    const baseY = b.y + dy * segmentProgress;
                    const jitter = 10;
                    const offsetX = (Math.random() - 0.5) * jitter;
                    const offsetY = (Math.random() - 0.5) * jitter;
                    ctx.lineTo(baseX + offsetX, baseY + offsetY);
                }
                ctx.stroke();
            }
            vfx.wallyLightningBolts = vfx.wallyLightningBolts.filter(b => b.t < b.life);

            for (const text of vfx.sixtySevenKidTextClones) {
                text.t += dt;
                const progress = text.t / text.life;
                const opacity = (1 - progress) * 0.9;
                const rotation = text.rotation + (text.rotationSpeed * dt);
                text.rotation = rotation;
                
                if (!isFinite(text.x) || !isFinite(text.y) || !isFinite(rotation) || 
                    !isFinite(text.size) || !isFinite(opacity) || text.size <= 0) {
                    continue;
                }
                
                ctx.save();
                ctx.translate(text.x, text.y);
                ctx.rotate(rotation);
                ctx.scale(text.size, text.size);
                
                ctx.globalCompositeOperation = 'lighter';
                ctx.shadowBlur = 20;
                ctx.shadowColor = `rgba(0, 188, 212, ${opacity * 0.8})`;
                ctx.fillStyle = `rgba(0, 188, 212, ${opacity})`;
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('67', 0, 0);
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = `rgba(255, 255, 255, ${opacity})`;
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.6})`;
                ctx.fillText('67', 0, 0);
                
                ctx.restore();
            }
            vfx.sixtySevenKidTextClones = vfx.sixtySevenKidTextClones.filter(t => t.t < t.life);
            
            for (const aura of vfx.sixtySevenKidMayhemAura) {
                aura.t += dt;
                const progress = aura.t / aura.life;
                const opacity = (1 - progress) * 0.7;
                const currentRadius = aura.radius * (1 + progress * 0.5);
                
                if (!isFinite(aura.x) || !isFinite(aura.y) || !isFinite(currentRadius) || 
                    !isFinite(opacity) || currentRadius <= 0) {
                    continue;
                }
                
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const auraGrad = ctx.createRadialGradient(aura.x, aura.y, 0, aura.x, aura.y, currentRadius);
                auraGrad.addColorStop(0, `rgba(0, 188, 212, ${opacity * 0.8})`);
                auraGrad.addColorStop(0.5, `rgba(33, 150, 243, ${opacity * 0.6})`);
                auraGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(aura.x, aura.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            vfx.sixtySevenKidMayhemAura = vfx.sixtySevenKidMayhemAura.filter(a => a.t < a.life);
            
            for (const overlay of vfx.sixtySevenKidBlackoutOverlay) {
                overlay.t += dt;
                const progress = overlay.t / overlay.life;
                const opacity = overlay.opacity * Math.sin(progress * Math.PI);
                
                if (!isFinite(opacity) || opacity < 0) {
                    continue;
                }
                
                ctx.save();
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillStyle = `rgba(0, 0, 0, ${Math.min(1, Math.max(0, opacity))})`;
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }
            vfx.sixtySevenKidBlackoutOverlay = vfx.sixtySevenKidBlackoutOverlay.filter(o => o.t < o.life);

            for(const storm of vfx.particleStorms){
                storm.t += dt;
                const progress = storm.t / storm.life;
                const opacity = Math.sin(progress * Math.PI) * storm.intensity;

                for(let i = 0; i < storm.particles.length; i++){
                    const p = storm.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.99;
                    p.vy *= 0.99;

                    const particleGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 3);
                    particleGrad.addColorStop(0, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${opacity})`);
                    particleGrad.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, 0)`);
                    ctx.fillStyle = particleGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            vfx.particleStorms = vfx.particleStorms.filter(s => s.t < s.life);

            for(const trail of vfx.cristianoPowerShotTrail){
                trail.t += dt;
                const f = 1 - trail.t / trail.life;
                const intensity = trail.intensity || 1;
                const a = f * 0.95 * intensity;
                const goatPower = Math.sin(trail.t * 0.02) * 0.3 + 0.7;

                ctx.save();
                
                ctx.globalCompositeOperation = 'screen';
                const legendGrad = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                legendGrad.addColorStop(0, `rgba(255, 215, 0, ${a * 0.4})`);
                legendGrad.addColorStop(0.5, `rgba(255, 50, 50, ${a * 0.6})`);
                legendGrad.addColorStop(1, `rgba(22, 163, 74, ${a * 0.4})`);
                ctx.strokeStyle = legendGrad;
                ctx.lineWidth = 35 * intensity * goatPower;
                ctx.shadowBlur = 40;
                ctx.shadowColor = `rgba(255, 215, 0, ${a})`;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(trail.startX, trail.startY);
                ctx.lineTo(trail.endX, trail.endY);
                ctx.stroke();
                
                ctx.globalCompositeOperation = 'source-over';

                ctx.shadowBlur = 25;
                ctx.shadowColor = `rgba(255, 215, 0, ${a * 0.8})`;
                const outerGlow = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                outerGlow.addColorStop(0, `rgba(255, 50, 50, ${a})`);
                outerGlow.addColorStop(0.2, `rgba(255, 215, 0, ${a * 0.95})`);
                outerGlow.addColorStop(0.4, `rgba(255, 255, 255, ${a * 0.9})`);
                outerGlow.addColorStop(0.6, `rgba(255, 215, 0, ${a * 0.8})`);
                outerGlow.addColorStop(0.8, `rgba(22, 163, 74, ${a * 0.7})`);
                outerGlow.addColorStop(1, `rgba(255, 50, 50, ${a * 0.6})`);

                ctx.strokeStyle = outerGlow;
                ctx.lineWidth = 22 * intensity * goatPower;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(trail.startX, trail.startY);
                ctx.lineTo(trail.endX, trail.endY);
                ctx.stroke();

                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(255, 255, 255, ${a})`;
                const innerCore = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                innerCore.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                innerCore.addColorStop(0.3, `rgba(255, 215, 0, ${a * 0.95})`);
                innerCore.addColorStop(0.7, `rgba(255, 255, 255, ${a * 0.9})`);
                innerCore.addColorStop(1, `rgba(255, 215, 0, ${a * 0.8})`);

                ctx.strokeStyle = innerCore;
                ctx.lineWidth = 12 * intensity * goatPower;
                ctx.beginPath();
                ctx.moveTo(trail.startX, trail.startY);
                ctx.lineTo(trail.endX, trail.endY);
                ctx.stroke();
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${a * 0.9})`;
                ctx.lineWidth = 4 * intensity;
                ctx.shadowBlur = 8;
                ctx.shadowColor = `rgba(255, 255, 255, ${a})`;
                ctx.beginPath();
                ctx.moveTo(trail.startX, trail.startY);
                ctx.lineTo(trail.endX, trail.endY);
                ctx.stroke();

                ctx.restore();
            }
            vfx.cristianoPowerShotTrail = vfx.cristianoPowerShotTrail.filter(trail => trail.t < trail.life);

            for(const p of vfx.cristianoGoatTackleParticles){
                p.t += dt;
                const f = 1 - p.t / p.life;
                const a = f * 0.9;
                p.x += p.vx * (dt/16);
                p.y += p.vy * (dt/16);
                p.vx *= 0.96;
                p.vy *= 0.96;

                ctx.save();

                if (p.isExplosion) {
                    const goatGlow = Math.sin(p.t * 0.03) * 0.4 + 0.6;
                    ctx.shadowBlur = 25 * goatGlow;
                    ctx.shadowColor = `rgba(255, 215, 0, ${a})`;
                    const size = Math.max(0.1, p.size * f * goatGlow);
                    
                    const divineGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 3);
                    divineGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                    divineGrad.addColorStop(0.2, `rgba(255, 215, 0, ${a * 0.9})`);
                    divineGrad.addColorStop(0.5, `rgba(255, 140, 0, ${a * 0.7})`);
                    divineGrad.addColorStop(0.8, `rgba(220, 38, 38, ${a * 0.5})`);
                    divineGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = divineGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 1.5);
                    coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                    coreGrad.addColorStop(0.3, `rgba(255, 215, 0, ${a * 0.9})`);
                    coreGrad.addColorStop(0.7, `rgba(255, 140, 0, ${a * 0.7})`);
                    coreGrad.addColorStop(1, `rgba(220, 38, 38, ${a * 0.4})`);
                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (p.isPowerShotExplosion) {
                    const furyPulse = Math.sin(p.t * 0.04) * 0.5 + 0.5;
                    ctx.shadowBlur = 20 * furyPulse;
                    ctx.shadowColor = `rgba(255, 50, 50, ${a})`;
                    const size = Math.max(0.1, p.size * f);
                    
                    const flagGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2);
                    flagGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                    flagGrad.addColorStop(0.3, `rgba(255, 50, 50, ${a * 0.9})`);
                    flagGrad.addColorStop(0.6, `rgba(255, 215, 0, ${a * 0.7})`);
                    flagGrad.addColorStop(0.9, `rgba(22, 163, 74, ${a * 0.5})`);
                    flagGrad.addColorStop(1, `rgba(255, 100, 0, ${a * 0.3})`);
                    ctx.fillStyle = flagGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size * furyPulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (p.isEnergyBurst) {
                    const size = Math.max(0.1, p.size * f);
                    const prideSparkle = Math.sin(p.t * 0.02) * 0.4 + 0.6;
                    ctx.shadowBlur = 15 * prideSparkle;
                    ctx.shadowColor = `rgba(22, 163, 74, ${a * prideSparkle})`;
                    
                    const spiritGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2.5);
                    spiritGrad.addColorStop(0, `rgba(255, 255, 255, ${a * prideSparkle})`);
                    spiritGrad.addColorStop(0.3, `rgba(22, 163, 74, ${a * 0.9})`);
                    spiritGrad.addColorStop(0.6, `rgba(255, 215, 0, ${a * 0.7})`);
                    spiritGrad.addColorStop(0.9, `rgba(220, 38, 38, ${a * 0.5})`);
                    spiritGrad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = spiritGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size * prideSparkle, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else {
                    const brilliance = Math.sin(p.t * 0.01) * 0.3 + 0.7;
                    const goatShine = Math.sin(p.t * 0.02) * 0.4 + 0.6;
                    ctx.shadowBlur = 15 * brilliance;
                    ctx.shadowColor = `rgba(255, 215, 0, ${a * 0.8})`;
                    
                    const goldenGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
                    goldenGrad.addColorStop(0, `rgba(255, 215, 0, ${a * brilliance})`);
                    goldenGrad.addColorStop(0.4, `rgba(255, 255, 255, ${a * 0.7 * goatShine})`);
                    goldenGrad.addColorStop(0.8, `rgba(255, 165, 0, ${a * 0.4})`);
                    goldenGrad.addColorStop(1, `rgba(255, 165, 0, 0)`);
                    ctx.fillStyle = goldenGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * brilliance);
                    coreGrad.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                    coreGrad.addColorStop(0.5, `rgba(255, 215, 0, ${a * 0.9})`);
                    coreGrad.addColorStop(1, `rgba(255, 165, 0, ${a * 0.6})`);
                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * brilliance, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
            vfx.cristianoGoatTackleParticles = vfx.cristianoGoatTackleParticles.filter(p => p.t < p.life);

            for(const aura of vfx.cristianoPortugueseSpiritAura){
                aura.t += dt;
                const f = 1 - aura.t / aura.life;
                const a = f * 0.4;
                const pulse = Math.sin(aura.t * 0.005) * 0.3 + 0.7;

                ctx.save();
                ctx.translate(aura.x, aura.y);

                const rotation = aura.t * 0.002;
                for(let ring = 0; ring < 3; ring++){
                    const radius = aura.radius * (0.5 + ring * 0.25) * pulse;
                    const ringOpacity = a * (1 - ring * 0.3);

                    const redGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    redGradient.addColorStop(0, `rgba(220, 20, 60, ${ringOpacity})`);
                    redGradient.addColorStop(1, `rgba(220, 20, 60, 0)`);
                    ctx.fillStyle = redGradient;

                    ctx.beginPath();
                    ctx.arc(0, 0, radius, rotation, rotation + Math.PI);
                    ctx.fill();

                    const greenGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    greenGradient.addColorStop(0, `rgba(34, 139, 34, ${ringOpacity})`);
                    greenGradient.addColorStop(1, `rgba(34, 139, 34, 0)`);
                    ctx.fillStyle = greenGradient;

                    ctx.beginPath();
                    ctx.arc(0, 0, radius, rotation + Math.PI, rotation + Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
            vfx.cristianoPortugueseSpiritAura = vfx.cristianoPortugueseSpiritAura.filter(aura => aura.t < aura.life);

            for(const trail of vfx.cristianoMovementTrail){
                trail.t += dt;
                const f = 1 - trail.t / trail.life;
                const a = f * 0.7;

                if (isFinite(trail.x) && isFinite(trail.y) && isFinite(trail.vx) && isFinite(trail.vy)) {
                    if (trail.isEnergyBurst || trail.isPowerShotExplosion) {
                        trail.x += trail.vx * (dt/16);
                        trail.y += trail.vy * (dt/16);
                        trail.vx *= 0.98;
                        trail.vy *= 0.98;

                        const size = Math.max(0.1, trail.size * f);
                        const g = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, Math.max(0.1, size));
                        if (trail.isEnergyBurst) {
                            g.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                            g.addColorStop(0.5, `rgba(22, 163, 74, ${a * 0.8})`);
                            g.addColorStop(1, `rgba(220, 38, 38, ${a * 0.4})`);
                        } else {
                            g.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                            g.addColorStop(0.5, `rgba(255, 50, 50, ${a * 0.8})`);
                            g.addColorStop(1, `rgba(255, 215, 0, ${a * 0.6})`);
                        }
                        ctx.fillStyle = g;
                        ctx.beginPath();
                        ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (trail.startX && trail.startY && trail.endX && trail.endY &&
                             isFinite(trail.startX) && isFinite(trail.startY) && isFinite(trail.endX) && isFinite(trail.endY)) {
                        const g = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                        g.addColorStop(0, `rgba(220, 20, 60, ${a})`);
                        g.addColorStop(0.5, `rgba(255, 255, 255, ${a * 0.5})`);
                        g.addColorStop(1, `rgba(34, 139, 34, ${a})`);

                        ctx.strokeStyle = g;
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(trail.startX, trail.startY);
                        ctx.lineTo(trail.endX, trail.endY);
                        ctx.stroke();
                    }
                }
            }
            vfx.cristianoMovementTrail = vfx.cristianoMovementTrail.filter(trail => trail.t < trail.life);

            for(const p of vfx.lincolnShrekTrail){
                const f = 1 - p.t / p.life;
                const a = f * 0.9;
                const pulse = Math.sin(p.t * 0.01) * 0.3 + 0.7;
               
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
               
                const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
                g.addColorStop(0, `rgba(144, 238, 144, ${a * pulse})`);
                g.addColorStop(0.5, `rgba(50, 205, 50, ${a * 0.8})`);
                g.addColorStop(1, `rgba(34, 139, 34, 0)`);
               
                ctx.fillStyle = g;
                ctx.shadowBlur = 10;
                ctx.shadowColor = `rgba(50, 205, 50, ${a * 0.6})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * pulse, 0, Math.PI * 2);
                ctx.fill();
               
                ctx.restore();
            }

            for(const p of vfx.lincolnShrekParticles){
                const f = 1 - p.t / p.life;
                const a = f * 0.9;
                const glowPulse = Math.sin(p.t * 0.015) * 0.4 + 0.6;
               
                ctx.save();
               
                if(p.glow) {
                    ctx.globalCompositeOperation = 'screen';
                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3.5);
                    g.addColorStop(0, `rgba(255, 255, 255, ${a * glowPulse})`);
                    g.addColorStop(0.4, p.color.replace(')', `, ${a * 0.8})`));
                    g.addColorStop(1, p.color.replace(')', ', 0)'));
                   
                    ctx.fillStyle = g;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = p.color.replace(')', `, ${a})`);
                } else {
                    ctx.globalCompositeOperation = 'lighter';
                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2.5);
                    g.addColorStop(0, p.color.replace(')', `, ${a * glowPulse})`));
                    g.addColorStop(1, p.color.replace(')', ', 0)'));
                    ctx.fillStyle = g;
                }
               
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * glowPulse, 0, Math.PI * 2);
                ctx.fill();
               
                ctx.restore();
            }
        }

        function tryDiddyBabyOilAscension() {
            const now = performance.now();
            if (currentStyle !== 'diddy') return;

            if (player.hasBall) {
                showNotification('cant use baby oil ascension while holding ball', 'error');
                return;
            }

            if (now < diddyBabyOilReadyAt) {
                const cooldownLeft = Math.ceil((diddyBabyOilReadyAt - now) / 1000);
                showNotification(`Baby Oil Ascension on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (player.diddyBabyOilActive) return;

            player.diddyBabyOilActive = true;
            player.diddyBabyOilPhase = 'subtitle1';
            player.diddyBabyOilStartTime = now;

            showBabyOilGuySubtitle('Yo theres the ball! baby oil help me!', () => {
                player.diddyBabyOilPhase = 'running';

                const distance = Math.sqrt((ball.x - player.x) ** 2 + (ball.y - player.y) ** 2);
                const teleportSteps = 15;
                const stepX = (ball.x - player.x) / teleportSteps;
                const stepY = (ball.y - player.y) / teleportSteps;

                let step = 0;
                const teleportInterval = setInterval(() => {
                    if (step < teleportSteps) {
                        player.x += stepX;
                        player.y += stepY;

                        vfx.diddyOilParticles.push({
                            x: player.x + (Math.random() - 0.5) * 20,
                            y: player.y + (Math.random() - 0.5) * 20,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                            life: 800,
                            t: 0,
                            r: 2 + Math.random() * 3,
                            opacity: 0.8
                        });
                        step++;
                    } else {
                        clearInterval(teleportInterval);

                        player.hasBall = true;
                        ball.vx = 0;
                        ball.vy = 0;

                        player.diddyBabyOilPhase = 'ascension';

                        for(let i = 0; i < 20; i++){
                            vfx.diddyAscensionVFX.push({
                                x: ball.x + (Math.random() - 0.5) * 50,
                                y: ball.y + (Math.random() - 0.5) * 50,
                                speed: 1 + Math.random() * 2,
                                life: 1500 + Math.random() * 500,
                                t: 0,
                                r: 8 + Math.random() * 6
                            });
                        }

                        setTimeout(() => {
                            player.diddyBabyOilPhase = 'subtitle2';
                            showBabyOilGuySubtitle('Thanks baby oil :D)', () => {
                                player.diddyBabyOilActive = false;
                                player.diddyBabyOilPhase = '';
                            });
                        }, 1000);
                    }
                }, 50);
            });

            diddyBabyOilReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryDiddySlickShot() {
            const now = performance.now();
            if (currentStyle !== 'diddy') return;

            if (now < diddySlickShotReadyAt) {
                const cooldownLeft = Math.ceil((diddySlickShotReadyAt - now) / 1000);
                showNotification(`Slick Shot on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('Need ball for Slick Shot!', 'error');
                return;
            }

            const shootDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.vx = Math.cos(shootDir) * DIDDY_SLICK_SHOT_POWER + player.vx * 0.2;
            ball.vy = Math.sin(shootDir) * DIDDY_SLICK_SHOT_POWER + player.vy * 0.2;

            ball.hasOilTrail = true;
            ball.oilTrailEndTime = now + 1000;

            player.hasBall = false;
            diddySlickShotReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryDiddyOilSlickTrap() {
            const now = performance.now();
            if (currentStyle !== 'diddy') return;

            if (now < diddyOilSlickReadyAt) {
                const cooldownLeft = Math.ceil((diddyOilSlickReadyAt - now) / 1000);
                showNotification(`Baby Oil Blindness on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            vfx.diddyOilSlicks.push({
                x: mouse.x,
                y: mouse.y,
                radius: 80,
                t: 0,
                life: DIDDY_OIL_SLICK_DURATION,
                opacity: 0.7
            });

            for(let i = 0; i < 25; i++){
                const angle = (Math.PI * 2 * i) / 25;
                vfx.diddyOilParticles.push({
                    x: mouse.x,
                    y: mouse.y,
                    vx: Math.cos(angle) * (2 + Math.random() * 3),
                    vy: Math.sin(angle) * (2 + Math.random() * 3),
                    life: 1200 + Math.random() * 600,
                    t: 0,
                    r: 2 + Math.random() * 3,
                    opacity: 0.8
                });
            }

            player.diddyOilSlickActive = true;
            player.diddyOilSlickEndTime = now + DIDDY_OIL_SLICK_DURATION;

            diddyOilSlickReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryCristianoPowerShot() {
            const now = performance.now();
            if (currentStyle !== 'cristiano') return;

            if (now < cristianoPowerShotReadyAt) {
                const cooldownLeft = Math.ceil((cristianoPowerShotReadyAt - now) / 1000);
                showNotification(`Power Shot on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('Need ball to use Power Shot!', 'error');
                return;
            }

            const shotPower = CRISTIANO_POWER_SHOT_POWER + (player.cristianoPortugueseSpiritActive ? CRISTIANO_PORTUGUESE_SPIRIT_SHOT_POWER_BONUS : 0);
            const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);

            ball.vx = Math.cos(angle) * shotPower;
            ball.vy = Math.sin(angle) * shotPower;
            ball.maxSpeed = 100000;
            ball.isUnblockable = true;
            ball.isCristianoPowerShot = true;

            player.hasBall = false;

            for (let i = 0; i < 3; i++) {
                vfx.cristianoPowerShotTrail.push({
                    startX: player.x + (Math.random() - 0.5) * 10,
                    startY: player.y + (Math.random() - 0.5) * 10,
                    endX: player.x + Math.cos(angle) * (250 + i * 50),
                    endY: player.y + Math.sin(angle) * (250 + i * 50),
                    life: 1200 + i * 200,
                    t: 0,
                    intensity: 1 - i * 0.2
                });
            }

            for (let i = 0; i < 20; i++) {
                const explosionAngle = (Math.PI * 2 * i) / 20;
                vfx.cristianoMovementTrail.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(explosionAngle) * 12,
                    vy: Math.sin(explosionAngle) * 12,
                    life: 600,
                    t: 0,
                    size: Math.random() * 6 + 4,
                    isPowerShotExplosion: true
                });
            }

            if (typeof screenShake !== 'undefined') {
                screenShake(15, 300);
            }

        shockwave(player.x, player.y, 40, 'cristiano');

            setTimeout(() => {
                ball.maxSpeed = 18;
            }, 800);

            showNotification('CRISTIANO POWER SHOT! DEVASTATING FORCE!', 'success');
            cristianoPowerShotReadyAt = now + ABILITY_COOLDOWN;
        }


        function tryCristianoGoatTackle() {
            const now = performance.now();
            if (currentStyle !== 'cristiano') return;

            if (now < cristianoGoatTackleReadyAt) {
                const cooldownLeft = Math.ceil((cristianoGoatTackleReadyAt - now) / 1000);
                showNotification(`GOAT's Tackle on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            const distanceToBall = Math.hypot(ball.x - player.x, ball.y - player.y);
            const distanceToAI = aiEnabled ? Math.hypot(aiPlayer.x - player.x, aiPlayer.y - player.y) : Infinity;

            const canTackleBall = distanceToBall <= CRISTIANO_GOAT_TACKLE_RANGE && !player.hasBall && !aiPlayer.hasBall;
            const canStealFromAI = aiEnabled && aiPlayer.hasBall && distanceToAI <= CRISTIANO_GOAT_TACKLE_RANGE;

            if (!canTackleBall && !canStealFromAI) {
                if (player.hasBall) {
                    showNotification("Already have the ball!", 'error');
                } else if (aiPlayer.hasBall) {
                    showNotification(`Too far from AI! Must be within ${Math.floor(CRISTIANO_GOAT_TACKLE_RANGE)}px`, 'error');
                } else {
                    showNotification(`Too far from ball! Must be within ${Math.floor(CRISTIANO_GOAT_TACKLE_RANGE)}px`, 'error');
                }
                return;
            }

            const oldX = player.x;
            const oldY = player.y;

            if (canStealFromAI) {
                const angle = Math.atan2(aiPlayer.y - player.y, aiPlayer.x - player.x);
                player.x = aiPlayer.x - Math.cos(angle) * (player.r + aiPlayer.r + 10);
                player.y = aiPlayer.y - Math.sin(angle) * (player.r + aiPlayer.r + 10);

                aiPlayer.hasBall = false;
                aiPlayer.isStunned = true;
                aiPlayer.stunEndTime = now + 2000;

                player.hasBall = true;
                ball.x = player.x + player.r + ball.r + 2;
                ball.y = player.y;
                ball.vx = 0;
                ball.vy = 0;

                showNotification("GOAT's Tackle! Ball stolen from AI!", 'success');
            } else if (canTackleBall) {
                const angle = Math.atan2(ball.y - player.y, ball.x - player.x);
                player.x = ball.x - Math.cos(angle) * (player.r + ball.r + 8);
                player.y = ball.y - Math.sin(angle) * (player.r + ball.r + 8);

                player.hasBall = true;
                ball.vx = 0;
                ball.vy = 0;

                showNotification("GOAT's Tackle! Ball secured!", 'success');
            }

            for (let i = 0; i < 25; i++) {
                vfx.cristianoGoatTackleParticles.push({
                    x: oldX,
                    y: oldY,
                    vx: (Math.random() - 0.5) * 18,
                    vy: (Math.random() - 0.5) * 18,
                    life: 1200,
                    t: 0,
                    size: Math.random() * 8 + 4
                });
            }

            for (let i = 0; i < 15; i++) {
                const angle = (Math.PI * 2 * i) / 15;
                vfx.cristianoGoatTackleParticles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * 10,
                    vy: Math.sin(angle) * 10,
                    life: 800,
                    t: 0,
                    size: Math.random() * 6 + 6,
                    isExplosion: true
                });
            }

            cristianoGoatTackleReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryCristianoPortugueseSpirit() {
            const now = performance.now();
            if (currentStyle !== 'cristiano') return;

            if (now < cristianoPortugueseSpiritReadyAt) {
                const cooldownLeft = Math.ceil((cristianoPortugueseSpiritReadyAt - now) / 1000);
                showNotification(`Portuguese Spirit on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            player.cristianoPortugueseSpiritActive = true;
            player.cristianoPortugueseSpiritEndTime = now + CRISTIANO_PORTUGUESE_SPIRIT_DURATION;
            player.maxSpd *= CRISTIANO_PORTUGUESE_SPIRIT_SPEED_MULTIPLIER;

            vfx.cristianoPortugueseSpiritAura.push({
                x: player.x,
                y: player.y,
                radius: player.r * 4,
                life: CRISTIANO_PORTUGUESE_SPIRIT_DURATION,
                t: 0,
                layer: 'outer'
            });

            vfx.cristianoPortugueseSpiritAura.push({
                x: player.x,
                y: player.y,
                radius: player.r * 2.5,
                life: CRISTIANO_PORTUGUESE_SPIRIT_DURATION,
                t: 0,
                layer: 'inner'
            });

            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                vfx.cristianoMovementTrail.push({
                    x: player.x + Math.cos(angle) * player.r,
                    y: player.y + Math.sin(angle) * player.r,
                    vx: Math.cos(angle) * 8,
                    vy: Math.sin(angle) * 8,
                    life: 1000,
                    t: 0,
                    size: Math.random() * 4 + 3,
                    isEnergyBurst: true
                });
            }

            showNotification('Portuguese Spirit ACTIVATED! Unstoppable power unleashed!', 'success');
            cristianoPortugueseSpiritReadyAt = now + 15000;
        }

        function showBabyOilGuySubtitle(text, callback) {
            const subtitleEl = document.getElementById('baby-oil-guy-subtitles');
            const textEl = document.getElementById('subtitle-text');

            subtitleEl.style.display = 'block';
            textEl.textContent = '';

            let charIndex = 0;
            const typeInterval = setInterval(() => {
                if (charIndex < text.length) {
                    textEl.textContent += text[charIndex];
                    charIndex++;
                } else {
                    clearInterval(typeInterval);
                    setTimeout(() => {
                        subtitleEl.style.display = 'none';
                        if (callback) callback();
                    }, 1000);
                }
            }, 50);
        }

        function trySajaJinDemonicHeroism() {
            const now = performance.now();
            if (currentStyle !== 'saja-jin') return;

            if (now < sajaJinDemonicHeroismReadyAt) {
                const cooldownLeft = Math.ceil((sajaJinDemonicHeroismReadyAt - now) / 1000);
                showNotification(`Demonic Heroism on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            player.sajaJinDemonicHeroismActive = true;
            player.sajaJinDemonicHeroismEndTime = now + SAJA_JIN_DEMONIC_HEROISM_DURATION;
            player.sajaJinDemonicHeroismOriginalMaxSpd = player.maxSpd;
            player.maxSpd *= SAJA_JIN_DEMONIC_HEROISM_SPEED_BOOST;

            vfx.sajaJinDemonicAura.push({
                followPlayer: true,
                radius: player.r * 3,
                life: SAJA_JIN_DEMONIC_HEROISM_DURATION,
                t: 0
            });

            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                vfx.sajaJinSoulParticles.push({
                    x: player.x + Math.cos(angle) * player.r,
                    y: player.y + Math.sin(angle) * player.r,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    life: 1200,
                    t: 0,
                    size: Math.random() * 4 + 2
                });
            }

            showNotification('Demonic Heroism activated! 40% speed boost!', 'success');
            sajaJinDemonicHeroismReadyAt = now + ABILITY_COOLDOWN;
        }

        function trySajaJinSoulSuckingShot() {
            const now = performance.now();
            if (currentStyle !== 'saja-jin') return;

            if (now < sajaJinSoulSuckingShotReadyAt) {
                const cooldownLeft = Math.ceil((sajaJinSoulSuckingShotReadyAt - now) / 1000);
                showNotification(`Soul-Sucking Shot on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('Need ball for Soul-Sucking Shot!', 'warning');
                return;
            }

            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            ball.vx = Math.cos(dir) * SAJA_JIN_SOUL_SUCKING_SHOT_POWER;
            ball.vy = Math.sin(dir) * SAJA_JIN_SOUL_SUCKING_SHOT_POWER;
            player.hasBall = false;

            vfx.sajaJinSoulTrail.push({
                end: now + SAJA_JIN_SOUL_SUCKING_TRAIL_DURATION,
                w: 25,
                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--saja-jin-trail-start'),
                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--saja-jin-trail-end')
            });

            ball.hasGhostTrail = true;
            ball.ghostTrailEndTime = now + SAJA_JIN_SOUL_SUCKING_TRAIL_DURATION + 300;

            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    vfx.sajaJinSoulParticles.push({
                        x: ball.x + (Math.random() - 0.5) * 30,
                        y: ball.y + (Math.random() - 0.5) * 30,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 600,
                        t: 0,
                        size: Math.random() * 6 + 3
                    });
                }, i * 50);
            }

            showNotification('Soul-Sucking Shot fired!', 'success');
            sajaJinSoulSuckingShotReadyAt = now + ABILITY_COOLDOWN;
        }

        function trySajaJinHypnoticShot() {
            const now = performance.now();
            if (currentStyle !== 'saja-jin') return;

            if (playerLevel < 10) {
                showNotification('Need to be Level 10 to use Hypnotic Shot!', 'warning');
                return;
            }

            if (now < sajaJinHypnoticShotReadyAt) {
                const cooldownLeft = Math.ceil((sajaJinHypnoticShotReadyAt - now) / 1000);
                showNotification(`Hypnotic Shot on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('Need ball for Hypnotic Shot!', 'warning');
                return;
            }


            player.sajaJinHypnoticShotActive = true;
            player.sajaJinHypnoticShotPhase = 'spinning';
            player.sajaJinHypnoticShotStartTime = now;
            player.sajaJinHypnoticShotSpinAngle = 0;
            
            if (isFinite(player.x) && isFinite(player.y)) {
                player.sajaJinHypnoticShotPlayerCenterX = player.x;
                player.sajaJinHypnoticShotPlayerCenterY = player.y;
            } else {
                player.sajaJinHypnoticShotPlayerCenterX = W / 4;
                player.sajaJinHypnoticShotPlayerCenterY = H / 2;
            }

            ball.vx = 0;
            ball.vy = 0;
            player.hasBall = false;

            for (let i = 0; i < 40; i++) {
                const angle = (Math.PI * 2 * i) / 40;
                const radius = SAJA_JIN_HYPNOTIC_SHOT_SPIN_RADIUS + (i % 3) * 15;
                
                vfx.sajaJinHypnoticGlow.push({
                    x: player.x + Math.cos(angle) * radius,
                    y: player.y + Math.sin(angle) * radius,
                    radius: ball.r * (2 + Math.random()),
                    life: SAJA_JIN_HYPNOTIC_SHOT_SPIN_DURATION * (0.8 + Math.random() * 0.4),
                    t: 0,
                    angle: angle,
                    type: 'init_glow'
                });
            }
            
            vfx.sajaJinHypnoticGlow.push({
                x: player.x,
                y: player.y,
                radius: SAJA_JIN_HYPNOTIC_SHOT_SPIN_RADIUS * 0.8,
                life: SAJA_JIN_HYPNOTIC_SHOT_SPIN_DURATION,
                t: 0,
                type: 'player_aura'
            });
            
            for (let spiral = 0; spiral < SAJA_JIN_HYPNOTIC_SHOT_SPIRAL_LAYERS; spiral++) {
                for (let i = 0; i < 20; i++) {
                    const spiralAngle = (Math.PI * 2 * i / 20) + (spiral * Math.PI * 0.4);
                    const spiralRadius = SAJA_JIN_HYPNOTIC_SHOT_SPIN_RADIUS * (0.5 + spiral * 0.25);
                    
                    vfx.sajaJinHypnoticSpinTrail.push({
                        x: player.x + Math.cos(spiralAngle) * spiralRadius,
                        y: player.y + Math.sin(spiralAngle) * spiralRadius,
                        life: 1000 + spiral * 200,
                        t: 0,
                        angle: spiralAngle,
                        layer: spiral,
                        intensity: 1 - (spiral * 0.2)
                    });
                }
            }

            showNotification('HYPNOTIC SHOT: Ball entranced by Saja Jin\'s mesmerizing power!', 'success');
            sajaJinHypnoticShotReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryLincolnShrekMove() {
            const now = performance.now();
            if (currentStyle !== 'lincoln') return;

            if (!player.hasBall) {
                showNotification('Lincoln needs the ball for his Shrek move!', 'warning');
                return;
            }

            if (now < lincolnShrekMoveReadyAt) {
                const cooldownLeft = Math.ceil((lincolnShrekMoveReadyAt - now) / 1000);
                showNotification(`Shrek Move on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (player.lincolnShrekMoveActive) return;

            player.lincolnShrekMoveActive = true;
            player.lincolnShrekMovePhase = 'shrek1_appear';
            player.lincolnShrekMoveStartTime = now;

            const shrekImg = document.createElement('img');
            shrekImg.src = 'shrek.png';
            shrekImg.style.position = 'fixed';
            shrekImg.style.top = '0';
            shrekImg.style.left = '0';
            shrekImg.style.width = '100vw';
            shrekImg.style.height = '100vh';
            shrekImg.style.objectFit = 'cover';
            shrekImg.style.zIndex = '10000';
            shrekImg.style.pointerEvents = 'none';
            shrekImg.style.opacity = '0';
            shrekImg.style.transition = 'opacity 0.5s ease-in-out';
            document.body.appendChild(shrekImg);
           
            setTimeout(() => shrekImg.style.opacity = '1', 50);

            setTimeout(() => {
                Trycaption('its time to swamp you lincoln...','fade');
            }, 600);
           
            const createSwampWave = (delay = 0) => {
                setTimeout(() => {
                    for (let i = 0; i < 40; i++) {
                        const angle = (Math.PI * 2 * i) / 40;
                        const radius = 100 + Math.random() * 150;
                        vfx.lincolnShrekTrail.push({
                            x: W/2 + Math.cos(angle) * radius,
                            y: H/2 + Math.sin(angle) * radius,
                            vx: Math.cos(angle) * (6 + Math.random() * 6),
                            vy: Math.sin(angle) * (6 + Math.random() * 6),
                            life: 3000,
                            t: 0,
                            size: Math.random() * 12 + 6,
                            color: `hsl(${Math.random() * 30 + 80}, 85%, ${55 + Math.random() * 25}%)`
                        });
                    }
                }, delay);
            };
           
            createSwampWave(0);
            createSwampWave(300);
            createSwampWave(600);
           
            canvas.style.transition = 'filter 0.8s ease-in-out';
            canvas.style.filter = 'brightness(1.3) contrast(1.2) hue-rotate(20deg)';

            setTimeout(() => {
                shrekImg.style.opacity = '0';
                setTimeout(() => {
                    if (document.body.contains(shrekImg)) {
                        document.body.removeChild(shrekImg);
                    }
                }, 500);
               
                player.lincolnShrekMovePhase = 'shrek2_kick';

                const shrek2Img = document.createElement('img');
                shrek2Img.src = 'shrek2.png';
                shrek2Img.style.position = 'fixed';
                shrek2Img.style.top = '50%';
                shrek2Img.style.left = '50%';
                shrek2Img.style.transform = 'translate(-50%, -50%) scale(0.8)';
                shrek2Img.style.width = '300px';
                shrek2Img.style.height = '300px';
                shrek2Img.style.objectFit = 'contain';
                shrek2Img.style.zIndex = '10000';
                shrek2Img.style.pointerEvents = 'none';
                shrek2Img.style.opacity = '0';
                shrek2Img.style.transition = 'all 0.4s ease-out';
                document.body.appendChild(shrek2Img);
               
                setTimeout(() => {
                    shrek2Img.style.opacity = '1';
                    shrek2Img.style.transform = 'translate(-50%, -50%) scale(1)';
                }, 50);

                setTimeout(() => {
                    const goalX = W - margin;
                    const goalY = H / 2;
                    const dir = Math.atan2(goalY - ball.y, goalX - ball.x);
                   
                    ball.vx = Math.cos(dir) * LINCOLN_SHREK2_KICK_POWER;
                    ball.vy = Math.sin(dir) * LINCOLN_SHREK2_KICK_POWER;
                    player.hasBall = false;

                    vfx.trail.push({
                        end: now + 4000,
                        w: 60,
                        colorStart: getComputedStyle(document.documentElement).getPropertyValue('--lincoln-trail-start'),
                        colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--lincoln-trail-end')
                    });
                   
                    for (let layer = 0; layer < 3; layer++) {
                        setTimeout(() => {
                            for (let i = 0; i < 25; i++) {
                                vfx.lincolnShrekParticles.push({
                                    x: ball.x + (Math.random() - 0.5) * (60 + layer * 20),
                                    y: ball.y + (Math.random() - 0.5) * (60 + layer * 20),
                                    vx: (Math.random() - 0.5) * (12 + layer * 3),
                                    vy: (Math.random() - 0.5) * (12 + layer * 3),
                                    life: 2500 + layer * 500,
                                    t: 0,
                                    size: Math.random() * (15 + layer * 3) + 8,
                                    color: `hsl(${Math.random() * 40 + 90}, 100%, ${65 + Math.random() * 20}%)`,
                                    glow: true
                                });
                            }
                        }, layer * 100);
                    }
                   
                    for (let ring = 0; ring < 3; ring++) {
                        for (let i = 0; i < 30; i++) {
                            const angle = (Math.PI * 2 * i) / 30;
                            const radius = (ring + 1) * 50;
                            vfx.lincolnShrekTrail.push({
                                x: ball.x + Math.cos(angle) * radius,
                                y: ball.y + Math.sin(angle) * radius,
                                vx: Math.cos(angle) * (8 + ring * 2),
                                vy: Math.sin(angle) * (8 + ring * 2),
                                life: 2500 - ring * 300,
                                t: 0,
                                size: Math.random() * 10 + 8,
                                color: ring === 0 ? '#4ADF4A' : ring === 1 ? '#32CD32' : '#228B22'
                            });
                        }
                    }
                   
                    canvas.style.animation = 'shake 0.6s ease-in-out';
                    canvas.style.filter = 'brightness(1.6) saturate(1.4) contrast(1.1)';
                   
                    showNotification('🥅 LEGENDARY SHREK KICK! 🥅', 'success');
                }, 400);

                setTimeout(() => {
                    shrek2Img.style.opacity = '0';
                    shrek2Img.style.transform = 'translate(-50%, -50%) scale(1.2)';
                    setTimeout(() => {
                        if (document.body.contains(shrek2Img)) {
                            document.body.removeChild(shrek2Img);
                        }
                        player.lincolnShrekMoveActive = false;
                        player.lincolnShrekMovePhase = '';
                       
                        canvas.style.animation = '';
                        canvas.style.filter = '';
                    }, 500);
                }, 1200);

            }, LINCOLN_SHREK1_DURATION + 500);

            lincolnShrekMoveReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryLincolnKissMove() {
            const now = performance.now();
            if (currentStyle !== 'lincoln') return;

            if (now < lincolnKissMoveReadyAt) {
                const cooldownLeft = Math.ceil((lincolnKissMoveReadyAt - now) / 1000);
                showNotification(`Kiss Move on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (player.lincolnKissMoveActive) return;

            const originalX = player.x;
            const originalY = player.y;
            player._frozenForKissMove = true;
            player._originalX = originalX;
            player._originalY = originalY;

            ball.vx = 0;
            ball.vy = 0;

            player.lincolnKissMoveActive = true;
            player.lincolnKissMovePhase = 'gyat_appear';
            player.lincolnKissMoveStartTime = now;

            const centerX = W/2;
            const centerY = H/2;
            const gyatImg = document.createElement('img');
            gyatImg.src = 'gyat.png';
            gyatImg.style.position = 'fixed';
            gyatImg.style.left = (centerX * (window.innerWidth / W)) + 'px';
            gyatImg.style.top = (centerY * (window.innerHeight / H)) + 'px';
            gyatImg.style.transform = 'translate(-50%, -50%)';
            gyatImg.style.width = '80px';
            gyatImg.style.height = '80px';
            gyatImg.style.objectFit = 'contain';
            gyatImg.style.zIndex = '10000';
            gyatImg.style.pointerEvents = 'none';
            gyatImg.style.animation = 'pulse 0.5s infinite alternate';
            document.body.appendChild(gyatImg);

            Trycaption('oH MY GOODNESS GRACIOUS ITS A GYATT 😳', 'Bounce');
           
            for (let i = 0; i < 10; i++) {
                vfx.lincolnKissHeartParticles.push({
                    x: originalX + (Math.random() - 0.5) * 40,
                    y: originalY + (Math.random() - 0.5) * 40,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3 - 1,
                    life: 2000,
                    t: 0,
                    size: Math.random() * 6 + 3,
                    color: 'pink'
                });
            }
           
            setTimeout(() => {
                if (!gyatImg || !gyatImg.parentElement) return;
               
                Trycaption('nah im just a chill guy', 'fade');
               
                player.x = originalX;
                player.y = originalY;
                player.vx = 0;
                player.vy = 0;
               
                const chillGuyImg = document.createElement('img');
                chillGuyImg.src = 'chillguy.png';
                chillGuyImg.style.position = 'fixed';
               
                const canvasRect = canvas.getBoundingClientRect();
                const playerScreenX = canvasRect.left + (player.x / W) * canvasRect.width;
                const playerScreenY = canvasRect.top + (player.y / H) * canvasRect.height;
               
                chillGuyImg.style.left = playerScreenX + 'px';
                chillGuyImg.style.top = playerScreenY + 'px';
                chillGuyImg.style.transform = 'translate(-50%, -50%)';
                chillGuyImg.style.width = '120px';
                chillGuyImg.style.height = '120px';
                chillGuyImg.style.objectFit = 'contain';
                chillGuyImg.style.zIndex = '10001';
                chillGuyImg.style.pointerEvents = 'none';
                document.body.appendChild(chillGuyImg);

                const maintainFreeze = setInterval(() => {
                    if (chillGuyImg.parentElement && player._frozenForKissMove) {
                        player.x = originalX;
                        player.y = originalY;
                        player.vx = 0;
                        player.vy = 0;
                       
                        const canvasRect = canvas.getBoundingClientRect();
                        const playerScreenX = canvasRect.left + (player.x / W) * canvasRect.width;
                        const playerScreenY = canvasRect.top + (player.y / H) * canvasRect.height;
                       
                        chillGuyImg.style.left = playerScreenX + 'px';
                        chillGuyImg.style.top = playerScreenY + 'px';
                    } else {
                        clearInterval(maintainFreeze);
                    }
                }, 16);

                setTimeout(() => {
                    if (document.body.contains(gyatImg)) {
                        document.body.removeChild(gyatImg);
                    }
                    if (document.body.contains(chillGuyImg)) {
                        document.body.removeChild(chillGuyImg);
                    }
                    clearInterval(maintainFreeze);
                   
                    Trycaption('ok time to get the ball :D','Fade')

                    player._frozenForKissMove = false;
                    player.x = ball.x;
                    player.y = ball.y;
                    player.hasBall = true;
                    player.lincolnKissMoveActive = false;
                    player.lincolnKissMovePhase = '';
                   
                    for (let i = 0; i < 15; i++) {
                        vfx.lincolnKissHeartParticles.push({
                            x: ball.x + (Math.random() - 0.5) * 50,
                            y: ball.y + (Math.random() - 0.5) * 50,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            life: 800,
                            t: 0,
                            size: Math.random() * 5 + 3,
                            color: 'white'
                        });
                    }
                }, 2000);
            }, 1000);

            lincolnKissMoveReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryLincolnGyattShowdown() {
            const now = performance.now();
            if (currentStyle !== 'lincoln') return;

            if (now < lincolnGyattShowdownReadyAt) {
                const cooldownLeft = Math.ceil((lincolnGyattShowdownReadyAt - now) / 1000);
                showNotification(`Gyatt Showdown on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (player.lincolnGyattShowdownActive) return;

            player.lincolnGyattShowdownActive = true;
            player.lincolnGyattShowdownEndTime = now + LINCOLN_GYATT_SHOWDOWN_DURATION;
            player.lincolnGyattShowdownOriginalMaxSpd = player.maxSpd;

            player.maxSpd *= LINCOLN_GYATT_SHOWDOWN_SPEED_MULTIPLIER;

            const gyattImg = document.createElement('img');
            gyattImg.src = 'gyat.png';
            gyattImg.id = 'lincolnGyattImage';
            gyattImg.style.position = 'absolute';
            gyattImg.style.width = '40px';
            gyattImg.style.height = '40px';
            gyattImg.style.objectFit = 'contain';
            gyattImg.style.zIndex = '10000';
            gyattImg.style.pointerEvents = 'none';
            gyattImg.style.opacity = '0.9';
            gyattImg.style.transition = 'opacity 0.3s ease-in-out';
            document.body.appendChild(gyattImg);

            for (let i = 0; i < 50; i++) {
                const angle = (Math.PI * 2 * i) / 50;
                vfx.lincolnGyattParticles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * (5 + Math.random() * 10),
                    vy: Math.sin(angle) * (5 + Math.random() * 10),
                    life: 2000 + Math.random() * 1000,
                    t: 0,
                    size: 4 + Math.random() * 6,
                    hue: 300 + Math.random() * 60
                });
            }

            showNotification('GYATT SHOWDOWN ACTIVATED! 5x shot power, 2x speed!', 'success');
            Trycaption('GYATT MODE ENGAGED! 💪✨', 'Bounce');

            lincolnGyattShowdownReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryAbbyColossalCalves() {
            const now = performance.now();
            if (currentStyle !== 'abby') return;

            if (!player.hasBall) {
                showNotification('Abby needs the ball for Colossal Calves!', 'warning');
                return;
            }

            if (now < abbyColossalCalvesReadyAt) {
                const cooldownLeft = Math.ceil((abbyColossalCalvesReadyAt - now) / 1000);
                showNotification(`Colossal Calves on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const angle = Math.atan2(dy, dx);
           
            player.hasBall = false;
            ball.vx = Math.cos(angle) * 35;
            ball.vy = Math.sin(angle) * 35;
           
            
            for(let i = 0; i < 80; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 150,
                    y: ball.y + (Math.random() - 0.5) * 150,
                    vx: (Math.random() - 0.5) * 25,
                    vy: (Math.random() - 0.5) * 25,
                    life: 80,
                    t: 0,
                    color: 'rgba(255, 20, 147, 0.98)',
                    w: 15
                });
            }
           
            for(let ring = 0; ring < 5; ring++) {
                for(let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const radius = 40 + (ring * 25);
                    vfx.trails.push({
                        x: player.x + Math.cos(angle) * radius,
                        y: player.y + Math.sin(angle) * radius,
                        vx: Math.cos(angle) * (15 + ring * 5),
                        vy: Math.sin(angle) * (15 + ring * 5),
                        life: 70 - ring * 10,
                        t: 0,
                        color: `rgba(255, ${105 + ring * 30}, 180, 0.9)`,
                        w: 14 - ring * 2
                    });
                }
            }
           
            for(let i = 0; i < 35; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 120,
                    y: ball.y + (Math.random() - 0.5) * 120,
                    vx: (Math.random() - 0.5) * 35,
                    vy: (Math.random() - 0.5) * 35,
                    life: 60,
                    t: 0,
                    color: 'rgba(255, 192, 203, 0.95)',
                    w: 12
                });
            }
           
            for(let i = 0; i < 30; i++) {
                vfx.trails.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(i * 0.21) * 30,
                    vy: Math.sin(i * 0.21) * 30,
                    life: 55,
                    t: 0,
                    color: 'rgba(255, 0, 127, 0.85)',
                    w: 16
                });
            }
           
            for(let i = 0; i < 50; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 80,
                    y: ball.y + (Math.random() - 0.5) * 80,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20,
                    life: 50,
                    t: 0,
                    color: 'rgba(255, 255, 255, 0.9)',
                    w: 4
                });
            }

            showNotification('Colossal Calves activated! Powerful shot!', 'success');
            abbyColossalCalvesReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryAbbyPowerPin() {
            const now = performance.now();
            if (currentStyle !== 'abby') return;

            if (!player.hasBall) {
                showNotification('Abby needs the ball for Power Pin!', 'warning');
                return;
            }

            if (now < abbyPowerPinReadyAt) {
                const cooldownLeft = Math.ceil((abbyPowerPinReadyAt - now) / 1000);
                showNotification(`Power Pin on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const angle = Math.atan2(dy, dx);
           
            player.hasBall = false;
            ball.vx = Math.cos(angle) * 28;
            ball.vy = Math.sin(angle) * 28;
           
            ball.abbyPowerPinActive = true;
            ball.abbyPowerPinEndTime = now + 8000;
           
            
            for(let i = 0; i < 60; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 120,
                    y: ball.y + (Math.random() - 0.5) * 120,
                    vx: (Math.random() - 0.5) * 25,
                    vy: (Math.random() - 0.5) * 25,
                    life: 75,
                    t: 0,
                    color: 'rgba(255, 69, 0, 0.98)',
                    w: 14
                });
            }
           
            for(let i = 0; i < 45; i++) {
                const angle = (i / 45) * Math.PI * 2;
                vfx.trails.push({
                    x: ball.x,
                    y: ball.y,
                    vx: Math.cos(angle) * 28,
                    vy: Math.sin(angle) * 28,
                    life: 65,
                    t: 0,
                    color: 'rgba(255, 140, 0, 0.95)',
                    w: 12
                });
            }
           
            for(let i = 0; i < 35; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 90,
                    y: ball.y + (Math.random() - 0.5) * 90,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20,
                    life: 55,
                    t: 0,
                    color: 'rgba(255, 215, 0, 0.95)',
                    w: 10
                });
            }
           
            for(let wave = 0; wave < 4; wave++) {
                for(let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const radius = 30 + (wave * 20);
                    vfx.trails.push({
                        x: ball.x + Math.cos(angle) * radius,
                        y: ball.y + Math.sin(angle) * radius,
                        vx: Math.cos(angle) * (20 + wave * 8),
                        vy: Math.sin(angle) * (20 + wave * 8),
                        life: 60 - wave * 10,
                        t: 0,
                        color: `rgba(255, ${165 - wave * 25}, 0, 0.9)`,
                        w: 12 - wave * 2
                    });
                }
            }
           
            for(let i = 0; i < 40; i++) {
                vfx.trails.push({
                    x: ball.x + (Math.random() - 0.5) * 60,
                    y: ball.y + (Math.random() - 0.5) * 60,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 45,
                    t: 0,
                    color: 'rgba(255, 100, 0, 0.9)',
                    w: 8
                });
            }

            showNotification('Power Pin activated! Ball will stick to walls!', 'success');
            abbyPowerPinReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryAbbyDemonDrive() {
            const now = performance.now();
            if (currentStyle !== 'abby') return;

            if (!player.hasBall) {
                showNotification('Abby needs the ball for Demon Drive!', 'warning');
                return;
            }

            if (now < abbyDemonDriveReadyAt) {
                const cooldownLeft = Math.ceil((abbyDemonDriveReadyAt - now) / 1000);
                showNotification(`Demon Drive on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            player.abbyDemonDriveActive = true;
            player.abbyDemonDrivePhase = 'forward';
            player.abbyDemonDriveStartTime = now;
           
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const angle = Math.atan2(dy, dx);
           
            player.abbyDemonDriveDirection = angle;
            player.abbyDemonDriveStartX = player.x;
            player.abbyDemonDriveStartY = player.y;
           
            const ballOffset = 30;
            ball.x = player.x + Math.cos(angle) * ballOffset;
            ball.y = player.y + Math.sin(angle) * ballOffset;
            ball.vx = 0;
            ball.vy = 0;
           
            
            for(let i = 0; i < 70; i++) {
                vfx.trails.push({
                    x: player.x + (Math.random() - 0.5) * 140,
                    y: player.y + (Math.random() - 0.5) * 140,
                    vx: (Math.random() - 0.5) * 30,
                    vy: (Math.random() - 0.5) * 30,
                    life: 85,
                    t: 0,
                    color: 'rgba(139, 0, 139, 0.98)',
                    w: 18
                });
            }
           
            for(let ring = 0; ring < 6; ring++) {
                for(let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    const radius = 35 + (ring * 20);
                    vfx.trails.push({
                        x: player.x + Math.cos(angle) * radius,
                        y: player.y + Math.sin(angle) * radius,
                        vx: Math.cos(angle) * (25 + ring * 6),
                        vy: Math.sin(angle) * (25 + ring * 6),
                        life: 75 - ring * 8,
                        t: 0,
                        color: `rgba(${75 + ring * 20}, 0, ${130 + ring * 15}, 0.9)`,
                        w: 16 - ring * 2
                    });
                }
            }
           
            for(let i = 0; i < 50; i++) {
                vfx.trails.push({
                    x: player.x + (Math.random() - 0.5) * 100,
                    y: player.y + (Math.random() - 0.5) * 100,
                    vx: (Math.random() - 0.5) * 25,
                    vy: (Math.random() - 0.5) * 25,
                    life: 70,
                    t: 0,
                    color: 'rgba(148, 0, 211, 0.95)',
                    w: 14
                });
            }
           
            for(let i = 0; i < 40; i++) {
                const angle = (i / 40) * Math.PI * 6;
                const radius = 20 + (i * 2);
                vfx.trails.push({
                    x: player.x + Math.cos(angle) * radius,
                    y: player.y + Math.sin(angle) * radius,
                    vx: Math.cos(angle) * 20,
                    vy: Math.sin(angle) * 20,
                    life: 65,
                    t: 0,
                    color: 'rgba(75, 0, 130, 0.9)',
                    w: 12
                });
            }
           
            for(let i = 0; i < 30; i++) {
                vfx.trails.push({
                    x: player.x + (Math.random() - 0.5) * 80,
                    y: player.y + (Math.random() - 0.5) * 80,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 80,
                    t: 0,
                    color: 'rgba(25, 0, 25, 0.8)',
                    w: 6
                });
            }

            showNotification('Demon Drive initiated! Get ready...', 'success');
            abbyDemonDriveReadyAt = now + ABILITY_COOLDOWN;
        }

        function tryKorbinFieryApocalypse() {
            const now = performance.now();
            if (now < korbinFieryApocalypseReadyAt) {
                const cooldownLeft = Math.ceil((korbinFieryApocalypseReadyAt - now) / 1000);
                showNotification(`Fiery Apocalypse on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('need ball for fiery apocalypse fr', 'warning');
                return;
            }

            korbinFieryApocalypseReadyAt = now + KORBIN_FIERY_APOCALYPSE_COOLDOWN;
            
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const angle = Math.atan2(dy, dx);
            
            for (let i = 0; i < 30; i++) {
                const explosionAngle = (Math.PI * 2 * i) / 30;
                const explosionRadius = 30 + Math.random() * 80;
                vfx.korbinFireApocalypseExplosion.push({
                    x: player.x + Math.cos(explosionAngle) * explosionRadius,
                    y: player.y + Math.sin(explosionAngle) * explosionRadius,
                    vx: Math.cos(explosionAngle) * (3 + Math.random() * 6),
                    vy: Math.sin(explosionAngle) * (3 + Math.random() * 6),
                    life: 600 + Math.random() * 200,
                    t: 0,
                    size: 6 + Math.random() * 8,
                    hue: 0 + Math.random() * 60,
                    intensity: 0.8 + Math.random() * 0.2,
                    loop: Math.sin(i * 0.5) * 0.2
                });
            }

            for (let i = 0; i < 25; i++) {
                vfx.korbinFireApocalypseFlames.push({
                    x: player.x + (Math.random() - 0.5) * 120,
                    y: player.y + (Math.random() - 0.5) * 120,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 800 + Math.random() * 300,
                    t: 0,
                    size: 12 + Math.random() * 15,
                    hue: 0 + Math.random() * 45,
                    intensity: 0.8 + Math.random() * 0.2,
                    loop: Math.cos(i * 0.3) * 0.3
                });
            }

            for (let i = 0; i < 40; i++) {
                vfx.korbinFireApocalypseEmbers.push({
                    x: player.x + (Math.random() - 0.5) * 150,
                    y: player.y + (Math.random() - 0.5) * 150,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1000 + Math.random() * 600,
                    t: 0,
                    size: 2 + Math.random() * 5,
                    hue: 15 + Math.random() * 30,
                    gravity: 0.08,
                    intensity: 0.7 + Math.random() * 0.3,
                    loop: Math.sin(i * 0.1) * 0.15
                });
            }

            for (let wave = 0; wave < 3; wave++) {
                for (let i = 0; i < 20; i++) {
                    const shockAngle = (Math.PI * 2 * i) / 20;
                    vfx.korbinFireApocalypseShockwave.push({
                        x: player.x + Math.cos(shockAngle) * (wave * 30),
                        y: player.y + Math.sin(shockAngle) * (wave * 30),
                        vx: Math.cos(shockAngle) * (15 + wave * 3),
                        vy: Math.sin(shockAngle) * (15 + wave * 3),
                        life: 400 - wave * 50,
                        t: 0,
                        size: 10 - wave * 2,
                        hue: 0 + wave * 15,
                        intensity: 1.0 - wave * 0.15,
                        delay: wave * 40,
                        loop: Math.sin(shockAngle * 2 + wave) * 0.3
                    });
                }
            }

            player.hasBall = false;
            ball.vx = Math.cos(angle) * KORBIN_FIERY_APOCALYPSE_DAMAGE * 20;
            ball.vy = Math.sin(angle) * KORBIN_FIERY_APOCALYPSE_DAMAGE * 20;

            for (let i = 0; i < 15; i++) {
                vfx.korbinFireApocalypseTrail.push({
                    x: ball.x + (Math.random() - 0.5) * 25,
                    y: ball.y + (Math.random() - 0.5) * 25,
                    vx: ball.vx * 0.2 + (Math.random() - 0.5) * 6,
                    vy: ball.vy * 0.2 + (Math.random() - 0.5) * 6,
                    life: 600,
                    t: 0,
                    size: 6 + Math.random() * 8,
                    hue: 0 + Math.random() * 60,
                    intensity: 0.8,
                    loop: Math.sin(i * 0.2) * 0.2
                });
            }

            showNotification('FIERY APOCALYPSE UNLEASHED!', 'success');
        }

        function tryKorbinBigBackPower() {
            const now = performance.now();
            if (now < korbinBigBackPowerReadyAt) {
                const cooldownLeft = Math.ceil((korbinBigBackPowerReadyAt - now) / 1000);
                showNotification(`Big Back Power on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            
            korbinBigBackPowerReadyAt = now + KORBIN_BIG_BACK_POWER_COOLDOWN;
            player.korbinBigBackPowerActive = true;
            player.korbinBigBackPowerEndTime = now + KORBIN_BIG_BACK_POWER_DURATION;
            player.korbinBigBackPowerStunned = true;
            
            player.korbinBigBackPowerOriginalMaxSpd = player.maxSpd;
            player.maxSpd = KORBIN_BIG_BACK_POWER_SPEED;
            
            let dirX = 0, dirY = 0;
            if (Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.1) {
                const speed = Math.hypot(player.vx, player.vy);
                dirX = player.vx / speed;
                dirY = player.vy / speed;
            } else {
                const dx = mouse.x - player.x;
                const dy = mouse.y - player.y;
                const distance = Math.hypot(dx, dy);
                if (distance > 0) {
                    dirX = dx / distance;
                    dirY = dy / distance;
                } else {
                    dirX = 1;
                    dirY = 0;
                }
            }
            
            player.korbinBigBackPowerDirection = { x: dirX, y: dirY };
            
            player.vx = dirX * KORBIN_BIG_BACK_POWER_SPEED;
            player.vy = dirY * KORBIN_BIG_BACK_POWER_SPEED;
            
            if (player.hasBall) {
                ball.korbinBigBackProtected = true;
            }
            
            showNotification('BIG BACK POWER! Press SPACE to stop!', 'success');
        }

        function stopKorbinBigBackPower() {
            if (!player.korbinBigBackPowerActive) return;
            
            player.korbinBigBackPowerActive = false;
            player.korbinBigBackPowerStunned = false;
            
            player.maxSpd = player.korbinBigBackPowerOriginalMaxSpd;
            
            player.vx = 0;
            player.vy = 0;
            
            if (ball.korbinBigBackProtected) {
                ball.korbinBigBackProtected = false;
            }
            
            createKorbinWindShockwave();
            
            showNotification('WIND SHOCKWAVE!', 'success');
        }

        function createKorbinWindShockwave() {
            for (let wave = 0; wave < 4; wave++) {
                for (let i = 0; i < 25; i++) {
                    const angle = (Math.PI * 2 * i) / 25;
                    vfx.korbinBigBackPowerShockwave.push({
                        x: player.x + Math.cos(angle) * (wave * 20),
                        y: player.y + Math.sin(angle) * (wave * 20),
                        vx: Math.cos(angle) * (20 + wave * 5),
                        vy: Math.sin(angle) * (20 + wave * 5),
                        life: 800 - wave * 100,
                        t: 0,
                        size: 15 - wave * 2,
                        intensity: 0.9 - wave * 0.15,
                        delay: wave * 50,
                        loop: Math.sin(angle * 3 + wave) * 0.4
                    });
                }
            }
            
            for (let i = 0; i < 40; i++) {
                vfx.korbinBigBackPowerWindBurst.push({
                    x: player.x + (Math.random() - 0.5) * 60,
                    y: player.y + (Math.random() - 0.5) * 60,
                    vx: (Math.random() - 0.5) * 30,
                    vy: (Math.random() - 0.5) * 30,
                    life: 600 + Math.random() * 400,
                    t: 0,
                    size: 8 + Math.random() * 12,
                    intensity: 0.7 + Math.random() * 0.3,
                    spiral: Math.random() * Math.PI * 2
                });
            }
        }

        function tryKorbinBigShot() {
            const now = performance.now();
            if (now < korbinBigShotReadyAt) {
                const cooldownLeft = Math.ceil((korbinBigShotReadyAt - now) / 1000);
                showNotification(`Big Shot on cooldown for ${cooldownLeft}s`, 'error');
                return;
            }

            if (!player.hasBall) {
                showNotification('need ball for big shot fr', 'warning');
                return;
            }

            korbinBigShotReadyAt = now + KORBIN_BIG_SHOT_COOLDOWN;
            
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            const angle = Math.atan2(dy, dx);
            
            for (let i = 0; i < 35; i++) {
                const windAngle = (Math.PI * 2 * i) / 35;
                const windRadius = 40 + Math.random() * 60;
                vfx.korbinBigShotWindParticles.push({
                    x: player.x + Math.cos(windAngle) * windRadius,
                    y: player.y + Math.sin(windAngle) * windRadius,
                    vx: Math.cos(windAngle) * (2 + Math.random() * 4),
                    vy: Math.sin(windAngle) * (2 + Math.random() * 4),
                    life: 800 + Math.random() * 400,
                    t: 0,
                    size: 4 + Math.random() * 6,
                    opacity: 0.7 + Math.random() * 0.3,
                    swirl: Math.random() * Math.PI * 2
                });
            }

            for (let i = 0; i < 20; i++) {
                vfx.korbinBigShotWindSwirls.push({
                    x: player.x + (Math.random() - 0.5) * 100,
                    y: player.y + (Math.random() - 0.5) * 100,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 1000 + Math.random() * 600,
                    t: 0,
                    size: 8 + Math.random() * 12,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.3,
                    opacity: 0.6 + Math.random() * 0.4
                });
            }
            
            player.hasBall = false;
            ball.vx = Math.cos(angle) * KORBIN_BIG_SHOT_DAMAGE * 22;
            ball.vy = Math.sin(angle) * KORBIN_BIG_SHOT_DAMAGE * 22;
            
            for (let i = 0; i < 15; i++) {
                vfx.korbinBigShotWindTrail.push({
                    x: ball.x - Math.cos(angle) * i * 8,
                    y: ball.y - Math.sin(angle) * i * 8,
                    vx: Math.cos(angle) * (5 - i * 0.3),
                    vy: Math.sin(angle) * (5 - i * 0.3),
                    life: 600 + Math.random() * 200,
                    t: 0,
                    size: 12 - i * 0.6,
                    opacity: (15 - i) / 15 * 0.8,
                    windForce: 1.0 - i * 0.05
                });
            }
            
            showNotification('BIG SHOT UNLEASHED!', 'success');
        }
    
    </script>
</body>
</html>
